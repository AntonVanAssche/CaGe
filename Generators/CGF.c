/* CGF.c (Cubic maps with given Genus and Face sizes) */
/* Version 2.0 */
/* Thomas Harmuth */
/* 20.Juni 1997 */

/* 23.10.2008: alle mit NOTIMES modifizierte Teile von Gunnar Brinkmann zugefuegt. 
               Die Absicht ist, dass es mit -DNOTIMES auch auf Windows compiliert 
	       werden kann. 
*/

/* Dieses Programm generiert 3-regulaere Karten mit vorgegebenem
   Geschlecht und vorgegebenen Flaechen. Bedienung siehe Anleitung. */

/* "????": Stellen, die noch behandelt werden koennen */
/* "!!!!": Stellen, die noch behandelt werden muessen */
/* "####": Anregungen fuer die Zukunft                */

/* Im folgenden wird in der Regel zwischen "Bordercode" und "Randcode"
   unterschieden: Ein "Randcode" enthaelt die Informationen zu EINEM Rand,
   ein "Bordercode" die Informationen zu ALLEN Raendern eines Patches. */
/* Im Gegensatz zu CPF kann es beim Begriff "Uhrzeigersinn" zu Verwirrung
   kommen, da die Patches bzw. Karten nicht immer elegant gezeichnet werden
   koennen. "Uhrzeigersinn" meint dasselbe wie bei CPF: Wenn man den Rand
   eines Patches nach aussen zeichnet, passt der Begriff, ansonsten muss man
   GEGEN den Uhrzeigersinn laufen. Generell heisst "im Uhrzeigersinn" also:
   Man laeuft in dieselbe Richtung, in der die Randcodierung gebildet wird. */
/* "Graph" bedeutet "Karte"                                                 */
/* Hoechste vergebene Fehlernummer:  225                                    */

/* Es gibt folgende Patchvermeidungskriterien:
    0 = Genuskriterium 
    2 = schwaches Eulerkriterium in Teil 1 der Rekursion
    3 = Eulerkriterium in Teil 2 der Rekursion
    4 = erweitertes Eulerkriterium ("flaechenvorausschau_ok")
    5 = Bruchkantenkriterium (nur bei top-down)
   10 = Vollstaendigkeitskriterium  (Rekursion - nur bei bottom-up)
   11 = erweitertes Vollstaendigkeitskriterium (nur bei bottom-up)
        bzw. Kriterium der kritischen Punkte 2 (nur bei top-down)
   0-4 werden immer angewendet. Dies ist UNBEDINGT erforderlich, weil ein
       Bordercode, der zu lang werden wuerde (und damit nicht mehr in das
       fuer ihn vorgesehene Array passen wuerde) unbedingt aussortiert werden
       muss, bevor er gebildet wird. Dies geschieht durch Kriterium 4. Falls
       naemlich ein Bordercode zu lang wird, klappt auch das Eulerkriterium
       nicht mehr.
       Frueher gab es das sogenannte Kriterium der kritischen Punkte. Das
       war aber aeusserst schwach (mit ziemlicher Sicherheit schwaecher als
       das Eulerkriterium) und galt nur fuer simple Karten. Deshalb wurde es
       'rausgeschmissen.                                                    */

/* Ein wenig Terminologie-Vergleich zwischen hiesigen Begriffen und 
   Begriffen in der Dissertation: */
/* Bauchbinde    -> Jordan curve path
   Sandwich      -> sandwich path
   Brille        -> dumbbell path
   Durchschnitt  -> intersection
   Einschluss    -> enclosure
   Fall 1        -> linkage
   Randcode      -> canonical boundary code of a boundary face
   Bordercode    -> boundary code of a patch (wobei am Anfang des Codes nicht 
                    die Anzahlen der Bruchkanten in den einzelnen Raendern, 
                    sondern die kumulierten Anzahlen stehen)
   Bruchkante,
   break edge    -> convex edge 
   planarcode    -> vertex code
   embedcode     -> edge code (oder vertex code, falls in Wirklichkeit
                    der klassische planarcode berechnet wird) 
   Stammpatch    -> permanent patch                                   */

/* #### Option "girth" einfuehren:  Mindest-Taillenweite
   - kann auch schon in Patches ueberprueft werden
   - nur sinnvoll, wenn girth<=small_face
   - kann auch zur Ueberpruefung des wahren Genus herangezogen werden
     (Thomassen) */
/* #### Fuer Stammpatches: 
   - evtl. anstelle Berechnung der Vorgaengercodes beidseitig verknuepften
     Patchbaum einfuehren, mit dessen Hilfe man Weg zur Wurzel verfolgen kann.
     Time - Space - Tradeoff  */

/*************/
/* Includes: */
/*************/

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <limits.h>

#ifndef NOTIMES
#include <time.h>
#include <sys/times.h>
#include <signal.h>
#include <sys/time.h>
#endif //NOTIMES

#include <string.h>
#include <memory.h>

#include <sys/stat.h>
//#include <malloc.h>
#include <unistd.h>


/******************************************/
/* User-modifizierbare define-Konstanten: */
/******************************************/

#define N_MAX    2000   /* maximal moegliche Anzahl der Knoten in einer Karte */
#define N_MAX_P  (3*N_MAX)  
                       /* maximal moegliche Anzahl der Knoten in einem Patch */
#define CODESIZE_MAX_P  (N_MAX*9+1)
  /* maximal moegliche embed_code-Laenge in einem Patch: Erlaeuterung siehe
     Definition von POSTYP */
#define F_MAX    170        /* Maximale Groesse einer Flaeche */ 
#define G_MAX    5         /* Maximal moegliches Geschlecht */
#define V_MAX    10        /* Fuer einen Patch werden alle moeglichen Ver-
 knuepfungen gespeichert, jedoch maximal V_MAX-1 gleichartige Verknuepfungen. 
 V_MAX muss also mindestens 1 sein. */
#define LINELEN 2000       /* fuer Strings */
#define MAXFTYPEN 170        /* maximale Anzahl verschiedener Flaechentypen */
#define MEMBLOCKSIZE 131072L /* Groesse eines dynamischen Speicherblocks */ 
                      /* Mindestgroesse: Groesse des groessten Elements */
#define CHECKLISTLEN 100      /* maximal gespeicherte gute Verzweigungen in 
                                 einem History-Level */

#define DURCHSCHNITT 0      /* Verklebungsarten */
#define EINSCHLUSS   1
#define VERBINDUNG   2


/* -------------------- */
/* Ausgabe von Graphen: */
/* -------------------- */

#define OUTPUT_ONE_ROW 2000   /* Anzahl der Bytes, die auf einmal geschrieben
                                 werden (klein, um interrupted system call
                                 bei fwrite zu vermeiden) */
   
/* --------------------------- */
/* Erstellung eines Dumpfiles: */
/* --------------------------- */

#define SICHERUNGSINTERVALL 2000
   /* At most "Sicherungsintervall" seconds between two savings */


/*******************************************/
/* nicht modifizierbare define-Konstanten: */
/*******************************************/

#define F_MAXANZ ((N_MAX>>1)+2) /* Maximal moegliche Anzahl der Flaechen
                                   (kann nur bei Geschlecht 0 ueberhaupt
                                    erreicht werden) */
#define FL_MAX   UCHAR_MAX     /* absolutes Limit fuer eine Flaeche, wobei
                                  unsigned char der Typ einer Flaeche ist */
#define KN_MAX   USHRT_MAX/2   /* absolutes Limit fuer die Knotenzahl, wobei
                                  unsigned short der Typ eines Knotens ist */
/*  - Eine Division durch 2 ist mindestens 
      notwendig, damit beim Addieren zweier Zahlen vom Typ KNOTENTYP die
      hoechste erlaubte Zahl nicht ueberschritten wird (z.B. beim Zusammen-
      naehen von Patches, wenn die Knotenzahlen addiert werden). Allerdings ist
      dies nur von Belang, wenn auch das Ergebnis in einer Variablen vom Typ
      KNOTENTYP gespeichert wird.
    - Eine Division durch 2 ist mindestens notwendig, damit eine Variable
      vom Typ EULERTYP den Inhalt einer Variablen vom Typ KNOTENTYP uebernehmen
      kann. 
    - Eine Division durch 3/2 waere mindestens notwendig, damit die Nummer
      einer Kante im embed_code noch in den KNOTENTYP passt.
    - Eine Substraktion mit 3 waere mindestens notwendig, weil der Bordercode
      eines n-Ecks die Laenge n+3 besitzt (siehe Ausfuehrungen zur Funktion
      "generiere_patches"). */
#define GEN_MAX  KN_MAX/12
  /* Absolutes Limit fuer das Geschlecht, damit die Anzahl der kritischen
     Punkte in eine Variable vom Typ KNOTENTYP passt (siehe "krit_max"). */

#define False    0
#define True     1
#define nil      0
#define PV_DEFAULT 20     /* default-Wert fuer Option "pv" */
#define BB_KENNUNG N_MAX_P+1   /* mit diesem Wert beginnt ein BB-Randcode */
  /* Der Wert 0 ist nicht mehr erlaubt. Zwar koennte (0,0) eindeutig als
     Bruchkantencode und (0,x),x>0 eindeutig als BB-Code identifiziert werden,
     aber dann wird's kompliziert mit den Abfragen. Ohne 0 wird stattdessen
     einfacher:  aus code[0]==BB_KENNUNG folgt codelen==2.
     Erlaubt sind nunmehr alle Werte > N_MAX_P (maximale Knotenzahl in Patch 
     >= maximale Anzahl Bruchkanten) */
#define HISTORYLEN MAX(F_MAXANZ+G_MAX*2,3*N_MAX+3)
  /* maximale Groesse des Arrays "history" und verwandter Arrays. 
     - Fuer die Rekursion bottom-up: "F_MAXANZ+G_MAX*2" ist die Maximalzahl
       Verklebungen fuer EINEN brauchbaren Patch, da bei jeder Verklebung
       entweder die Anzahl der Flaechen, die Anzahl der Raender oder das 
       Geschlecht erhoeht wird.
     - Fuer die Rekursion top-down: "3*N_MAX/2" ist die Maximalzahl 
       Zerschneidungen in einer Karte, da 3*N_MAX/2 die Maximalzahl
       Kanten in einer Karte ist und bei jeder Zerschneidung 
       mindestens eine Kante betroffen ist. Zerschnittene Kanten sind 
       anschliessend keine
       inneren Kanten mehr und damit nicht an weiteren Zerschneidungen
       beteiligt. Bei jeder Zerschneidung koennen maximal zwei Patches 
       entstehen. Deshalb maximal 3*N_MAX/2*2 = 3*N_MAX Eintraege.
       Hinzu kommen bis zu 3 Eintraege fuer die Ausgangspatches */ 
#define ACCEPTLEN ((N_MAX_P/2)/8+1)
  /* maximale Groesse des Arrays "akzeptiert" fuer einen Patch: theoretisch
     kann maximal jeder zweite Knoten markiert werden. */
#define R_ARRAY ((G_MAX>>3)+1)  /* Groesse eines Arrays, das fuer jeden Rand
                                   ein Flag speichern soll */

#ifndef NOTIMES
#if !defined(CLK_TCK) && !defined(_SC_CLK_TCK)
#include <time.h>
#endif
#if !defined(CLK_TCK) && !defined(_SC_CLK_TCK)
#include <unistd.h>
#endif
#if !defined(CLK_TCK) && defined(_SC_CLK_TCK)
#define CLK_TCK sysconf(_SC_CLK_TCK)
#endif
#ifndef CLK_TCK
#define CLK_TCK 60     /* If the CPU time stated by the program appears
                      to be out by a constant ratio, the most likely
                      explanation is that the code got to this point but
                      60 is the wrong guess.  Another common value is 100. */
#endif
#define time_factor CLK_TCK
#endif //NOTIMES



/***********/
/* Makros: */
/***********/

#define CODESIZE(n) (((size_t)(n)<<2)+1)  
   /* Laenge eines planarcodes fuer 3-regulaere Karten mit n Knoten und
      beliebigem Geschlecht g. */
   /* Dies ist gleichzeitig eine obere Schranke fuer die Laenge des
      Dualen, denn die Anzahl der Eintraege im Dualen ist:
         1           (Flaechenzahl)
      +  f           (Anzahl der abschliessenden Nullen)
      +  \sum i*p_i  (Adjazenzen zwischen Flaechen)
      mit \sum i*p_i = \sum (i-6)*p_i + \sum 6*p_i 
                     =     -12+12*g   +     6f
      Also 1 + f + \sum i*p_i = 7f - 11 + 12*g = 7*(n/2+2-2*g) - 11 + 12*g =
       7/2*n + 3 - 2*g <= 7/2*n + 3 <= CODESIZE(n) */
#define MIN(a,b) ((a)<(b) ? (a) : (b))
#define MAX(a,b) ((a)<(b) ? (b) : (a))
#define ABS(a)   ((a)<0 ? -(a) : (a))
#define ARRAYPOS_N(ge,nv) (((ge)-genus_anf_usr)*(((n_end_usr-n_anf_usr)>>1)+1)+(((nv)-n_anf_usr)>>1))
        /* dieses Makro gibt die Position in einem Statistikarray fuer das
           Geschlecht "ge" und Knotenzahl "nv" an */
#define ARRAYPOS_LN(ge,nv,x)  (3*ARRAYPOS_N((ge),(nv))+(x)-1)
        /* dieses Makro gibt die Position in einem Statistikarray fuer das
           Geschlecht "ge", die Knotenzahl "nv" und die Unterteilung "x", die
           zwischen 1 und 3 variieren darf, an (z.B. x=Nahttyp, x=Zsh-zahl). */
#define ARRAYPOS_F(ge,fl)  ((ge)*((n_end_usr>>1)+2) + (fl) - 1)  
        /* dieses Makro gibt die Position in einem Statistikarray fuer das
           Geschlecht "ge" und die Flaechenzahl "fl" an. Bei dem Statistik-
           array ist das minimale Geschlecht immer 0 und die kleinste 
           Flaechenzahl immer 1.  */
 /* Wichtig: fuer jedes Statistikarray passt genau EINES der obigen Makros! */
#define NON_ISO_RAND(e,n) ((((e)->iso_rand)[(n)>>3]) & (1<<((n)&7)))  
   /* gibt an, ob der n-te Rand des Patches e nicht
      isomorph zu seinen uebergeordneten Raendern ist */
#define SET_ISO_RAND(e,n) ((((e)->iso_rand)[(n)>>3]) &= ~(1<<((n)&7)))
   /* loescht das zum n-ten Rand des Patches e gehoerige Bit (das bedeutet: 
      der Rand ist isomorph zu seinem uebergeordneten Rand) */
#define SET_ACCEPT(a,n) ((a[(n)>>3]) |= (1<<((n)&7)))
   /* setzt das zur n-ten moeglichen Markierung in einem Patchrand (Rand 2 
      bei Fall 1) gehoerige Bit (das bedeutet: wenn die Markierung an dieser
      Stelle gesetzt wird, wird der Patch akzeptiert). "a" ist ein Array. */
#define IS_ACCEPTED(a,n) ((a[(n)>>3]) & (1<<((n)&7)))
   /* gibt an, ob die n-te moegliche Markierung akzeptiert wird */
#define SET_PATCH1(a,n) ((a[(n)>>3]) &= ~(1<<((n)&7)))
#define SET_PATCH2(a,n) ((a[(n)>>3]) |= (1<<((n)&7)))
#define IS_PATCH1(a,n)  (((a[(n)>>3]) & (1<<((n)&7)))==0)
#define IS_PATCH2(a,n)  ((a[(n)>>3]) & (1<<((n)&7)))
   /* fuer die Zuweisung eines Randes zu einem Patch bei einer
      Zerschneidung */
#define ERMITTLE_ANZ_BK(code) (code[code[0]+1] - code[0] - 2 - (ermittle_anz_bb(code)<<1))
/*  ermittelt die Anzahl der Bruchkanten in einem Patch mit
    Bordercode "code".  */
#define ANZ_BK_BEREINIGT(bk,g,r) ((bk) + 6*((r)-1) + 12*(g)) 
/* Wenn "bk" die Anzahl der Bruchkanten in einem Patch mit "r" Raendern und
   Geschlecht "g" ist, so gibt dieses Makro die Anzahl der Bruchkanten zurueck,
   die der Patch hat, wenn er so oft zerschnitten wurde,
   dass er Geschlecht 0 und einen Rand hat. */ 
#define ERMITTLE_FD(g,code) (12*(1-(POSTYP)(g)) - 6*(POSTYP)(code[0]) - (POSTYP)ERMITTLE_ANZ_BK(code))
/* ermittelt die Flaechenformeldifferenz in einem Patch mit
   Geschlecht "g" und Bordercode "code". */
#define LOWER_FLAECHENTERM(g,r,n) ((EULERTYP)((((n)+1)>>1)+2-((g)<<1)-(r)))
  /*  Errechnet einen Term, der als minimale Flaechenzahl-Grenze 
      interpretiert werden kann. Der Cast-Operator ist oberwichtig! */
#define UPPER_FLAECHENTERM(g,r,n) ((EULERTYP)(((n)>>1)+2-((g)<<1)-(r)))
  /*  Errechnet einen Term, der als maximale Flaechenzahl-Grenze 
      interpretiert werden kann. Der Cast-Operator ist oberwichtig! */
#define INNERE_KNOTEN(g,fl,r,anz3) ((EULERTYP)((((r)+(fl))<<1) + ((g)<<2) - 4 - (anz3)))
  /*  Errechnet die Anzahl der inneren Knoten eines Patches mit "fl" Flaechen,
      Genus "g", "r" Raendern und "anz3" 3-valenten Randknoten.
      Der Cast-Operator ist oberwichtig! */
#define FLAECHEN(g,r,n1,n3) ((EULERTYP)(((n1)+(n3)>>1) + 2 - (r) - ((g)<<1)))
  /* Errechnet die Anzahl der Flaechen eines Patches mit Geschlecht "g",
     "r" Raendern, "n1" inneren Knoten und "n3" 3-valenten Randknoten.
     Der Cast-Operator ist oberwichtig! */
#define SET_KP_MOEGLICH(fl,bk,kp) (kp_moeglich[fl][(int)(bk)+((int)(kp)>>3)*(bk_max+1)] |= (1<<((kp)&7)))
#define IS_KP_MOEGLICH(fl,bk,kp) (kp_moeglich[fl][(int)(bk)+((int)(kp)>>3)*(bk_max+1)] & (1<<((kp)&7)))
  /* fuer das Belegen und Auslesen von "kp_moeglich" */


/**********************/
/* Typ-Deklarationen: */
/**********************/

typedef char BOOL;                 /* von 0 verschieden entspricht True, 
   es sollen aber nur die Werte 0 und 1 benutzt werden, um mit dem Wahr-
   heitswert rechnen zu koennen. */
typedef unsigned short KNOTENTYP;  /* fuer Knotennummern und Randcodierungen */
typedef unsigned char FLAECHENTYP;   /* fuer die Groesse einer Flaeche */
typedef signed short EULERTYP;       /* fuer Zahlen, die mit KNOTENTYP
                          assoziiert werden und negativ werden koennen */
typedef int POSTYP;   /* fuer die Angabe einer Position innerhalb eines Arrays
    von KNOTENTYPen oder EULERTYPen. Es wird vorausgesetzt, dass POSTYP 
    zweimal so grosse Werte aufnehmen kann wie KNOTENTYP (wegen der Groesse des
    Arrays KANTENARRAY) und auch negative Werte speichern kann.
  - Mindestens dreimal so grosse Werte + 1 sind notwendig, damit jede 
    Position in einem Patchcode (embed_code) angesprochen werden kann, denn 
    Anzahl Eintraege<>0 = Anzahl Kanten <= Maximalzahl gerichteter Kanten in 
    einem Patch <= 2*Anzahl gerichteter Kanten in einer Karte (jede Kante darf
    theoretisch einmal aufgeschnitten werden) = 2*3*N_MAX = 2*N_MAX*P.
    Hinzu kommen N_MAX_P abschliessende Nullen => Patchcode hat maximal
    1 + 3*N_MAX_P Eintraege.  
  - Mindestens dreimal so grosse Werte sind notwendig, weil die Randcodes,
    die eine Laenge von N_MAX_P haben koennen, dreimal hintereinander
    gespeichert werden. */

typedef struct borderpos {   /* zur Speicherung von Randnummer und Position */
          KNOTENTYP nr;      /* Nummer des Randes im betrachteten Patch
                                (Numerierung beginnt mit 0). Falls Fall 1 
                                vorliegt und diese Struktur zum Element j
                                gehoert: Anzahl der Kanten gegen den
                                Uhrzeigersinn vom Auftreffpunkt der Naht zum
                                markierten Knoten (im zweiten Rand, also BEVOR
                                aufgetrennt wird). */    
          KNOTENTYP pos;     /* Position im betrachteten Rand (Numerierung
                                beginnt mit 0) */
	} BORDERPOS;

typedef struct elem {          /* zur Speicherung eines Patches */ 
          struct elem *next;   /* naechster Patch mit demselben Bordercode */
          struct elem *prev1;  /* Zeiger auf den ersten Vorgaenger oder nil,
                                  gdw. es keinen Vorgaenger gibt. */
          struct elem *prev2;  /* Zeiger auf den zweiten Vorgaenger oder nil,
                                  gdw. es hoechstens einen Vorgaenger gibt. */
          KNOTENTYP *flaechenzahl;    /* Zeiger auf Array mit Flaechenzahlen */
          /*unsigned long nr; */ /* zu Testzwecken: Nummer des Patches in der
                                  Reihenfolge der Generierung */    
          BORDERPOS i;         /* falls Vorgaenger vorhanden: Nummer und
                                  Drehung des ersten Vorgaengerrandes,
                                  falls prev1==nil: Die Struktur
                                  repraesentiert ein (i.nr)-Eck */
          BORDERPOS j;         /* Falls Vorgaenger vorhanden: Nummer und
                                  Drehung des zweiten Vorgaengerrandes.
                                  Fall 1: siehe Typdefinition BORDERPOS */
          POSTYP his_nr;   /* fuer top-down: Position im History-Array. 
            Falls das Element zu einem Stammpatch gehoert, ist der Wert nur 
            wichtig, sofern der Stammpatch gerade an der Konstruktion 
            beteiligt ist. */
          KNOTENTYP nahtlen;  /* Laenge der Naht, falls Vorgaenger vorhanden */
          KNOTENTYP ziellen;  /* Laenge der Schleife bzw. Abstand von der
                                 Grundkante (bei Fall 1 die des Zielrandes) 
                                 zum Nahtende (im Uhrzeigersinn) */
          KNOTENTYP zielrand;  /* Nummer des Randes, an dem die Naht endet */  
                               /* nur bei Fall 1 */
          unsigned char aufteilung[R_ARRAY];  /* Verteilung der Raender an die
                                  Vorgaenger (falls 2 Vorgaenger) */
          unsigned char vorg;  /* Anzahl der Vorgaenger (0-2) */
             /* nur wichtig bei top-down, falls art!=VERBINDUNG */
             /* Wert kann nicht durch e->prev2 ersetzt werden, da dieser
                Wert erst gesetzt wird, wenn diverse Vorberechnungen
                durchgefuehrt worden sind, bei denen der "vorg"-Wert
                bereits gebraucht wird. */
          unsigned char art;   /* Art der Verknuepfung: 
             DURCHSCHNITT (0), EINSCHLUSS (1) oder VERBINDUNG (2) ("Fall 1")
             Der genaue Fall ergibt sich aus "art" und den Werten von
             "prev1", "prev2", "nahtlen" und "ziellen" */
          unsigned char iso_rand[R_ARRAY];
            /* fuer jeden Rand (maximal G_MAX+1) ein Bit, das angibt, ob der
               Rand isomorph zu einem ranghoeheren Rand ist (=0) oder nicht 
               (=1) */  
          BOOL stamm;       /* True => Patch ist im Patchbaum gespeichert,
                               False => Patch ist in history gespeichert */
          char test; /* Bit 0 gesetzt:  Patch wurde mittelbar benutzt */
                     /* Bit 1 gesetzt:  Patch wurde unmittelbar benutzt */ 
        } ELEM;

typedef union baumzeiger{
          struct elem *firstpatch;  
                 /* zugehoerige Patches (nil = noch keine gefunden) */
          struct treenode *nextlevel; 
               /* weitere Patches mit laengerem Code */
        } BAUMZEIGER;
/* "firstpatch" und "nextlevel" schliessen sich gegenseitig aus. Ist naemlich
   ein Patch erreicht, so steht dessen Bordercodelaenge fest. Da diese aber
   auch im Bordercode selbst gespeichert ist, so muessen alle Patches, die bis 
   hierhin den uebereinstimmenden Bordercode haben, auch an diesem Knoten
   gespeichert sein.
   Es gilt sogar noch mehr:  GENAU einer der beiden Werte wird benutzt.
   Waeren naemlich beide Werte ==nil, so waere ein Zweig ins Leere konstruiert
   worden. Aber es wird ja kein Zweig konstruiert, der nicht auch benutzt 
   wird. */

typedef struct treenode {     /* Verzweigung im Patchbaum */
          struct treenode *next;   
               /* fuer naechsten Zweig mit bis dahin gleichem Code */
          BAUMZEIGER weiter;   /* weitere Verzweigungen */
          KNOTENTYP code;  /* naechster Eintrag des Bordercodes */
        } TREENODE;

typedef struct stattreenode {   /* Verzweigung im Baum mit Flaechenstatistik */
          struct stattreenode *next;   
               /* fuer naechsten Zweig mit bis dahin gleichem Pfad */
          unsigned long zaehler; 
               /* Anzahl der Karten mit zugehoerigen Flaechen */  
          struct stattreenode *nextlevel;  
               /* weitere Knoten mit laengerem Pfad */
          FLAECHENTYP code;   /* aktueller Pfadeintrag (Flaechengrad) */
        } STATTREENODE;

typedef struct kante {    /* Kante einer Karte (wird gerichtet behandelt) */
          struct kante *prev;    /* vorherige Kante im Uhrzeigersinn */
          struct kante *next;    /* naechste Kante im Uhrzeigersinn */
          struct kante *invers;  /* inverse Kante (name->ursprung) */
          KNOTENTYP ursprung;    /* (ursprung->name) ist die Kante im Graph, */
          KNOTENTYP name;        /* wenn der Graph numeriert ist */
          KNOTENTYP embed_nr;    /* Nummer der Kante im embed_code */
          KNOTENTYP ursprung2;   /* -> fuer alternative Numerierung */
          KNOTENTYP name2;       /* -> fuer alternative Numerierung */
          KNOTENTYP embed_nr2;   /* -> fuer alternative Numerierung */
          KNOTENTYP connfl;      /* fuer Zusammenhangszahl und Dual: 
                           Markierung der rechten Flaeche (0 = unbestimmt) */
          KNOTENTYP all;         /* Farbe der Kante (beim Isomorphietest) */
          EULERTYP nr;           /* fuer die Numerierung der Kanten eines
                                    Petriepfades (bei Kartenkonstruktion) */
          FLAECHENTYP fl_rechts; /* Groesse der Flaeche rechts von der Kante */
          BOOL pfadanfang;       /* True <=> die Kante soll als Anfang
                                    eines Petriepfades benutzt werden. */    
          BOOL sp_pfadanfang;    /* True <=> die Kante soll als Anfang
                  eines spiegelverkehrten Petriepfades benutzt werden. */   
        } KANTE;

typedef KANTE *PLANMAP[N_MAX_P][3];  /* fuer Karte, die ausgegeben werden soll
                                   oder fuer Patch, der bewertet werden soll */
typedef KANTE KANTENARRAY[N_MAX_P*4];   /* bottom-up und top-down */
  /* Fuer Patches und Karten, die zusammengenaeht werden. Ein Patch
     besitzt maximal N_MAX_P*2 (gerichtete) Kanten (eine Karte maximal N_MAX*3
     gerichtete Kanten). Maximal je zwei Kanten koennen miteinander 
     identifiziert werden (zwei identifizierte Kanten werden zu einer inneren 
     Kante). Deshalb ist das Array ausreichend gross. Wenn keine bottom-up-
     Konstruktion mehr noetig waere, wuerden sogar N_MAX_P*2 Kanten ausreichen,
     da keine Kanten miteinander identifiziert wuerden. */
typedef struct mem {       /* Zeiger auf grossen Speicherblock */
  struct mem *next;        /* naechster Speicherblock */
  size_t used;             /* Anzahl der benutzten Bytes - immer durch 
                              sizeof(void *) teilbar */
  void *memory;            /* Zeiger auf Block */
} MEMORY;

   
/**********************/    
/* globale Variablen: */
/**********************/

/* Alle globalen Variablen, die mit "(-)" gekennzeichnet sind, werden einmal
   belegt und bleiben dann waehrend des ganzen Programmdurchlaufs konstant. */

/* ------------------ */
/* Erzeugungsgrenzen: */
/* ------------------ */

KNOTENTYP n_max;    /* maximale Knotenzahl eines brauchbaren Patches bei 
                       gegebener maximaler Knotenzahl eines Graphen (-) */
KNOTENTYP f_max[G_MAX+1];  /* Flaechenzahl = maximale Flaechenzahl eines 
   Graphen bei gegebener maximaler Knotenzahl eines Graphen (-).
   Gleichzeitig maximale Flaechenzahl in einem Patch.
   Fuer jedes Geschlecht wird eine eigene Zahl bestimmt. */
KNOTENTYP f_anf[G_MAX+1];  /* Flaechenzahl bei gegebener minimaler 
                              Knotenzahl Graphen (-) */


/* ---------- */
/* Statistik: */
/* ---------- */

unsigned long *graphenzahl = nil, *non_iso_graphenzahl = nil; 
     /* Zeiger auf Arrays mit Graphenzahlen:  Fuer Graphen vom Geschlecht
        g mit n Knoten und dem Nahttyp x (1-3) wird das Arrayelement 
        ARRAYPOS_LN(g,n,x) bereitgestellt. */
unsigned long patches = 0L;    /* Anzahl der gespeicherten Patches */
unsigned long nahttyp[3] = {0,0,0};  /* gespeicherte Patches 
                  nach Nahttypen (siehe "ELEM.art") der Vorgaenger sortiert */
unsigned long *patch_anz = nil;   /* fuer jede Flaechenzahl und jedes 
                              Geschlecht:  Anzahl der gespeicherten Patches */
unsigned long gute_basen=0L;    /* Anzahl der mittelbar brauchbaren Patches */
unsigned long *connzahl = nil;  /* Im Arrayelement ARRAYPOS_LN(g,n,x) steht,
                                   wie viele x-fach-zsh. Graphen mit Geschlecht
                                   g und n Knoten generiert wurden. */ 

/* ----------------- */
/* Benutzeroptionen: */
/* ----------------- */

/* Die folgenden Werte sind alle "(-)" und geben an, ob die Option desselben
   Namens benutzt wurde. */
BOOL v_used = False;
BOOL output_used = False;
BOOL outputmem_used = False;
BOOL types_used = False;
BOOL facecon_used = False;
BOOL logfile_used = False;
BOOL g_used = False;
BOOL gs_used = False;
BOOL mapstat_used = False;
BOOL mapcon_used = False;
BOOL vs_used = False;
BOOL f_used = False;
BOOL fileindex_used = False;
BOOL facestat_used = False;
BOOL pv_used = False;
BOOL delaney_used = False;
BOOL logfilename_used = False;
BOOL topdown_used = False;
BOOL patchstat_used = False;
BOOL patchcheck_used = False;
BOOL pid_used = False;
BOOL priority_used = False;
BOOL patchcon_used = False;
BOOL alt_used = False;
BOOL dual_used = False;
BOOL db_used = False;
BOOL td_limits_used = False;
BOOL memory_used = False;
BOOL mod_used = False;
BOOL class_used = False;
BOOL save_used = False;
BOOL no_recover_used = False;
BOOL digon_path_used = False;
BOOL level_used = False;
BOOL shortfilename_used = False;
BOOL lazydump_used = False;
BOOL mod2_used = False;
BOOL class2_used = False;
BOOL old_mod2_used = False;
BOOL old_class2_used = False;
BOOL level2_used = False;
BOOL mod3_used = False;
BOOL class3_used = False;
BOOL old_mod3_used = False;
BOOL old_class3_used = False;
BOOL level3_used = False;
BOOL mod4_used = False;
BOOL class4_used = False;
BOOL old_mod4_used = False;
BOOL old_class4_used = False;
BOOL level4_used = False;
BOOL mod5_used = False;
BOOL class5_used = False;
BOOL old_mod5_used = False;
BOOL old_class5_used = False;
BOOL level5_used = False;
BOOL mod6_used = False;
BOOL class6_used = False;
BOOL old_mod6_used = False;
BOOL old_class6_used = False;
BOOL level6_used = False;
BOOL comp4_used = False;
BOOL mdeza1_used = False;
BOOL bigendian_used = False;

KNOTENTYP genus_anf;  /* gewuenschtes Minimalgeschlecht
          (wird nach Pruefung der Flaechenkombination nicht mehr veraendert) */
KNOTENTYP genus_end;  /* gewuenschtes Maximalgeschlecht (K.s.o.) */
KNOTENTYP genus_anf_usr, genus_end_usr;   /* siehe genus_anf, genus_end, aber
   diese Werte werden durch die Funktion "pruefe_flaechenkombination" NICHT
   veraendert. Diese Variablen enthalten also IMMER die Werte, die der Benutzer
   (usr = user) anfangs eingegeben hatte. Diese unveraenderten Werte sind
   wichtig, damit die Makros "ARRAYPOS_x" immer dieselben Werte liefern! (-) */
KNOTENTYP n_anf, n_end;   /* erste und letzte gewuenschte Knotenzahl
                             (nach Flaechenkomb. nicht mehr veraendert) */
KNOTENTYP n_anf_usr,n_end_usr;  /* siehe n_anf, n_end (Kommentar siehe
                                   genus_anf_usr, genus_end_usr) (-) */ 
FLAECHENTYP face[MAXFTYPEN];       /* gewuenschte Flaechentypen (-) */
KNOTENTYP facenum_min_usr[MAXFTYPEN];  /* zugehoerige Minimalzahlen (-) */
KNOTENTYP facenum_max_usr[MAXFTYPEN];  /* zugehoerige Maximalzahlen (-) */
KNOTENTYP facenum_min[MAXFTYPEN];  /* vom Programm optimierte Zahlen (-) */
KNOTENTYP facenum_max[MAXFTYPEN];  /* (-) */
FLAECHENTYP anz_face=0;            /* Anzahl der Flaechentypen (-) */
BOOL facestat = False;       /* True => Flaechenstatistik wird erstellt (-) */
BOOL facerestrict = False;   /* True => Minimal- und Maximalzahlen fuer
                                Flaechen eines Typs werden gesetzt (-) */
BOOL facenumbers = False;    /* Flaechenzahlen werden errechnet
                                (fuer "facerestrict" und "facestat") (-) */
BOOL output=True;            /* False => keine Graphen ausgeben (-) */
BOOL do_bauchbinde = True;   /* Sollen Typ-1-Graphen erzeugt werden? (-) */
BOOL do_sandwich = True;     /* Sollen Typ-2-Graphen erzeugt werden? (-) */
BOOL do_brille = True;       /* Sollen Typ 3-Graphen erzeugt werden? (-) */
BOOL alternative = False;    /* False = Aufspaltung nach kritischen Flaechen,
                                True = keine Aufspaltung (-) */
BOOL dual = False;           /* True => Triangulierungen werden ausgegeben */
KNOTENTYP bauchbindenkennung=3, sandwichkennung=2, brillenkennung=1;
 /* Prioritaeten der drei Pfadtypen (je kleiner der Wert, desto groesser die
    Prioritaet). Die Defaults sind so gewaehlt, dass moeglichst oft Teile der
    Generierung entfallen koennen. (-) */
unsigned char pv = PV_DEFAULT;   /* (-) je hoeher dieser Wert, desto mehr 
                                 Patchvermeidungskriterien werden angewendet */
BOOL conn1 = True;              /* True => 1-zusammenhaengende Graphen 
                                    werden ausgegeben (-) */
BOOL conn2 = True;              /* (-) */
BOOL conn3 = True;              /* (-) */
BOOL do_conn = False;     /* True => Zusammenhangsstatistik (-) */
BOOL patchconn = False;   /* True => Zusammenhangszahl der Patches wird
                             beruecksichtigt, d.h. Patches, die zu Graphen mit
                             einer zu kleinen Zusammenhangszahl fuehren,
                             werden aussortiert. Dazu muss der Patch allerdings
                             konstruiert werden. (-) */
BOOL graphstat = False;   /* True => Statistik ueber die Anzahl der Graphen
                             sortiert nach Pfadtypen wird ausgegeben (-)
                             (war bei CPF immer der Fall, jetzt nicht mehr) */
BOOL facecon1 = True;     /* False => Patches und Karten, bei denen eine
                             Flaeche mit sich selbst verklebt ist, 
                             aussortieren (-) */
BOOL facecon2 = True;     /* False => Patches und Karten, bei denen zwei
                             Flaechen an zwei Kanten miteinander verklebt sind,
                             aussortieren (-) */
                          /* facecon2==False => facecon1==False */
BOOL doppelkanten = False;  /* True => Doppelkanten, die keine 2-Ecke
                               einschliessen, sind erlaubt (-) */
BOOL delaney = False;       /* True => es koennen drei Mengen von Flaechentypen
                               vorgegeben werden: An jeden Knoten muss je eine
                               Flaeche jedes Typs angrenzen. (-) */
unsigned char dela_set[F_MAX+1];   /* fuer jeden Flaechentyp die Mengen-
    zugehoerigkeit (Bit i in Element j gesetzt => Flaeche der Groesse j 
    gehoert zu Menge i+1) (-) */
BOOL patchcheck = False;    /* True => auch in der Rekursion werden Patches
                               sofort konstruiert und eventuell verworfen 
     (nuetzlich z.B. bei "delaney", wo sehr viele Patches entfallen koennen)
                                                                         (-) */
BOOL pco = False;           /* True => patchcheck && !overflow */
BOOL logfile_out = True;    /* "False" => kein Logfile wird erzeugt (-) */
BOOL stderr_out = True;     /* "False" => keine Informationen auf stderr (-) */
BOOL digon_path = False;    /* "True" => nur BK-Pfade, die an einem Zweieck
                               beginnen, werden erzeugt (-) */
BOOL comp4 = False;   /* True => im Dump-File werden von 8Byte-Zahlen nur die
      untersten 4 ernst genommen. Keine offizielle Option, nur fuer
      Kompatibilitaetszwecke mit alten Versionen (-) */
  /* In alten Versionen wurden auch dann 8 Bytes eines Wertes abgespeichert,
     wenn der Wert nur 4 Bytes Groesse hatte. Der Shift-Operator permutierte
     dann zyklisch mit 4 Byte Periode, so dass die 4-Byte-Zahl zweimal
     hintereinander abgespeichert wurde, anstatt dass 4 fuehrende Nullen
     ausgegeben wurden. Damit wurde das Dump-File fuer Alpha-Rechner
     unbrauchbar. Wenn "comp4" gesetzt ist, so werden von 8-Byte-Zahlen
     grundsaetzlich die obersten 4 Bytes beim Lesen ignoriert.  Die Option
     sollte also grundsaetzlich eingeschaltet werden, wenn alte Dump-Files
     eingelesen werden.
     Ohne die Option "comp4" wird ueberprueft, ob die oberen 4 Bytes einer
     8 Byte-Zahl leer sind, es sei denn, das Programm wird auf einer 8-Byte-
     Architektur ausgefuehrt. Falls die oberen 4 Bytes nicht leer sind, so
     wird abgebrochen, da sonst moeglicherweise eine wichtige Information
     verschluckt wird. 
     Es gibt aber noch einen Haken:  Wenn his_check auf einen Overflow
     abgefragt wird, dann geschieht das u.a. unter Bezugnahme auf den
     ULONG_MAX-Wert.  Das Ergebnis kann also je nach Architektur anders
     ausgehen. Da der his_check-Wert nicht im Dump-File gespeichert wird,
     dann man hier den Uebergang zwischen 2 Architekturen nicht ueberpruefen.
     Normalerweise wird der ULONG_MAX-Wert bei his_check aber nicht
     ueberschritten. */
BOOL bigendian = False;    /* True = Codes werden als BigEndian-Codes geschrieben */


/* ------ */
/* Files: */
/* ------ */

char logfilename[FILENAME_MAX];   /* Am Anfang auch fuer die anderen
                                        Filenamen (-) */
char **outputbuffer;   /* Zwischenspeicher fuer die zugehoerige Knotenzahl
                          und das zugehoerige Geschlecht (-) */
size_t *outputbufferlen;  /* Laenge des fuer die zugehoerige
                             Knotenzahl vorgesehenen Zwischenspeichers (-) */
size_t *outputbufferused;  
       /* Anzahl der benutzten Eintraege im
          fuer die zugehoerige Knotenzahl vorgesehenen Zwischenspeicher */
char *outputfile;    /* fuer jede Knotenzahl und jedes Geschlecht 
                        ein Outputfile (-)
      0 bedeutet "keine Ausgabe", 1 bedeutet "Ausgabe in File",
      2 bedeutet "Ausgabe nach stdout" */
char **outputfilename;   /* zugehoerige Namen (-) */
size_t basis = 200L;     /* (-) diese beiden Parameter regeln die */ 
size_t zusatz = 300L;    /* (-) Groesse des Outputbuffers:  "basis"
   gibt die Anzahl der Karten an, die fuer die kleinste Knotenzahl im
   Outputbuffer gespeichert werden koennen, "zusatz" die Anzahl der Karten,
   die zusaetzlich fuer die groesste Knotenzahl gespeichert werden koennen.
   Wenn beide Werte 0 sind, so wird jede Karte sofort gespeichert
   (nuetzlich fuer "Cage"). */


/* ------------------- */
/* Speicherverwaltung: */
/* ------------------- */

MEMORY *firstmem=nil;  /* Zeiger auf ersten dynamischen Speicherbereich (-) */
MEMORY *currmem=nil;         /* Zeiger auf aktuellen dynamischen
                                Speicherbereich (der noch nicht voll ist) */ 
MEMORY *savemem=nil;   /* Zeiger auf den letzten dynamischen Speicherbereich,
                          in dem sich noch Patches befinden, die bei der
   Konstruktion gebraucht werden. Wenn naemlich die Speicherschwelle erreicht 
   wird, so ist ein Grossteil der Patches unbrauchbar, weil es noch weitere
   Patches mit den gleichen Eigenschaften gibt, die nicht mehr gespeichert
   werden. Die uebrigen Patches mit den Eigenschaften koennen also geloescht
   werden. Wichtig hierbei:  Zwischen dem Erreichen der Speicherschwelle und
   der Freigabe der ueberfluessigen Patches wird nichts dynamisch gespeichert,
   was dann auch geloescht wuerde. */
#ifdef __FreeBsd__
struct mallinfo space_info;
#endif
size_t mem_max = 0L;     /* maximaler Speicherverbrauch (-) */
size_t mem_curr = 0L;    /* aktueller Speicherverbrauch */
BOOL memory_overflow = False;   /* True => Speicher verbraucht */


/* ---------- */
/* Zeitnahme: */
/* ---------- */
#ifndef NOTIMES
clock_t savetime=0;    /* verbrauchte Zeit seit Programmbeginn */
clock_t prevtime=0;    /* verbrauchte Zeit vorm Recovern       */ 
struct tms TMS;
#endif //NOTIMES

/* --------------------------------- */
/* History (Rekursion oder Topdown): */
/* --------------------------------- */

/* Im folgenden sind einige Zeiger auf Arrays, die dynamisch alloziert werden,
   aufgefuehrt. Die theoretischen Obergrenzen fuer die einzelnen Dimensionen
   sind in Klammern angegeben */
BOOL rekursion = False;     /* True => die Patchgenerierung ist "ueber den
                               Berg" und wird nun rekursiv durchgefuehrt */
ELEM *history;  /*[HISTORYLEN+1];*/  /* fuer die Geschichte eines in der
      Rekursion erzeugten Patches. 
      Wenn ein prev-Zeiger auf einen Stammpatch zeigt, dann zunaechst immer 
      auf das erste Element der Liste mit gleichen Randcodes. */
ELEM *hiscopy;  /*[HISTORYLEN];*/    /* Kopie von "history", in der die
      Zeiger auf Vorgaenger veraendert werden duerfen. */
KNOTENTYP *his_faces;  /* Zeiger auf Speicherbereich fuer die Flaechenzahlen */
KNOTENTYP *his_rl2;  /*[HISTORYLEN];*/
   /* fuer die Elemente, die aus Anwendung von
      Fall 1 hervorgingen: "rl2"-Eintrag */
KNOTENTYP *his_rlg2;  /*[HISTORYLEN];*/
   /* fuer die Elemente, die aus Anwendung von
      Fall 1 hervorgingen: "rlg2"-Eintrag */
unsigned char **his_acc;  /*[HISTORYLEN][ACCEPTLEN];*/
  /* fuer die Elemente, die aus
     Anwendung von Fall 1 hervorgingen: "akzeptiert"-Eintraege */
  /* Dimensionen koennen nicht umgedreht werden, weil einige Funktionen einen
     Zeiger auf alle Eintraege zu einem Patch benoetigen */
unsigned long **his_check;  /*[CHECKLISTLEN][HISTORYLEN];*/
   /* laufende Nummern von akzeptierten History-Verzweigungen */ 
unsigned char **his_check_iso_rand[CHECKLISTLEN];  /*[G_MAX/8+1][HISTORYLEN];*/
    /* fuer jeden Rand (maximal G_MAX+1) ein Bit, das angibt, ob der
       Rand isomorph zu einem ranghoeheren Rand ist (=0) oder nicht  (=1) */
    /* wird fuer jeden akzeptierten Patch in jeder Rekursionsebene benoetigt */
    /* wird bei "topdown" nicht benoetigt */
unsigned short *his_check_anz;  /*[HISTORYLEN];*/   /* Anzahl der Eintraege */
unsigned short *his_check_pos;  /*[HISTORYLEN];*/ 
                                /* Nummer des aktuellen Eintrags */
unsigned long *his_check_count; /*[HISTORYLEN];*//* aktuelle laufende Nummer */
BOOL *overflow;  /*[HISTORYLEN];*/  /* True => im aktuellen oder niedrigeren
                                       Level ist overflow aufgetreten */
KNOTENTYP **code1_kon,**code2_kon;  /* [HISTORYLEN][N_MAX_P+3] */
  /* fuer Bordercodes innerhalb der Funktionen "konstruiere_patch" und 
     "konstruiere_patch_in_rekursion" */
KANTE ***gk1_kon,***gk2_kon;   /* [HISTORYLEN][G_MAX+1] */
  /* fuer Grundkantenarrays innerhalb der Funktionen "konstruiere_patch" und
     "konstruiere_patch_in_rekursion" */
KNOTENTYP **randcode2_vpr;   /* [HISTORYLEN][2*N_MAX_P] */
  /* fuer Randcode innerhalb der Funktionen "verknuepfe_patches_in_rekursion"
     und "verknuepfe_patch_fall1_in_rekursion" */
KNOTENTYP **ergrandcode_vpr;   /* [HISTORYLEN][2*N_MAX_P] */
  /* fuer Randcode innerhalb der Funktionen "verknuepfe_patches_in_rekursion"
     und "verknuepfe_patch_fall1_in_rekursion" */
KNOTENTYP **ergrandcode2_vpr;   /* [HISTORYLEN][2*N_MAX_P] */
  /* fuer Randcode innerhalb der Funktion
     "verknuepfe_patch_fall1_in_rekursion" */
KNOTENTYP **ergcode_vpr;   /* [HISTORYLEN][N_MAX_P+3] */
  /* fuer Bordercode innerhalb der Funktionen "verknuepfe_patches_in_rekursion"
     und "verknuepfe_patch_fall1_in_rekursion" */
KNOTENTYP **bordercode2_sppr;   /* [HISTORYLEN][N_MAX_P+3] */
  /* fuer Bordercode innerhalb der Funktion
     "suche_passende_patches_in_rekursion" */


/* --------- */
/* Top-Down: */
/* --------- */

BOOL topdown = False;     /* True => Option topdown wird benutzt (-) */
EULERTYP *fl_td[2];  /*[HISTORYLEN];*/
          /* Flaechenzahlen der beiden Vorgaenger eines Patches in der
             History (falls nur 1 Vorgaenger: "fl_td[1][.]" unbenutzt) */
EULERTYP *g_td[2];  /*[HISTORYLEN];*/   /* entsprechend fuer das Geschlecht */
KNOTENTYP *krit_td[2];  /*[HISTORYLEN];*/ 
  /* entsprechend fuer die kritischen Punkte */
KNOTENTYP *kriti_td;  /*[HISTORYLEN];*/ /* Entsprechend fuer die kritischen 
  Punkte: Es werden allerdings nur die Indizes auf das Array "kp" gespeichert,
  und dies auch nur fuer den ersten von zwei Vorgaengern,
  d.h.  kp[fl_td[0][index]][anz_bk_td[0][index]][kriti_td[index]]
  enthaelt die kritischen Punkte */
KNOTENTYP *fl_max_td[2];  /*[HISTORYLEN];*/
KNOTENTYP *fl_min_td[2];  /*[HISTORYLEN];*/
  /* theoretische Grenzen bei zugrundeliegendem Geschlecht und Bordercode */
KNOTENTYP **bc_td[2]; /*[HISTORYLEN][N_MAX_P+3];*/
  /* entsprechend fuer die Bordercodes */
  /* Im Gegensatz zu und "per_td" MUSS die letzte Dimension an letzter
     Stelle stehen, damit ein Bordercode im Zusammenhang kopiert werden kann.
     Aber das ist ueberhaupt nicht schlimm, da die letzte Dimension genauso
     gross ist wie die vorletzte. */
KNOTENTYP *anz_bk_td[2];    /* [HISTORYLEN] */
  /* BEREINIGTE Anzahl der Bruchkanten in den zugehoerigen bc_td-Bordercodes 
     (wird oft abgefragt, deshalb lieber einmal berechnen). Wird nur dann 
     gebraucht, wenn 2 Vorgaenger vorliegen. Deshalb muessen die Werte 
     insbesondere nie im obersten Level berechnet werden (in der Funktion 
     "top_down_generierung"). */
KNOTENTYP **per_td[2];   /*[G_MAX+1][HISTORYLEN];*/
   /* Laenge der kleinsten Periode im
      zugehoerigen Rand (gemessen in Kanten) */
KNOTENTYP *anz3_td[2];  /*[HISTORYLEN];*/ 
    /* Anzahl der 3-valenten Randknoten im Patch */
EULERTYP *n_td[2];  /*[HISTORYLEN];*/
    /* innere Knoten der beiden Vorgaenger eines Patches in der History */
KANTE ***gk_td;  /*[HISTORYLEN][G_MAX+1];*/  
   /* Array mit Grundkanten fuer jeden Historyeintrag */
   /* Im Gegensatz zu "per_td" MUSS die letzte Dimension an letzter Stelle
      stehen, weil einige Funktionen einen Zeiger auf alle Grundkanten eines
      Patches benoetigen. */
KNOTENTYP *ziellenrandcodepos_td; /*[HISTORYLEN];*/
          /* vereinfachte Verarbeitung */
KNOTENTYP *ziellenposindex_td;    /*[HISTORYLEN];*/     /* von "ziellen" */
/* nahtlen, ziellen, aufteilung und zielrand werden direkt in den History-
   Elementen gespeichert. */
BOOL *vor1;  /*[HISTORYLEN];*/  /* True => der Patch ist der erste von ZWEI
                                   Vorgaengern eines anderen Patches */
BOOL *vor2;  /*[HISTORYLEN];*/  /* True => der Patch ist der zweite von zwei
                                   Vorgaengern eines anderen Patches */
char *vor;   /*[HISTORYLEN];*/  /* 0 = der Patch ist der einzige oder der 
                               erste von 2 Vorgaengern eines anderen Patches, 
                           1 = der Patch ist der zweite von zwei Vorgaengern
                               eines anderen Patches */
POSTYP *vater_nr;   /*[HISTORYLEN];*/   /* Nummer des Vorgaengers in der
                                           History */ 
KNOTENTYP cmax_g_usr[G_MAX+1];   /* enthaelt fuer jedes Geschlecht die 
     Maximalzahl kritischer Punkte, fuer die die Patchkonstruktion bottom-up
     geschehen soll. Die Folge muss monoton fallend sein. (-) */
KNOTENTYP fmax_g_usr[G_MAX+1];   /* enthaelt fuer jedes Geschlecht die 
     Maximalzahl Flaechen, fuer die die Patchkonstruktion bottom-up geschehen 
     soll. Die Folge von Flaechen muss monoton fallend sein, sofern die 
     zugehoerigen cmax-Werte gleich sind, weil ein Patch mit Geschlecht "g+1"
     und "fl" Flaechen u.a. aus einem Patch mit Geschlecht "g" und "fl"
     Flaechen erzeugt werden kann, wobei die kritische Summe gleich ist. (-) */
KNOTENTYP bmax_g_usr[G_MAX+1];   /* enthaelt die Maximalzahl Raender, fuer die
     ein Patch mit Geschlecht "g" und "fmax_g[g]" Flaechen noch bottom-up
     erzeugt wird. Die Folge von Randzahlen muss STRENG monoton fallend sein, 
     wenn die zugehoerigen fmax-Werte und cmax-Werte gleich sind, weil ein
     Patch mit Geschlecht "g+1" und "b" Raendern unter anderem aus einem
     Patch mit Geschlecht "g" und "b+1" Raendern erzeugt werden kann. Es 
     muessen also alle Patches mit Geschlecht "g" und "b+1" Raendern 
     vorliegen.  (-) */  
KNOTENTYP fmax_g[G_MAX+1];   /* wie fmax_g_usr, wird aber angepasst, wenn der
          Speicher voll ist */
KNOTENTYP cmax_g[G_MAX+1];   /* wie cmax_g_usr */
KNOTENTYP bmax_g[G_MAX+1];   /* wie bmax_g_usr */
BOOL td_limits = False;      /* True => User legt bottom-up-Grenzen fest (-) */
BOOL td_limits_auto = False;   /* True => Programm legt bottom-up-Grenzen
                                  fest (-) */
KNOTENTYP *pc_flaechenzahl;  /* [MAXFTYPEN]; */   /* fuer die Addition der
    bei der top-down-Konstruktion auftretenden Flaechenzahlen (wird bei
    "patchcheck" benutzt) */
KNOTENTYP *pc_flaechenzahl_sk;  /* [MAXFTYPEN]; */ 
unsigned long *anz_p;    /* [HISTORYLEN]; */   /* enthaelt die Laenge der
                   in einem History-Eintrag gespeicherten Stammpatchliste */
BOOL **bk_moeglich;   /* [F_MAXANZ+1][bk_max+1] (-) */ 
  /* bk_moeglich[i][j] ist True, wenn aufgrund der erlaubten Flaechen
     theoretisch ein Patch mit "i" Flaechen und "j" Bruchkanten existieren
     kann, wobei der Patch einen Rand und Genus 0 hat (d.h. die Anzahl der
     Bruchkanten ist "bereinigt"). 
     bk_moeglich[0][j] ist False, wenn aufgrund der erlaubten Flaechen
     keine Flaechenzahl "i" existiert, so dass bk_moeglich[i][j]==True ist.
     Patches mit "j" Bruchkanten existieren also grundsatzlich nicht.*/
BOOL **kp_moeglich;   /* [F_MAXANZ+1][(krit_max/8+1)*(bk_max+1)] (-) */
  /* kp_moeglich[i][k+(j/8)*(bk_max+1)]&(1<<(j%8)) ist ungleich null, wenn 
     aufgrund der erlaubten Flaechen theoretisch ein Patch oder eine Karte mit
     "i" Flaechen, "k" (bereinigten) Bruchkanten und "j" kritischen Punkten 
     existieren kann. 
     (j/8) bzw. (j>>3) muss zuerst ausgerechnet (also abgerundet) werden!
     kp_moeglich[0][0+(j/8)*(bk_max+1)]&(1<<(j%8)) ist False, wenn aufgrund der
     erlaubten Flaechen keine Flaechenzahl "i" und kein "k" existiert, so dass 
     kp_moeglich[i][k+(j/8)*(bk_max+1)]&(1<<(j%8)) True ist. Patches mit "j" 
     kritischen Punkten existieren also grundsatzlich nicht 
     (z.B. Patches mit einem kritischen Punkt,
     wenn Achtecke, aber keine Siebenecke erlaubt sind). */
     /* ???? kp_moeglich[0] wird zur Zeit nicht genutzt */
KNOTENTYP ***kp;        /* [F_MAXANZ+1][bk_max+1] (-) */
  /* Dieses Array enthaelt fuer jede Flaechenzahl und jede (bereinigte)
     Bruchkantenzahl einen Zeiger auf ein Array mit den kritischen Punktzahlen,
     fuer die Patches existieren koennen, in gebuendelter Form (im Gegensatz
     zu "kp_moeglich") (aufsteigend sortiert) */
KNOTENTYP **kp_anz;     /* [F_MAXANZ+1][bk_max+1] (-) */
  /* Fuer jede Flaechenzahl und jede (bereinigte) Bruchkantenzahl Anzahl der 
     Elemente in "kp" */
KNOTENTYP **kpk;   /* [(G_MAX+1)*(F_MAXANZ+1)][krit_max-krit_min+1] (-) */  
  /* Dieses Array enthaelt fuer jedes Geschlecht und jede Knotenzahl einen 
     Zeiger auf ein Array mit den kritischen Punktzahlen, fuer die komplette 
     kubische Karten existieren koennen, in gebuendelter Form 
     (aufsteigend sortiert). krit_max-krit_min+1 ist die maximale Anzahl 
     verschiedener kritischer Punktzahlen, deshalb reicht dies auch als 
     Arraygroesse aus. */
KNOTENTYP *kpk_anz;   /* [(G_MAX+1)*(F_MAXANZ+1)] (-) */
  /* fuer jede Flaechenzahl Anzahl der Elemente in "kpk" */


/* --------------------------- */
/* Aufteilung eines Prozesses: */
/* --------------------------- */

unsigned short mod = 1,class = 0; /* fuer die Aufteilung eines Prozesses (-) */
  /* "mod" muss gesetzt werden, damit nicht durch 0 geteilt wird, falls
     "mod_used==False" bleibt. "class" muss gesetzt werden, damit "count"
     mit "class" verglichen werden kann, auch wenn "mod_used==False" gilt */
unsigned short level = 0;        /* fuer bottom-up (-) */
unsigned short level2 = 1;       /* bei top-down fuer 'mod2' (-) */
unsigned short level3 = 3;       /* bei top-down fuer 'mod3' (-) */
unsigned short level4 = 5;       /* bei top-down fuer 'mod4' (-) */
unsigned short level5 = 8;       /* bei top-down fuer 'mod5' (-) */
unsigned short level6 = 11;      /* bei top-down fuer 'mod6' (-) */
unsigned short count = 0;        /* zaehlt das Erreichen des Levels mit */
unsigned short recovercount;     /* Wert, der im Recoverfile stand (-) */
unsigned short count2 = 0;       /* zaehlt das Erreichen des Levels mit */
unsigned short recovercount2;    /* Wert, der im Recoverfile stand (-) */
unsigned short count3 = 0;       /* zaehlt das Erreichen des Levels mit */
unsigned short recovercount3;    /* Wert, der im Recoverfile stand (-) */
unsigned short count4 = 0;       /* zaehlt das Erreichen des Levels mit */
unsigned short recovercount4;    /* Wert, der im Recoverfile stand (-) */
unsigned short count5 = 0;       /* zaehlt das Erreichen des Levels mit */
unsigned short recovercount5;    /* Wert, der im Recoverfile stand (-) */
unsigned short count6 = 0;       /* zaehlt das Erreichen des Levels mit */
unsigned short recovercount6;    /* Wert, der im Recoverfile stand (-) */
unsigned short mod2 = 1,class2 = 0; /* fuer die Aufteilung eines Top-down-
                                       Prozesses in unteren Levels (-) */
unsigned short mod3 = 1,class3 = 0; /* fuer die Aufteilung eines Top-down-
                                       Prozesses in unteren Levels (-) */
unsigned short mod4 = 1,class4 = 0; /* fuer die Aufteilung eines Top-down-
                                       Prozesses in unteren Levels (-) */
unsigned short mod5 = 1,class5 = 0; /* fuer die Aufteilung eines Top-down-
                                       Prozesses in unteren Levels (-) */
unsigned short mod6 = 1,class6 = 0; /* fuer die Aufteilung eines Top-down-
                                       Prozesses in unteren Levels (-) */
/* "mod2" muss gesetzt werden, damit nicht durch 0 geteilt wird, falls
   "mod2_used==False" bleibt. "class2" muss gesetzt werden, damit "count2"
   mit "class2" verglichen werden kann, auch wenn "mod2_used==False" gilt */
/* "class2", "class3" und "class4" muessen auf 0 gesetzt werden, damit in 
   topdown-Generierung der Vergleich von "level2", "level3" und "level4" mit 
   "hislen" ohne Folgen bleibt */
unsigned short old_mod2,old_class2 = 0; /* fuer weitere Aufteilung (-) */
BOOL alias = False;              /* True => es wird weiter aufgeteilt (-) */
unsigned short old_mod3,old_class3 = 0;  /* fuer noch weitere Aufteilung (-) */
BOOL alias2 = False;             /* True => es wird weiter aufgeteilt (-) */
unsigned short old_mod4,old_class4 = 0;  /* fuer noch weitere Aufteilung (-) */
BOOL alias3 = False;             /* True => es wird weiter aufgeteilt (-) */
unsigned short old_mod5,old_class5 = 0;  /* fuer noch weitere Aufteilung (-) */
BOOL alias4 = False;             /* True => es wird weiter aufgeteilt (-) */
unsigned short old_mod6,old_class6 = 0;  /* fuer noch weitere Aufteilung (-) */
BOOL alias5 = False;             /* True => es wird weiter aufgeteilt (-) */
/* die "old_class"-Werte muessen gesetzt werden, weil bei Bauchbinden
   eventuell auf die Werte zugegriffen wird. */ 


/* -------------- */
/* Recover-Modus: */
/* -------------- */

int S_intervall = SICHERUNGSINTERVALL;     
                    /* Anzahl der Sekunden, die zwischen zwei Sicherungen
                       maximal verstreichen (sofern nicht zuvor schon so
                       viele Karten erzeugt wurden, dass eine Sicherung
                       notwendig ist) */
unsigned long *zweig;   /*[HISTORYLEN];*/ 
   /* Gibt fuer jede Rekursionsebene die Nummer des Zweigs im 
      konstruktionsbaum an (beginnend mit 1). "zweig[i]" gibt an, wie oft
      in der Ebene "i" durch "suche_patch" eine gueltige Wertebelegung 
      gefunden wurde. */
unsigned long nebenzweig[3]; 
   /* "nebenzweig[i]" gibt an, wie oft fuer Patch "i" die Funktion 
      "schalte_history_weiter_td" aufgerufen wurde.
      Nur wichtig, wenn innerhalb der Konstruktion gespeichert wird. */
   /* Die beiden "zweig"-Zaehler lassen sich nicht sinnvoll miteinander 
      kombinieren. Denn um den Wert von "nebenzweig" zu kennen und somit 
      ueberspringen zu koennen, muesste man ja alle moeglichen Patches 
      konstruieren oder zumindest die Moeglichkeiten durchlaufen. */
POSTYP recover_hislen;   /* gibt an, bis zu welcher Tiefe in der History
                           rekonstruiert werden soll */
unsigned long *recoverzweig;    /*[HISTORYLEN];*/            /* (-) */
   /* gibt fuer jede Rekursionsebene die 
      Nummer des beim Recovern geforderten Zweigs an */
unsigned long recovernebenzweig[3];           /* (-) */
   /* gibt fuer jede Rekursionsebene die 
      Nummer des beim Recovern geforderten Zweigs an (-) */
KNOTENTYP fmax_g_rec[G_MAX+1];  /* enthaelt den im Recoverfile gespeicherten
    "fmax_g"-Wert. Dieser muss beim Recovern auch wieder erreicht werden,
    sonst ist das Recovern wertlos. (nur topdown) (-) */
KNOTENTYP cmax_g_rec[G_MAX+1];   /* entsprechend fuer "cmax_g" (-) */
KNOTENTYP bmax_g_rec[G_MAX+1];   /* entsprechend fuer "bmax_g" (-) */
BOOL recover = True;  /* False => es wird kein dump-File eingelesen oder
                         Recover-Modus ist abgeschlossen */
BOOL save = True;     /* False => es werden keine dump-Files erzeugt */
char recoverreadfilename[FILENAME_MAX];  /* fuer den Namen des 
                                            gesuchten Files */
char recoversavefilename[FILENAME_MAX];  /* fuer den Namen des 
                                            zu oeffnenden Files */
char recoverfilename_sk[FILENAME_MAX];  /* dasselbe + "~" (Backup-File) */
char recoverflagfilename[FILENAME_MAX];   /* fuer den Namen des Flagfiles */
     /* "save_flag" ist unten definiert und steht auf 1, wenn wieder eine 
        Speicherung erfolgen muss */
char recoverreadflagfilename[FILENAME_MAX];   /* fuer den Namen des Flagfiles 
                                                 beim Lesen */
char recoverreadfilename_sk[FILENAME_MAX];  /* dasselbe + "~" (Backup-File) */
unsigned char *recoverdata;   /* zeigt auf Speicherbereich, in den
                                 die Daten geschrieben werden, bevor sie im
                                 Recoverfile abgespeichert werden */
unsigned char pfadtyp_rec;               /* gespeicherter Pfadtyp */
unsigned char submgl_rec,mgl_rec;        /* gespeicherte Patchaufteilung */
KNOTENTYP l1_rec,l2_rec,l3_rec,fln1_rec,fln2_rec,n_rec,g1_rec,g2_rec,g_rec,
          krit1_rec,krit2_rec,krit3_rec;
          /* gespeicherte Patchaufteilungsdetails */
unsigned char p1,p2,p3;    /* zu speichernde Patchaufteilungsdetails */
KNOTENTYP p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15; 
          /* zu speichernde Patchaufteilungsdetails (nur bei topdown) */
BOOL gefunden1,gefunden2,gefunden3;   /* Nur fuer topdown: diese Flags geben 
     an, ob ein Patch
     gefunden wurde. Das ist wichtig bei folgendem Szenario:  Sei Patch 2
     gesucht. Es wurde bereits ein passender Patch 2 gefunden, und nun wird
     weitergeschaltet. Beim Weiterschalten wuerde kein weiterer passender
     Patch mehr gefunden, aber das wird nicht registriert, weil waehrend des
     Weiterschaltens das Dumpfile erzeugt wird. Beim Recovern wird dann
     innerhalb des ERSTEN Aufrufs von "suche_patch" kein Patch gefunden. Es
     gibt aber einen passenden Patch, und um dies zu dokumentieren, wird
     "gefunden2" auf "True" gesetzt. */
     /* Beim Recovern koennen dieselben Flags benutzt werden, da die 
        Information waehrend des Recoverns konserviert wird. */ 
BOOL save_flag2 = False;   /* wird auf "True" gesetzt, wenn der Kartenspeicher
                              voll ist */


/* ---------- */
/* Sonstiges: */
/* ---------- */

KANTE defaultkante = {nil,nil,nil,0,0,0,0,0,0,0,0,0,0,True,True};
                     /* default - Vorbelegung */
KNOTENTYP bk_max=0;  /* maximale Anzahl Bruchkanten in einem theoretisch
     brauchbaren Patch. "Knotentyp" ist ausreichend, denn jede Bruchkante 
     bedingt mindestens einen zusaetzlichen Knoten und "Knotentyp" kann Werte
     bis zu N_MAX_P aufnehmen.
     "bk_max" enthaelt die maximale Anzahl Bruchkanten unter der Annahme,
     dass der Patch Geschlecht 0 hat und einen Rand besitzt. Andernfalls ist
     der Wert sogar noch kleiner (-6 fuer jeden weiteren Rand und -12 fuer 
     jeden Henkel).  (-) */
POSTYP bc_len_max=9; /* maximale Laenge eines theoretisch denkbaren 
                        Bordercodes. Haengt direkt von bk_max und genus_end_usr
                        ab: "MAX(6,bk_max)+3+genus_end_usr" ist die maximale 
      Laenge eines Bordercodes (bk_max Bruchkanteneintraege sowie 
      3+genus_end_usr Praefixeintragungen, wobei bk_max<=n_max_p). Dies gilt 
      auch dann, wenn Bauchbindenraender im Spiel sind: Ein Patch mit einem 
      einzigen Bauchbindenrand benoetigt 5 Eintraege, ein Patch mit 2 
      BB-Raendern 7 Eintraege; ferner gilt, wenn ein Patch noch andere Raender
      hat, dass bk_max pro Rand um 6 zu hoch angesetzt ist, so dass die 2 
      unberuecksichtigten Eintragungen pro BB-Rand locker Platz finden. (-) */
TREENODE *tree[F_MAXANZ+1];         /* fuer Patchbaeume */
STATTREENODE *facestatbaum = nil;   /* fuer Flaechenstatistik */
FLAECHENTYP big_face;            /* Anzahl der Ecken im groessten n-Eck (-) */
FLAECHENTYP small_face;          /* Anzahl der Ecken im kleinsten n-Eck (-) */
BOOL einecke = False, zweiecke = False;   /* True => erlaubt (-) */
KNOTENTYP krit_min = 0;         /* Mindestanzahl der kritischen Punkte (-) */
KNOTENTYP krit_max = 0;         /* Maximalanzahl der kritischen Punkte (-) */
  /* KNOTENTYP ist ausreichend, denn:
     krit = \sum_{i>6}(i-6)p_i   und   fd = 12(1-g)  (im S3Z-Graphen) 
     andererseits  fd = \sum_{i>=3}(6-i)p_i    (nach Definition)
     =>  12(1-g) = fd = \sum_{i>=3}(6-i)p_i = 3p_3 + 2p_4 + p_5 + 
         \sum_{i>6}(6-i)p_i = 3p_3 + 2p_4 + p_5 - \sum{i>6}(i-6)p_i
         = 3p_3 + 2p_4 + p_5 - krit
     =>  krit  = 3p_3 + 2p_4 + p_5 - 12(1-g)
              <= 3*(p_3 + p_4 + p_5) - 12(1-g)
              <= 3*(f_max[g]) - 12(1-g)
               = 3*(n_end/2+2-2*g) - 12(1-g)
               = 3/2*n_end + 6 - 6g - 12 + 12g     ; n_max =  3*n_end
               = 3/2*(n_max/3) - 6 + 6g
               = 1/2*n_max - 6 + 6g
              <= 1/2*KN_MAX - 6 + 6*GEN_MAX        ; GEN_MAX = KN_MAX/12
              <= 1/2*KN_MAX - 6 + 6*KN_MAX/12 
               = KN_MAX - 6    (im S3Z-Graphen)
     In keinem Patch darf die kritische Summe groesser sein als im kompletten
     S3Z-Graphen. Deshalb passt die kritische Summe in einen KNOTENTYP.
     Auch die Summe zweier kritischer Summen passt -- wie ueblich -- 
     noch in eine Variable vom Typ KNOTENTYP. */
           
BOOL *is_moeglich = nil;     /* is_moeglich[ARRAYPOS_N(g,n)]==False => Graphen
                                mit den 
                                vorgegebenen Flaechengroessen, Geschlecht g und
                                n Knoten gibt es nicht */
POSTYP genus_anf_fd;          /* Flaechendifferenz im 3-regulaeren Graphen
                                   mit Geschlecht "genus_anf" */
POSTYP genus_end_fd;          /* dasselbe fuer "genus_end" */
  /* POSTYP ist ausreichend, denn:
     fd = 12(1-g) - 6r - k   und   n >= 4g - 2   und   r <= genus_end+1   
                             und   k <= n
     =>                      g <= (n+2)/4, also genus_end <= (n_max+2)/4
                       und   r <= genus_end+1   und   k <= n <= n_max 
     =>  r <= (n_max+2)/4 + 1
     =>  fd =  12(1-g) - 6r - k 
            >= 12(1-(n_max+2)/4) - 6((n_max+2)/4 + 1) - n_max
            =  12 - 3*n_max - 6 - 3/2*n_max - 3 - 6 - n_max
            =  - 11/2*n_max - 3
     und POSTYP kann mindestens Werte zwischen -6*n_max und 6*n_max
     aufnehmen */ 
           
BORDERPOS *bind_array[10][V_MAX];  /*[N_MAX_P+1];*/
  /* Fuer den Patch 1 in der Verklebung
   wird festgehalten, welche Verknuepfungen moeglich sind. Es werden
   die Nummern der Randcodes und die Positionen im Randcode gespeichert, 
   an denen die Verknuepfung
   vorgenommen werden koennte. Sei bind_array[j][k][i] das betrachtete Element.
   i ist die Laenge der Verknuepfung (in Kanten),j die Art. Da mehrere
   gleichartige Verknuepfungen auftreten koennen, koennen pro Paar (i,j)
   mehrere Eintraege gespeichert werden, die mit Hilfe von k unterschieden
   werden. Insgesamt sind die Elemente [j][1][i] bis [j][anz[j][i]][i]
   belegt. Maximal V_MAX-1 Eintraege pro Verknuepfungsart koennen gespeichert
   werden. Die Elemente [j][0][i] sind jeweils {0,0}. 
   Sie werden dann gebraucht,
   wenn V_MAX==1, also die bind-Eintraege nicht benutzt werden. In dem Fall
   ist das Element [j][V_MAX-1][i] immer gleich {0,0},
   so dass immer alle Raender eines Patches komplett durchlaufen werden. 

   0: linker Patch - keine Bauchbinde moeglich
   1: linker Patch - es muss Bauchbinde entstehen (sonst nicht kanonisch)
   2: rechter Patch - keine Bauchbinde moeglich (nur bei Paaren)
   3: rechter Patch - "halbe" Bauchbinde entsteht (nur bei Paaren - ob 
      komplette Bauchbinde entsteht, haengt vom linken Patch ab)
   4: Einschluss Patch A, Fall 1a
   5: Einschluss Patch A, Fall 1b
   6: Einschluss Patch A, Fall 2a
   7: Einschluss Patch A, Fall 2b
   8: Einschluss Patch B, Faelle 1a und 2a (nur bei Paaren)
   9: Einschluss Patch B, Faelle 1b und 2b (nur bei Paaren)
   Bei den Faellen 4 bis 9 ist i nicht die Laenge der Naht, sondern der
   erste Eintrag im Bordercode des Patches B (bei 4 bis 7 also der erforder-
   liche und bei 8 und 9 der tatsaechliche Eintrag).
   Bei den Faellen 4 bis 9 ist es unwesentlich, ob eine Bauchbinde entsteht,
   da das Entstehen nicht vom Zusammenspiel zweier Patches (die dann entspre-
   chend zusammenpassen muessen), sondern nur vom Patch A abhaengt.

   Fuer Fall 1 ist keine Speicherung vorgesehen, da bei Fall 1 immer der
   Patch mit sich selbst verklebt wird, was sofort geschehen kann, sobald
   entdeckt wird, dass Fall 1 moeglich ist. */
KNOTENTYP *anz[10];  /*[N_MAX_P+1];*/     /* anz[i][j]<=V_MAX (siehe oben) */
char strpuf[LINELEN];          /* fuer alle moeglichen Strings, die aus
                                  Variablen zusammengesetzt werden */ 
BOOL l1_sandwich = False;   /* True => nur Sandwichpfade, bei denen "l1==1"
     und "l2==1" gilt, koennen kanonisch sein. Daraus folgt, dass ein
     Zweieck eingeschlossen wird. (-) */
BOOL loop_brille = False;   /* True => nur Brillenpfade, bei denen "l1==1"
     gilt, koennen kanonisch sein (-) */
BOOL digon_brille = False;  /* True => nur Brillenpfade, bei denen "l1==2"
     gilt, koennen kanonisch sein. "loop_brille" ist staerker als
     "digon_brille". "digon_brille" kann nur auf "True" gesetzt werden,
     wenn "loop_brille" nicht gesetzt wird. (-) */


/***************/
/* Prototypen: */
/***************/

BOOL schalte_nahtlen_weiter(ELEM *e,POSTYP index,BOOL von_oben);
BOOL schalte_ziellen_weiter(ELEM *e,POSTYP index,BOOL von_oben);
BOOL schalte_ziellen_weiter2(ELEM *e,POSTYP index,BOOL von_oben);
BOOL schalte_randaufteilung_weiter(ELEM *e,POSTYP index,BOOL von_oben);
BOOL schalte_genusaufteilung_weiter(ELEM *e,POSTYP index,BOOL von_oben);
BOOL schalte_knotenaufteilung_weiter(ELEM *e,POSTYP index,BOOL von_oben);
BOOL schalte_kritaufteilung_weiter(ELEM *e,POSTYP index,BOOL von_oben);
void gehe_patchbaum_durch_in_rekursion(KNOTENTYP *bordercode,KNOTENTYP g,
     KNOTENTYP fl,KNOTENTYP krit,POSTYP his_anz);
BOOL schalte_weiter_td(POSTYP *hislen,POSTYP top_index,POSTYP top_level,
                       BOOL *pc,BOOL letzter_patch);


/***************************************/
/* programminterne Speicherverwaltung: */
/***************************************/
 
/*****************KN_MEMCMP***************************************************/
/*  "memcmp" fuer KNOTENTYP - ohne endian-Probleme                           */
 
signed char kn_memcmp(KNOTENTYP *p1,KNOTENTYP *p2,POSTYP anz) {
  while (anz>0) {
    if (*p1 > *p2)      {return(1);}
    else if (*p1 < *p2) {return(-1);}
    p1++;  p2++;
    anz--;
  }
  return(0);
}

/*****************BO_MEMCMP***************************************************/
/*  "memcmp" fuer BORDERPOS - ohne endian-Probleme                           */
 
signed char bo_memcmp(BORDERPOS *p1,BORDERPOS *p2,KNOTENTYP anz) {
  static KNOTENTYP i;
  i = 0;
  while (anz>0) {
    if (p1[i].nr > p2[i].nr)      {return(1);}
    else if (p1[i].nr < p2[i].nr) {return(-1);}
    if (p1[i].pos > p2[i].pos)      {return(1);}
    else if (p1[i].pos < p2[i].pos) {return(-1);}
    anz--;  i++;
  }
  return(0);
}

/***************************REPEATED_FOPEN***********************************/

FILE *repeated_fopen(char *filename,char *mode,int tries) {
//  int i=0;
  FILE *file = nil;
//  do {
    file = fopen(filename,mode);
//    i++;
//    if (file==nil && i<tries) {sleep(5);}
//  } while(file==nil && i<tries);
  return(file);     /* es kann "nil" zurueckgegeben werden */
}

/*******************LOGFILE_ENTRY********************************************/
/*  Schreibt einen String in das Logfile.                                   */
/*  "op" und "cl" geben an, ob das logfile geoeffnet bzw. geschlossen werden
    muss. Natuerlich muss hier sauber vorgegangen werden.                   */
/*  Wenn "force==True", dann wird IMMER auf stderr geschrieben.             */

void logfile_entry(char *string,BOOL op,BOOL cl,BOOL force) {
  static FILE *logfile;  /* MUSS static sein, falls op==False oder cl==False */
  if (stderr_out || force) {fprintf(stderr,"%s",string);}
  if (logfile_out) {
    if (!op || (logfile = repeated_fopen(logfilename,"a",5))) {  
      /* lazy-eval. */
      if (fprintf(logfile,"%s",string)<0) {
        fprintf(stderr,"Cannot write logfile entry '%s'!\n",string);
        perror((char *)"Error description");
      }
      if (cl && fclose(logfile)!=0) {                /* lazy-eval. */
        fprintf(stderr,"Cannot close logfile!\n");
        perror((char *)"Error description");
      } 
    }
    else {
      fprintf(stderr,"Cannot open logfile!\n");
      perror((char *)"Error description");
    }
  }
}

/***************************SCHREIBFEHLER************************************/

void schreibfehler(char *filename,size_t soll,size_t ist,BOOL cont) {
  sprintf(strpuf,"Error while writing to file %s!\n"
          "Tried to write %ld entries, wrote %ld.\n",filename,soll,ist);
  logfile_entry(strpuf,True,True,True);
  perror((char *)"Error description");
  if (cont) {logfile_entry((char *)"Process continues...\n",True,True,True);}
  else {exit(1);}
}

/******************************LESEFEHLER************************************/

void lesefehler(char *filename,size_t soll,size_t ist,BOOL cont) {
  sprintf(strpuf,"Error while reading from file %s!\n"
          "Tried to read %ld entries, read %ld.\n",filename,soll,ist);
  logfile_entry(strpuf,True,True,True);
  perror((char *)"Error description");
  if (cont) {logfile_entry((char *)"Process continues...\n",True,True,True);}
  else {exit(2);}
}

/***********************HOLE_SPEICHER****************************************/
/*  Stellt len Bytes Speicher zur Verfuegung                                */
/*  len wird aufgerundet, so dass die Zahl durch sizeof(void *) teilbar ist */
/*  "count" gibt an, ob der Speicherverbrauch hochgezaehlt werden soll.     */
/*  Falls kein Speicher reserviert werden konnte, so ist der Rueckgabewert
    "nil". In diesem Fall gibt "cancel" an, ob das Programm abgebrochen 
    werden soll.                                                            */

void *hole_speicher(size_t len,BOOL count,BOOL cancel) {    
  static void *ptr;
  if (len > MEMBLOCKSIZE)  
    {logfile_entry((char *)
       "Required memblock too big (change MEMBLOCKSIZE)!\n",True,True,True);
     exit(3);}
  if (currmem==nil) {            /* noch kein dynamischer Speicherbereich */
    if ((firstmem = currmem = (MEMORY *)malloc(sizeof(MEMORY)))==nil) {
      logfile_entry((char *)"No memory for memorynode!\n",True,True,True);
      /* Fehlermeldung auf jeden Fall ausgeben */
      if (cancel) {exit(4);} else {memory_overflow = True;  return(nil);}
    }
    currmem->next = nil;
    currmem->used = 0;
    if ((currmem->memory = malloc(MEMBLOCKSIZE))==nil) {
      logfile_entry((char *)"No memory for memblock!\n",True,True,True);
      if (cancel) {exit(5);} 
      else {memory_overflow = True;  currmem = nil;  return(nil);}
    }
  }
  if (MEMBLOCKSIZE - currmem->used < len) {
      /* Speicherbereich zu klein => naechsten Block bereitstellen */  
    if ((currmem->next = (MEMORY *)malloc(sizeof(MEMORY)))==nil) {
      logfile_entry((char *)"No memory for new memorynode!\n",True,True,True);
      if (cancel) {exit(6);} else {memory_overflow = True;  return(nil);}
    }
    if ((currmem->next->memory = malloc(MEMBLOCKSIZE))==nil) {
      logfile_entry((char *)"No memory for new memblock!\n",True,True,True);
      if (cancel) {exit(7);} 
      else {memory_overflow = True;  currmem->next = nil;  return(nil);}
    }
    currmem = currmem->next;   /* erst hier, falls memblock nicht kommt */
    currmem->next = nil;
    currmem->used = 0;
  }
  if (count) {
    mem_curr += (len-1)/sizeof(void *)*sizeof(void *)+sizeof(void *);
    if (memory_used && mem_curr>=mem_max) { 
      if (cancel)      /* Programm abbrechen */
         {logfile_entry((char *)"User memory limit is violated!\n",True,True,
                        True);   exit(8);}
      else {memory_overflow = True;  return(nil);}
    }
  }   
  ptr = (void *)((char *)(currmem->memory) + currmem->used);
  currmem->used += (len-1)/sizeof(void *)*sizeof(void *)+sizeof(void *);
  return(ptr);
}   


/*****************************************/
/* Initialisierungsfunktionen:           */
/* (werden einmal von "main" aufgerufen) */
/*****************************************/

/***********************INITIALISIERE_ARRAYS*********************************/

void initialisiere_arrays(void) {
  static size_t i,j;

  i = ARRAYPOS_N((size_t)(genus_end_usr+1),n_anf_usr);      /* Arraygroesse */
  is_moeglich = (BOOL *)hole_speicher(sizeof(BOOL)*i,False,True);
  for (j=0; j<i; j++) {is_moeglich[j]=True;} 
}     

/***********************INITIALISIERE_ARRAYS2*********************************/

void initialisiere_arrays2(void) {
  static size_t i,j;
  static POSTYP historylen,acceptlen,n_max_p; 
         /* "weiche" Varianten der Konstanten */
  static KNOTENTYP g,n;

  for (i=0; i<=F_MAXANZ; i++) {tree[i] = nil;}    /* Patchbaeume */
  /* wichtig: auch der nullte Zweig wird initialisiert, da auf ihn zugegriffen
     wird (auf die Weise wird festgestellt, dass keine passenden Patches
           existieren) */

  i = ARRAYPOS_LN((size_t)genus_end_usr,(size_t)n_end_usr,4);  
      /* Arraygroesse */
  graphenzahl = (unsigned long *)hole_speicher(sizeof(unsigned long)*i,
                                 False,True);
  for (j=0; j<i; j++) {graphenzahl[j]=0L;}
  non_iso_graphenzahl = (unsigned long *)hole_speicher(sizeof(unsigned long)*i,
                                         False,True);
  for (j=0; j<i; j++) {non_iso_graphenzahl[j]=0L;}
  connzahl = (unsigned long *)hole_speicher(sizeof(unsigned long)*i,
                              False,True);
  for (j=0; j<i; j++) {connzahl[j]=0L;}
  i = ARRAYPOS_N((size_t)(genus_end_usr+1),n_anf_usr);      /* Arraygroesse */
  outputfile = (char *)hole_speicher(sizeof(char)*i,False,True);
  for (j=0; j<i; j++) {outputfile[j]=0;}

  if (output) {       /* Arrays fuer generierte Karten */
    outputbuffer = (char **)hole_speicher(sizeof(char *)*i,
                                               False,True);
    outputbufferlen = (size_t *)hole_speicher(sizeof(size_t)*i,False,True);
    /* "outputbuffer" und "outputbufferlen":
       fuer groessere Knotenzahlen mehr Speicherplatz */
    for (g=genus_anf_usr; g<=genus_end_usr; g++) {
      for (n=n_anf_usr; n<=n_end_usr; n+=2) {
        j = ARRAYPOS_N(g,n);
        if (j>=i) {fprintf(stderr,"Logischer Fehler in init!\n");  exit(9);}
        if (n_end_usr==n_anf_usr) 
             {outputbufferlen[j] = CODESIZE(n)*basis;}
        else {outputbufferlen[j] = CODESIZE(n)*(basis+zusatz*(n-n_anf_usr)/
                                               (n_end_usr-n_anf_usr));}
        if ((outputbuffer[j] = (char *)malloc(sizeof(char)*
            (outputbufferlen[j]+4*CODESIZE(n)+6)))==nil)
           /* 4*CODESIZE+6 als Ueberhang, so dass der Buffer voll ist, wenn
           "outputbufferused > outputbufferlen" gilt (ZWEIMAL CODESIZE, falls
           2-Byte-Codes gespeichert werden, +3 wegen evtl. 2-Byte-Code- und 
           embed-code-Kennung, und 
           das Ganze nochmals mal 2, weil bei manchen Faellen pro Zweig 2
           Karten - durch Vertauschen der Nebenraender - konstruiert werden,
           zwischen denen KEINE Dumpfile-Speicherung erfolgt). 
           Wichtig: CODESIZE ist die Groesse eines planar_codes, nicht jedoch
           eines embed_codes oder eines 2-Byte-planarcodes. Deshalb kann man
           nicht einfach die Anzahl der gespeicherten Karten mitzaehlen, um den
           Ueberlauf festzustellen. */
           {logfile_entry((char *)"No memory for basic arrays!\n",
            True,True,True);   exit(10);}
      }
    } 
    outputbufferused = (size_t *)hole_speicher(sizeof(size_t)*i,False,True);
    for (j=0; j<i; j++) {outputbufferused[j]=0L;}
    outputfilename = (char **)hole_speicher(sizeof(char *)*i,False,True);
    outputfilename[0] = (char *)hole_speicher(sizeof(char)*i*FILENAME_MAX,
                                False,True);
    for (j=1; j<i; j++) 
        {outputfilename[j] = outputfilename[0] + j*FILENAME_MAX;}
  }
  i = ARRAYPOS_F((size_t)(genus_end_usr+1),1);              /* Arraygroesse */
  patch_anz = (unsigned long *)hole_speicher(sizeof(unsigned long)*i,
                               False,True);
  for (j=0; j<i; j++) {patch_anz[j]=0L;}

  /* die folgenden Arrays nicht ueber "hole_speicher" allozieren, denn sie
     koennen groesser sein als MEMBLOCKSIZE */
  n_max_p = 3*n_end_usr;
  acceptlen = ((n_max_p>>1)>>3)+1;
  historylen = topdown ? 3*n_end_usr+3 : 
               (pv>9 ? (n_end_usr>>1)+2+(genus_end_usr<<1) : 0);   
                 /* Kommentar siehe "HISTORYLEN" */

  /* Arrays fuer die Konstruktion der Stammpatches (immer bottom-up, deshalb
     reicht bottom-up-historylen als Arraygroesse aus) */
  if ((code1_kon = (KNOTENTYP **)malloc(sizeof(KNOTENTYP *)*
      ((n_end_usr>>1)+2+(genus_end_usr<<1))))==nil ||
      (code1_kon[0] = (KNOTENTYP *)malloc(sizeof(KNOTENTYP)*
      ((n_end_usr>>1)+2+(genus_end_usr<<1))*bc_len_max))==nil ||
      (code2_kon = (KNOTENTYP **)malloc(sizeof(KNOTENTYP *)*
      ((n_end_usr>>1)+2+(genus_end_usr<<1))))==nil ||
      (code2_kon[0] = (KNOTENTYP *)malloc(sizeof(KNOTENTYP)*
      ((n_end_usr>>1)+2+(genus_end_usr<<1))*bc_len_max))==nil ||
      (gk1_kon = (KANTE ***)malloc(sizeof(KANTE **)*
      ((n_end_usr>>1)+2+(genus_end_usr<<1))))==nil ||
      (gk1_kon[0] = (KANTE **)malloc(sizeof(KANTE *)*
      ((n_end_usr>>1)+2+(genus_end_usr<<1))*(genus_end_usr+1)))==nil ||
      (gk2_kon = (KANTE ***)malloc(sizeof(KANTE **)*
      ((n_end_usr>>1)+2+(genus_end_usr<<1))))==nil ||
      (gk2_kon[0] = (KANTE **)malloc(sizeof(KANTE *)*
      ((n_end_usr>>1)+2+(genus_end_usr<<1))*(genus_end_usr+1)))==nil)
    {logfile_entry((char *)"No memory for basic arrays!\n",True,True,True);
     exit(95);}
  for (i=1; i<(n_end_usr>>1)+2+(genus_end_usr<<1); i++) {
    gk1_kon[i] = gk1_kon[0] + (size_t)i*(genus_end_usr+1);
    gk2_kon[i] = gk2_kon[0] + (size_t)i*(genus_end_usr+1);
    code1_kon[i] = code1_kon[0] + (size_t)i*bc_len_max;
    code2_kon[i] = code2_kon[0] + (size_t)i*bc_len_max;
  }

  if (patchcheck) {     /* Arrays fuer Patchcheck (=> topdown == False) */
    unsigned char *his_check_iso_array;    /* fuer his_check_iso_rand */
    unsigned char **his_check_iso_array2;  /* fuer *his_check_iso_rand */
    if ((!topdown && ((his_check_iso_array = 
         (unsigned char *)malloc(sizeof(unsigned char)
          *((genus_end_usr>>3)+1)*historylen*CHECKLISTLEN))==nil ||
        (his_check_iso_array2 = (unsigned char **)malloc(sizeof(unsigned
               char *)*((genus_end_usr>>3)+1)*CHECKLISTLEN))==nil ||
        (his_check_count = (unsigned long *)malloc(sizeof(unsigned long)*
                            historylen))==nil))  || 
        (his_check = (unsigned long **)malloc(sizeof(unsigned long *)*
                        CHECKLISTLEN))==nil ||
        (his_check[0] = (unsigned long *)malloc(sizeof(unsigned long)*
                         historylen*CHECKLISTLEN))==nil ||
        (overflow = (BOOL *)malloc(sizeof(BOOL)*historylen))==nil   || 
        (his_check_anz = (unsigned short *)malloc(sizeof(unsigned short)*
                          historylen))==nil   || 
        (his_check_pos = (unsigned short *)malloc(sizeof(unsigned short)*
                          historylen))==nil ||
        (topdown && ((pc_flaechenzahl = (KNOTENTYP *)malloc(sizeof(KNOTENTYP)*
                     anz_face))==nil ||
                     (pc_flaechenzahl_sk = 
                     (KNOTENTYP *)malloc(sizeof(KNOTENTYP)*anz_face))==nil ||
                     (anz_p = (unsigned long *)malloc(sizeof(unsigned long)*
                     historylen))==nil)))
      {logfile_entry((char *)"No memory for basic arrays!\n",True,True,True);
       exit(11);}
    for (i=1; i<CHECKLISTLEN; i++) 
        {his_check[i] = his_check[0] + (size_t)i*historylen;}
    if (!topdown) {
      for (i=0; i<CHECKLISTLEN; i++) {
        his_check_iso_rand[i] = his_check_iso_array2 + 
                                (size_t)i*(genus_end_usr>>3)+1;
        his_check_iso_rand[i][0] = his_check_iso_array + 
                                   (size_t)i*((genus_end_usr>>3)+1)*historylen;
        for (j=1; j<(genus_end_usr>>3)+1; j++)
          {his_check_iso_rand[i][j] = his_check_iso_rand[i][0] + 
                                      (size_t)j*historylen;}
      }
    }
  }

  if (topdown) {     /* Arrays fuer topdown-Generierung => Rekursion==False */
    if ((bc_td[0] = (KNOTENTYP **)malloc(sizeof(KNOTENTYP *)*historylen))==nil
        || (bc_td[0][0] = (KNOTENTYP *)malloc(sizeof(KNOTENTYP)*historylen*
                          bc_len_max))==nil ||
        (bc_td[1] = (KNOTENTYP **)malloc(sizeof(KNOTENTYP *)*historylen))==nil
        || (bc_td[1][0] = (KNOTENTYP *)malloc(sizeof(KNOTENTYP)*historylen*
                          bc_len_max))==nil ||
        (per_td[0] = (KNOTENTYP **)malloc(sizeof(KNOTENTYP *)*historylen))
                     ==nil ||
        (per_td[0][0] = (KNOTENTYP *)malloc(sizeof(KNOTENTYP)*historylen*
                         (genus_end_usr+1)))==nil ||
        (per_td[1] = (KNOTENTYP **)malloc(sizeof(KNOTENTYP *)*historylen))
                     ==nil ||
        (per_td[1][0] = (KNOTENTYP *)malloc(sizeof(KNOTENTYP)*historylen*
                        (genus_end_usr+1)))==nil ||
        (anz_bk_td[0] = (KNOTENTYP *)malloc(sizeof(KNOTENTYP)*2L*
                         historylen))==nil ||
        (anz3_td[0] = (KNOTENTYP *)malloc(sizeof(KNOTENTYP)*2L*
                       historylen))==nil ||
        (n_td[0] = (EULERTYP *)malloc(sizeof(EULERTYP)*2L*
                        historylen))==nil ||
        (gk_td = (KANTE ***)malloc(sizeof(KANTE **)*historylen))==nil ||
        (gk_td[0] = (KANTE **)malloc(sizeof(KANTE *)*historylen*
                              (genus_end_usr+1)))==nil ||
        (ziellenrandcodepos_td = (KNOTENTYP *)malloc(sizeof(KNOTENTYP)*
                                  historylen))==nil ||
        (ziellenposindex_td = (KNOTENTYP *)malloc(sizeof(KNOTENTYP)*
                               historylen))==nil ||
        (vor1 = (BOOL *)malloc(sizeof(BOOL)*historylen))==nil   || 
        (vor2 = (BOOL *)malloc(sizeof(BOOL)*historylen))==nil   || 
        (vor =  (char *)malloc(sizeof(char)*historylen))==nil   ||
        (vater_nr =  (POSTYP *)malloc(sizeof(POSTYP)*historylen))==nil   ||
        (fl_td[0] = (EULERTYP *)malloc(sizeof(KNOTENTYP)*2L*historylen))==nil
        || (g_td[0] = (EULERTYP *)malloc(sizeof(EULERTYP)*2L*historylen))==nil
        || (krit_td[0] = (KNOTENTYP *)malloc(sizeof(KNOTENTYP)*2L*historylen))
           ==nil
        || (kriti_td = (KNOTENTYP *)malloc(sizeof(KNOTENTYP)*historylen))
           ==nil
        || (fl_max_td[0] = (KNOTENTYP *)malloc(sizeof(KNOTENTYP)*2L*
                           historylen))==nil ||
        (fl_min_td[0] = (KNOTENTYP *)malloc(sizeof(KNOTENTYP)*2L*
                        historylen))==nil ||
        (bk_moeglich = (BOOL **)malloc(sizeof(BOOL *)*((n_end_usr>>1)+3)))==nil
        || (bk_moeglich[0] = (BOOL *)malloc(sizeof(BOOL)*((n_end_usr>>1)+3)*
                                            (bk_max+1)))==nil ||
        (kp_moeglich = (BOOL **)malloc(sizeof(BOOL *)*((n_end_usr>>1)+3)))==nil
        || (kp_moeglich[0] = (BOOL *)malloc(sizeof(BOOL)*((n_end_usr>>1)+3)*
                             ((krit_max>>3)+1)*(bk_max+1)))==nil ||
        (kp = (KNOTENTYP ***)malloc(sizeof(KNOTENTYP **)*((n_end_usr>>1)+3)))
              ==nil
        || (kp[0] = (KNOTENTYP **)malloc(sizeof(KNOTENTYP *)*
                    ((n_end_usr>>1)+3)*(bk_max+1)))==nil ||
        (kp_anz = (KNOTENTYP **)malloc(sizeof(KNOTENTYP *)*((n_end_usr>>1)+3)))
                  ==nil ||
        (kp_anz[0] = (KNOTENTYP *)malloc(sizeof(KNOTENTYP)*
                     ((n_end_usr>>1)+3)*(bk_max+1)))==nil ||
        (kpk = (KNOTENTYP **)malloc(sizeof(KNOTENTYP *)*
               ARRAYPOS_N((size_t)(genus_end_usr+1),n_anf_usr)))==nil
        || (kpk[0] = (KNOTENTYP *)malloc(sizeof(KNOTENTYP)*
                     ARRAYPOS_N((size_t)(genus_end_usr+1),n_anf_usr)*
                     (krit_max-krit_min+1)))==nil ||
        (kpk_anz = (KNOTENTYP *)malloc(sizeof(KNOTENTYP)*
                   ARRAYPOS_N((size_t)(genus_end_usr+1),n_anf_usr)))==nil ||
        (his_acc = (unsigned char **)malloc(sizeof(unsigned char *)*
                    historylen))==nil ||
        (his_acc[0] = (unsigned char *)malloc(sizeof(unsigned char)*
                       historylen*acceptlen))==nil ||
        (facenumbers && (his_faces = (KNOTENTYP *)malloc(sizeof(KNOTENTYP)*
                         historylen*anz_face))==nil) ||
        (history = (ELEM *)malloc(sizeof(ELEM)*(historylen+1)))==nil  || 
        (hiscopy = (ELEM *)malloc(sizeof(ELEM)*historylen))==nil  || 
        (his_rl2 = (KNOTENTYP *)malloc(sizeof(KNOTENTYP)*historylen))==nil  || 
        (his_rlg2 = (KNOTENTYP *)malloc(sizeof(KNOTENTYP)*historylen))==nil)
        {logfile_entry((char *)"No memory for basic arrays!\n",True,True,True);
         exit(12);}
    fl_td[1] = fl_td[0] + historylen;
    g_td[1]  = g_td[0]  + historylen;
    krit_td[1] = krit_td[0] + historylen;
    fl_max_td[1] = fl_max_td[0] + historylen;
    fl_min_td[1] = fl_min_td[0] + historylen;
    n_td[1]  = n_td[0] + historylen;
    anz3_td[1] = anz3_td[0] + historylen;
    anz_bk_td[1] = anz_bk_td[0] + historylen;
    for (i=1; i<=genus_end_usr; i++) {
      per_td[0][i] = per_td[0][0] + (size_t)i*historylen;
      per_td[1][i] = per_td[1][0] + (size_t)i*historylen;
    }
    for (i=1; i<historylen; i++) {
      gk_td[i] = gk_td[0] + (size_t)i*(genus_end_usr+1);
      bc_td[0][i]  = bc_td[0][0] + (size_t)i*bc_len_max;
      bc_td[1][i]  = bc_td[1][0] + (size_t)i*bc_len_max;
      his_acc[i] = his_acc[0] + (size_t)i*acceptlen;
    }
    for (i=0; i<(n_end_usr>>1)+3; i++) {
      if (i>0) {bk_moeglich[i] = bk_moeglich[0] + (size_t)i*(bk_max+1);}
      for (j=0; j<=bk_max; j++) {bk_moeglich[i][j] = False;} 
      if (i>0) {kp_moeglich[i] = kp_moeglich[0] + 
                                 (size_t)i*((krit_max>>3)+1)*(bk_max+1);}
      for (j=0; j<((krit_max>>3)+1)*(bk_max+1); j++) {kp_moeglich[i][j] = 0;}
      if (i>0) {kp[i] = kp[0] + (size_t)i*(bk_max+1);
                kp_anz[i] = kp_anz[0] + (size_t)i*(bk_max+1);}
      for (j=0; j<=bk_max; j++) {kp_anz[i][j] = 0;}
    }
    for (i=0; i<ARRAYPOS_N((size_t)(genus_end_usr+1),n_anf_usr); i++) { 
      if (i>0) {kpk[i] = kpk[0] + (size_t)i*(krit_max-krit_min+1);}
      kpk_anz[i] = 0;
    }
    for (i=0; i<historylen; i++) {     /* "history" initialisieren */
      history[i].next = nil;
      history[i].his_nr = i;
      history[i].stamm = False;
      history[i].flaechenzahl = facenumbers ? his_faces+i*anz_face : nil;
      for (j=0; j<acceptlen; j++) {his_acc[i][j] = 0;}  /* wichtig, da der
                Inhalt fuer den ersten Aufruf der Rekursion leer sein muss */
      if (patchcheck) {his_check_anz[i] = 0;}   
    }
  }

  else if (pv>9) {              /* Rekursion, aber kein Topdown */
    if ((his_acc = (unsigned char **)malloc(sizeof(unsigned char *)*
                    historylen))==nil ||
        (his_acc[0] = (unsigned char *)malloc(sizeof(unsigned char)*
                       historylen*acceptlen))==nil ||
        (facenumbers && (his_faces = (KNOTENTYP *)malloc(sizeof(KNOTENTYP)*
                         historylen*anz_face))==nil) ||
        (history = (ELEM *)malloc(sizeof(ELEM)*(historylen+1)))==nil  || 
        (hiscopy = (ELEM *)malloc(sizeof(ELEM)*historylen))==nil  || 
        (his_rl2 = (KNOTENTYP *)malloc(sizeof(KNOTENTYP)*historylen))==nil  || 
        (his_rlg2 = (KNOTENTYP *)malloc(sizeof(KNOTENTYP)*historylen))==nil ||
        (bordercode2_sppr = (KNOTENTYP **)malloc(sizeof(KNOTENTYP *)*
         historylen))==nil ||
        (bordercode2_sppr[0] = (KNOTENTYP *)malloc(sizeof(KNOTENTYP)*
         historylen*bc_len_max))==nil ||
        (randcode2_vpr = (KNOTENTYP **)malloc(sizeof(KNOTENTYP *)*
         historylen))==nil ||
        (randcode2_vpr[0] = (KNOTENTYP *)malloc(sizeof(KNOTENTYP)*
         historylen*2*bk_max))==nil ||
        (ergrandcode_vpr = (KNOTENTYP **)malloc(sizeof(KNOTENTYP *)*
         historylen))==nil ||
        (ergrandcode_vpr[0] = (KNOTENTYP *)malloc(sizeof(KNOTENTYP)*
         historylen*2*bk_max))==nil ||
        (ergrandcode2_vpr = (KNOTENTYP **)malloc(sizeof(KNOTENTYP *)*
         historylen))==nil ||
        (ergrandcode2_vpr[0] = (KNOTENTYP *)malloc(sizeof(KNOTENTYP)*
         historylen*2*bk_max))==nil ||
        (ergcode_vpr = (KNOTENTYP **)malloc(sizeof(KNOTENTYP *)*
         historylen))==nil ||
        (ergcode_vpr[0] = (KNOTENTYP *)malloc(sizeof(KNOTENTYP)*
         historylen*bc_len_max))==nil)
      {logfile_entry((char *)"No memory for basic arrays!\n",True,True,True);
       exit(13);}
    for (i=1; i<historylen; i++) {his_acc[i] = his_acc[0] + i*acceptlen;}
    for (i=0; i<historylen; i++) {     /* "history" initialisieren */
      history[i].next = nil;
      history[i].his_nr = i;
      history[i].stamm = False;
      history[i].flaechenzahl = facenumbers ? his_faces+i*anz_face : nil;
      bordercode2_sppr[i] = bordercode2_sppr[0] + (size_t)i*bc_len_max;
      randcode2_vpr[i] = randcode2_vpr[0] + (size_t)i*2*bk_max;
      ergrandcode_vpr[i] = ergrandcode_vpr[0] + (size_t)i*2*bk_max;
      ergrandcode2_vpr[i] = ergrandcode2_vpr[0] + (size_t)i*2*bk_max;
      ergcode_vpr[i] = ergcode_vpr[0] + (size_t)i*bc_len_max;
      for (j=0; j<acceptlen; j++) {his_acc[i][j] = 0;}  /* wichtig, da der
                Inhalt fuer den ersten Aufruf der Rekursion leer sein muss */
      if (patchcheck) {his_check_anz[i] = 0;}   
    }
  }

  /* "bind", "anz" und "recoverdata" initialisieren: */
  if ((bind_array[0][0] = (BORDERPOS *)malloc(sizeof(BORDERPOS)*(n_max_p+1)*10L*
       V_MAX))==nil ||
      (anz[0] = (KNOTENTYP *)malloc(sizeof(KNOTENTYP)*(n_max_p+1)*10L))==nil) 
     {logfile_entry((char *)"No memory for basic arrays!\n",True,True,True);
      exit(14);}
  for (i=0; i<10; i++) {
    anz[i] = anz[0] + i*(n_max_p+1);
    for (j=(i==0 ? 1 : 0); j<V_MAX; j++) 
        {bind_array[i][j] = bind_array[0][0] + ((size_t)i*V_MAX+j)*(n_max_p+1);}
    for (j=0; j<=n_max_p; j++) 
        {anz[i][j] = 0;   bind_array[i][0][j].nr = bind_array[i][0][j].pos = 0;}
    /*  Auch die nullte Reihe von "anz" muss initialisiert werden, weil darauf 
        zugegriffen werden kann. Das Programm merkt dann auf diese Weise, dass
        kein Durchschnitt der Laenge 0 moeglich ist. Die "bind"-Elemente 
        werden belegt fuer den Fall, dass V_MAX==1 ist 
        (siehe Variablendeklaration). */
  }
  if ((recover || save) &&
      (recoverdata = (unsigned char *)malloc(sizeof(unsigned char)*
      (190L + anz_face*6L + big_face*(delaney==True) + MAX(8L,sizeof(unsigned
       long))*historylen + 3*MAX(8L,sizeof(unsigned long)) + 
       12L*(genus_end_usr+1L)
       + 24L*ARRAYPOS_LN((size_t)genus_end_usr,(size_t)n_end_usr,4))))==nil)
  /* eigentlich benoetigter konstanter Wert: 140 statt 190 */
     {logfile_entry((char *)"No memory for basic arrays!\n",True,True,True);
      exit(15);}
  if (topdown || pv>9) {
    /* "zweig" (und "nebenzweig") auf jeden Fall allozieren, auch wenn 
       "save==False" und "recover==False", um if-Abfragen vor dem Aufrufen
       eines Arrayelements zu sparen. */
    if ((zweig = (unsigned long *)malloc(sizeof(unsigned long)*
                  historylen))==nil)
       {logfile_entry((char *)"No memory for basic arrays!\n",True,True,True);
        exit(16);}
    zweig[0] = 0L;                      /* fuer bottom-up wichtig */
    if (recover &&                      /* "recoverzweig" einfuehren */
       (recoverzweig = (unsigned long *)
        malloc(sizeof(unsigned long)*historylen))==nil)
       {logfile_entry((char *)"No memory for basic arrays!\n",True,True,True);
        exit(17);}
  }
}     


/**************************************/
/* Funktionen fuer den Recover-Modus: */
/**************************************/

/*******************SIGNALHANDLER****************************/

#ifndef NOTIMES
/* SA_OLDSTYLE */

#ifndef	SA_RESTART
#define	SA_RESTART	0
#endif

#ifdef __STDC__
volatile	int	save_flag = 0;

void	sigcatch( int sig )
{
	save_flag = 1;
}

int		setup( void )

#else

int save_flag = 0;

void sigcatch (int sig)
{
	save_flag = 1;
}


int		setup()
#endif

{
	struct	sigaction	action, old;
	struct	itimerval	timer;

	action.sa_handler = sigcatch;
	action.sa_flags   = SA_RESTART;
	sigemptyset( &action.sa_mask );

	if( sigaction( SIGALRM, &action, &old ) == -1 )
	{
		perror( "sigaction" );
		return( -1 );
	}

	timer.it_interval.tv_sec  = S_intervall;
	timer.it_interval.tv_usec = 0;
	timer.it_value.tv_sec     = timer.it_interval.tv_sec;
	timer.it_value.tv_usec    = timer.it_interval.tv_usec;

	if( setitimer( ITIMER_REAL, &timer, NULL ) == -1 )
	{
		perror( "setitimer" );
		sigaction( SIGALRM, &old, NULL );
		return( -1 );
	}

	return( 0 );
}
#else
int	save_flag = 0;
#endif //NOTIMES
/*******************SORTIERE_STATISTIK_IN_BAUM2***************************/
/*  Wie "sortiere_statistik_in_baum", aber fuer den Recover-Modus. Es
    werden gleich die kompletten Zahlen geschrieben.                     */

void sortiere_statistik_in_baum2(FLAECHENTYP *f,KNOTENTYP len,
                                 unsigned long zahl) {
  static KNOTENTYP l;
  static STATTREENODE *t, *t2, *t3, *t4; 
  l = 0; 
  while (l<len) {         /* noch nicht am Ende des Codes */
    if (l==0) {t=facestatbaum;} else {t4=t; t=t->nextlevel;}
    t2 = nil;
    while (t && t->code<f[l]) {t2=t; t=t->next;}
    if (t==nil || t->code!=f[l]) {  /* neuen Baumknoten einrichten */
      t3 = (STATTREENODE *)hole_speicher(sizeof(STATTREENODE),False,True);
      if (t2==nil)
        {if (l==0) {facestatbaum = t3;} else {t4->nextlevel = t3;} }
      else {t2->next = t3;}
      t3->next = t;      t3->zaehler = 0;
      t3->code = f[l];   t3->nextlevel = nil;
      t = t3;        /* t ist Liste, in die eingeordnet wird */
    }      /* if */
    l++;
  }        /* while */

  /* Zaehler am Blatt setzen: */
  t->zaehler = zahl;
}   

/********************SCHREIBE_FACESTATBAUM_IN_DUMPFILE******************/
/*  liest die Flaechenstatistik aus und schreibt sie in das Dumpfile.  */

void schreibe_facestatbaum_in_dumpfile(STATTREENODE *root,
       FLAECHENTYP *code,FLAECHENTYP len,FILE *recoverfile) {
  static FLAECHENTYP f;
  static unsigned char data[MAXFTYPEN*2+10];
  static size_t pos,written;
  while (root) {                         /* einen Level durchgehen */
    code[len] = root->code;  len++;
    if (root->zaehler) {
      pos = 0L;
      for (f=0; f<len; f++) {
        data[pos++] = (unsigned char)(code[f]>>8);
        data[pos++] = (unsigned char)(code[f]&255);
      }
      data[pos++] = 0;
      data[pos++] = 0;    /* Trennzeichen */
#if (ULONG_MAX == 4294967295UL)
      data[pos++] = (unsigned char) 0;
      data[pos++] = (unsigned char) 0;
      data[pos++] = (unsigned char) 0;
      data[pos++] = (unsigned char) 0;
#else // 64 bit
      data[pos++] = (unsigned char)(root->zaehler>>56);
      data[pos++] = (unsigned char)((root->zaehler>>48)&255);
      data[pos++] = (unsigned char)((root->zaehler>>40)&255);
      data[pos++] = (unsigned char)((root->zaehler>>32)&255);
#endif
      data[pos++] = (unsigned char)((root->zaehler>>24)&255);
      data[pos++] = (unsigned char)((root->zaehler>>16)&255);
      data[pos++] = (unsigned char)((root->zaehler>>8)&255);
      data[pos++] = (unsigned char)(root->zaehler&255);
      if ((written = fwrite(data,sizeof(unsigned char),pos,recoverfile)) < pos)
         {schreibfehler(recoversavefilename,pos,written,True);}
    }
    if (root->nextlevel) {schreibe_facestatbaum_in_dumpfile(root->nextlevel,
                          code,len,recoverfile);}
    root = root->next;  len--;
  }
}

/*******************LIES_FACESTAT_AUS_DUMPFILE******************************/
/*  Bildet den facestatbaum mit den Informationen aus dem Dumpfile         */

void lies_facestat_aus_dumpfile(FILE *recoverfile) {
  static unsigned char data[8];
  static unsigned long zahl;
  static FLAECHENTYP f,faces[MAXFTYPEN];
  static size_t gelesen;
  while (!feof(recoverfile)) {
    f = 0;
    do {
      if ((gelesen = fread(data,sizeof(unsigned char),2L,recoverfile))<2L) {
        if (!feof(recoverfile) || f>0) 
           {lesefehler(recoverreadfilename,2L,gelesen,False);}
        else {return;}
      }
      if ((FLAECHENTYP)(data[0])<<8 | (FLAECHENTYP)(data[1])) 
         {faces[f++] = (FLAECHENTYP)(data[0])<<8 | (FLAECHENTYP)(data[1]);} 
    } while ((FLAECHENTYP)(data[0])<<8 | (FLAECHENTYP)(data[1]));
    if ((gelesen = fread(data,sizeof(unsigned char),8L,recoverfile))<8L)
        {lesefehler(recoverreadfilename,8L,gelesen,False);}
    if (comp4) {    /* obere 4 Bytes ignorieren */
      zahl = (unsigned long)(data[4])<<24 |
             (unsigned long)(data[5])<<16 |
             (unsigned long)(data[6])<<8  |
             (unsigned long)(data[7]);
    }
    else {
#if (ULONG_MAX == 4294967295UL)
      //      if (sizeof(unsigned long)==4) {   
        /* pruefen, ob zu grosse Zahl eingelesen wird (z.B. von alpha) */
        if (data[0] || data[1] || data[2] || data[3]) 
	   {logfile_entry((char *)"Error while reading dump file: Number too "
            "large (too small architecture?)\n",True,True,True); exit(171);}
        zahl = (unsigned long)(data[4])<<24 |
               (unsigned long)(data[5])<<16 |
               (unsigned long)(data[6])<<8  |
               (unsigned long)(data[7]);
	//      }
#else // 64 bit
	//     else {       /* alle 8 Bytes werden ernst genommen */
        zahl = (unsigned long)(data[0])<<56 |
               (unsigned long)(data[1])<<48 |
               (unsigned long)(data[2])<<40 |
               (unsigned long)(data[3])<<32 |
               (unsigned long)(data[4])<<24 |
               (unsigned long)(data[5])<<16 |
               (unsigned long)(data[6])<<8  |
               (unsigned long)(data[7]);
	//      }
#endif
    }
    sortiere_statistik_in_baum2(faces,f,zahl);
  }
}
    
/*******************SCHREIBE_DUMPFILE***************************************/
/*  Diese Funktion schreibt alle Daten, die zum Recovern des Prozesses
    benoetigt werden, in die Datei mit dem Namen "recoversavefilename"     */
/*  Es wird davon ausgegangen, dass kein zu speichernder Wert groesser
    als 2^64-1 ist.                                                        */
/*  Einige Flags und Werte werden abgespeichert, obwohl sie auch aus dem
    Filenamen herausgelesen werden koennten. Aber so kann die Information
    auch nach einer eventuellen Umbennung des Files rekonstruiert werden. 
    Um das Dumpfile fuer "CGF" wieder verwenden zu koennen, muss es dann
    jedoch korrekt zurueckbenannt werden, da in "lies_dumpfile" der 
    Filename mit dem Inhalt des Dumpfiles verglichen wird.                 */
/*  Falls "finished" den Wert "True" besitzt, so ist der Prozess zu Ende.  */
/*  "hislen" enthaelt die Anzahl der interessanten Eintraege in die
    History.                                                               */
/*  Die letzten 15 Argumente praezisieren die Stelle, an der sich die
    Generierung befindet. "krit1", "krit2" und "krit3" sind bei bottom-up
    die kritischen Punkte selbst, bei top-down aber nur die Indizes auf
    die passende Stelle im Array "kp". Jedenfalls wird genau diese 
    Information beim Recovering wieder benoetigt.                          */

void schreibe_dumpfile(BOOL finished,POSTYP hislen,unsigned char *data,
     unsigned char pfadtyp,unsigned char mgl,unsigned char submgl,
     KNOTENTYP l1,KNOTENTYP l2,KNOTENTYP l3,KNOTENTYP fl1,KNOTENTYP fl2,
     KNOTENTYP n,KNOTENTYP g1,KNOTENTYP g2,KNOTENTYP g,KNOTENTYP krit1,
     KNOTENTYP krit2,KNOTENTYP krit3) {
  static FILE *recoverfile;
  static KNOTENTYP i;
  static FLAECHENTYP f,faces[MAXFTYPEN];
  static size_t pos,j,jj,written;
  static int dummy;
#ifndef NOTIMES
  static clock_t dummy_ct,medtime;
#endif //NOTIMES

  pos = 0L;                             /* Position im Array "data" */
  data[pos++] = finished;                    /* Finished   */
  
  if (!finished) {
    /* "lazydump", "save_used" und "no_recover_used" brauchen natuerlich nicht 
       gespeichert zu werden, da sie das Speichern selbst steuern. Auch 
       "shortfilename_used" wird nicht gespeichert. Ebenso "alias", 
       "old_mod2" und "old_class2" sowie "alias2", 
       "old_mod3" und "old_class3", sowie "alias3", 
       "old_mod4" und "old_class4", weil diese Variablen nach dem Einlesen
       des Recoverfiles wertlos werden. "comp4" wird nur beim Einlesen
       gebraucht. */
    data[pos++] = (unsigned char)
                  (v_used + (output_used<<1) + (outputmem_used<<2) +
                  (types_used<<3) + (facecon_used<<4) + (logfile_used<<5) +
                  (g_used<<6) + (gs_used<<7));
    data[pos++] = (unsigned char)
                  (mapstat_used + (mapcon_used<<1) + (vs_used<<2) +
                  (f_used<<3) + (fileindex_used<<4) + (facestat_used<<5) +
                  (pv_used<<6) + (digon_path_used<<7));
    data[pos++] = (unsigned char)
                  (delaney_used + (logfilename_used<<1) + (topdown_used<<2) +
                  (patchstat_used<<3) + (patchcheck_used<<4) + (pid_used<<5) +
                  (priority_used<<6) + (patchcon_used<<7));
    data[pos++] = (unsigned char)
                  (alt_used + (dual_used<<1) + (db_used<<2) + 
                  (td_limits_used<<3) + (memory_used<<4) + (mod_used<<5) +
                  (class_used<<6) + ((level_used|level2_used)<<7));
    data[pos++] = (unsigned char)(n_anf_usr>>8);
    data[pos++] = (unsigned char)(n_anf_usr&255);
    data[pos++] = (unsigned char)(n_end_usr>>8);
    data[pos++] = (unsigned char)(n_end_usr&255);
    data[pos++] = (unsigned char)(genus_anf_usr>>8);
    data[pos++] = (unsigned char)(genus_anf_usr&255);
    data[pos++] = (unsigned char)(genus_end_usr>>8);
    data[pos++] = (unsigned char)(genus_end_usr&255);
    data[pos++] = (unsigned char)(anz_face>>8);
    data[pos++] = (unsigned char)(anz_face&255);
    data[pos++] = (unsigned char)
                  (facestat + (facerestrict<<1) + (facenumbers<<2) +
                  (mod2_used<<3) + (output<<4) + (do_bauchbinde<<5) +
                  (do_sandwich<<6) + (do_brille<<7));
    data[pos++] = (unsigned char)
                  (alternative + (dual<<1) + (conn1<<2) + 
                  (conn2<<3) + (conn3<<4) + (do_conn<<5) +
                  (patchconn<<6) + (graphstat<<7));
    data[pos++] = pv;
    data[pos++] = (unsigned char)(bauchbindenkennung>>8);
    data[pos++] = (unsigned char)(bauchbindenkennung&255);
    data[pos++] = (unsigned char)(sandwichkennung>>8);
    data[pos++] = (unsigned char)(sandwichkennung&255);
    data[pos++] = (unsigned char)(brillenkennung>>8);
    data[pos++] = (unsigned char)(brillenkennung&255);
    data[pos++] = (unsigned char)
                  (facecon1 + (facecon2<<1) + (doppelkanten<<2) + 
                  (delaney<<3) + (patchcheck<<4) + (pco<<5) +
                  (logfile_out<<6) + (stderr_out<<7));
    data[pos++] = (unsigned char)(td_limits + (td_limits_auto<<1) +
                  (digon_path<<2) + (topdown<<3) + (class2_used<<4) +
                  (mdeza1_used<<5));
    for (f=0; f<anz_face; f++) {
      data[pos++] = (unsigned char)(face[f]>>8);
      data[pos++] = (unsigned char)(face[f]&255);
      data[pos++] = (unsigned char)(facenum_min_usr[f]>>8);
      data[pos++] = (unsigned char)(facenum_min_usr[f]&255);
      data[pos++] = (unsigned char)(facenum_max_usr[f]>>8);
      data[pos++] = (unsigned char)(facenum_max_usr[f]&255);
    }    
    /* die Patchstatistik braucht nicht gespeichert zu werden, da die Patches
       bei einem Recovering komplett neu erzeugt werden muessen. */
    jj = ARRAYPOS_LN((size_t)genus_end_usr,(size_t)n_end_usr,4);
    for (j=0; j<jj; j++) {
      //if (sizeof(unsigned long)==4) {
#if (ULONG_MAX == 4294967295UL)
        data[pos++] = 0;  data[pos++] = 0;  
        data[pos++] = 0;  data[pos++] = 0;
	// }
	//else {
#else // 64 bit
        data[pos++] = (unsigned char)(graphenzahl[j]>>56);
        data[pos++] = (unsigned char)((graphenzahl[j]>>48)&255);
        data[pos++] = (unsigned char)((graphenzahl[j]>>40)&255);
        data[pos++] = (unsigned char)((graphenzahl[j]>>32)&255);
	//}
#endif
      data[pos++] = (unsigned char)((graphenzahl[j]>>24)&255);
      data[pos++] = (unsigned char)((graphenzahl[j]>>16)&255);
      data[pos++] = (unsigned char)((graphenzahl[j]>>8)&255);
      data[pos++] = (unsigned char)(graphenzahl[j]&255);
      //      if (sizeof(unsigned long)==4) {
#if (ULONG_MAX == 4294967295UL)
        data[pos++] = 0;  data[pos++] = 0;  
        data[pos++] = 0;  data[pos++] = 0;
	//}
#else // 64 bit
	//else {
        data[pos++] = (unsigned char)(non_iso_graphenzahl[j]>>56);
        data[pos++] = (unsigned char)((non_iso_graphenzahl[j]>>48)&255);
        data[pos++] = (unsigned char)((non_iso_graphenzahl[j]>>40)&255);
        data[pos++] = (unsigned char)((non_iso_graphenzahl[j]>>32)&255);
	//}
#endif
      data[pos++] = (unsigned char)((non_iso_graphenzahl[j]>>24)&255);
      data[pos++] = (unsigned char)((non_iso_graphenzahl[j]>>16)&255);
      data[pos++] = (unsigned char)((non_iso_graphenzahl[j]>>8)&255);
      data[pos++] = (unsigned char)(non_iso_graphenzahl[j]&255);
      //      if (sizeof(unsigned long)==4) {
#if (ULONG_MAX == 4294967295UL)
        data[pos++] = 0;  data[pos++] = 0;  
        data[pos++] = 0;  data[pos++] = 0;
	// }
#else // 64 bit
	//else {
        data[pos++] = (unsigned char)(connzahl[j]>>56);
        data[pos++] = (unsigned char)((connzahl[j]>>48)&255);
        data[pos++] = (unsigned char)((connzahl[j]>>40)&255);
        data[pos++] = (unsigned char)((connzahl[j]>>32)&255);
	//}
#endif
      data[pos++] = (unsigned char)((connzahl[j]>>24)&255);
      data[pos++] = (unsigned char)((connzahl[j]>>16)&255);
      data[pos++] = (unsigned char)((connzahl[j]>>8)&255);
      data[pos++] = (unsigned char)(connzahl[j]&255);
    }
    if (delaney) {for (f=1; f<=big_face; f++) {data[pos++] = dela_set[f];} }
    //    if (sizeof(unsigned long)==4) {
#if (ULONG_MAX == 4294967295UL)
      data[pos++] = 0;  data[pos++] = 0;  
      data[pos++] = 0;  data[pos++] = 0;
      //}
#else // 64 bit
      //else {
      data[pos++] = (unsigned char)(basis>>56);  
      data[pos++] = (unsigned char)((basis>>48)&255);
      data[pos++] = (unsigned char)((basis>>40)&255);
      data[pos++] = (unsigned char)((basis>>32)&255);
      //}
#endif
    data[pos++] = (unsigned char)((basis>>24)&255);
    data[pos++] = (unsigned char)((basis>>16)&255);
    data[pos++] = (unsigned char)((basis>>8)&255);
    data[pos++] = (unsigned char)(basis&255);
    //    if (sizeof(unsigned long)==4) {
#if (ULONG_MAX == 4294967295UL)
      data[pos++] = 0;  data[pos++] = 0;  
      data[pos++] = 0;  data[pos++] = 0;
      //}
#else // 64 bit
      //else {
      data[pos++] = (unsigned char)(zusatz>>56);  
      data[pos++] = (unsigned char)((zusatz>>48)&255);
      data[pos++] = (unsigned char)((zusatz>>40)&255);
      data[pos++] = (unsigned char)((zusatz>>32)&255);
      //}
#endif
    data[pos++] = (unsigned char)((zusatz>>24)&255);
    data[pos++] = (unsigned char)((zusatz>>16)&255);
    data[pos++] = (unsigned char)((zusatz>>8)&255);
    data[pos++] = (unsigned char)(zusatz&255);
    //    if (sizeof(unsigned long)==4) {
#if (ULONG_MAX == 4294967295UL)
      data[pos++] = 0;  data[pos++] = 0;  
      data[pos++] = 0;  data[pos++] = 0;
      //}
#else // 64 bit
      //else {
      data[pos++] = (unsigned char)(mem_max>>56);  
      data[pos++] = (unsigned char)((mem_max>>48)&255);
      data[pos++] = (unsigned char)((mem_max>>40)&255);
      data[pos++] = (unsigned char)((mem_max>>32)&255);
      //}
#endif
    data[pos++] = (unsigned char)((mem_max>>24)&255);
    data[pos++] = (unsigned char)((mem_max>>16)&255);
    data[pos++] = (unsigned char)((mem_max>>8)&255);
    data[pos++] = (unsigned char)(mem_max&255);
    /* "memory_overflow" wird natuerlich nicht gespeichert, da der Zustand 
       im Bedarfsfall durch die Patcherzeugung erreicht wird. */
    /* "history" und "his_check" werden nicht gespeichert, da sie beim 
       Recovern reproduziert werden. */
    if (topdown) {
      for (i=0; i<=genus_end_usr; i++) {
        data[pos++] = (unsigned char)(cmax_g_usr[i]>>8);
        data[pos++] = (unsigned char)(cmax_g_usr[i]&255);
        data[pos++] = (unsigned char)(fmax_g_usr[i]>>8);
        data[pos++] = (unsigned char)(fmax_g_usr[i]&255);
        data[pos++] = (unsigned char)(bmax_g_usr[i]>>8);
        data[pos++] = (unsigned char)(bmax_g_usr[i]&255);
        data[pos++] = (unsigned char)(cmax_g[i]>>8);
        data[pos++] = (unsigned char)(cmax_g[i]&255);
        data[pos++] = (unsigned char)(fmax_g[i]>>8);
        data[pos++] = (unsigned char)(fmax_g[i]&255);
        data[pos++] = (unsigned char)(bmax_g[i]>>8);
        data[pos++] = (unsigned char)(bmax_g[i]&255);
      }
    }
    data[pos++] = (unsigned char)(mod>>8);
    data[pos++] = (unsigned char)(mod&255);
    data[pos++] = (unsigned char)(class>>8);
    data[pos++] = (unsigned char)(class&255);
    data[pos++] = (unsigned char)(topdown ? (level2>>8) : (level>>8));
    data[pos++] = (unsigned char)(topdown ? (level2&255) : (level&255));
    data[pos++] = (unsigned char)(count>>8);
    data[pos++] = (unsigned char)(count&255);
    data[pos++] = (unsigned char)(mod2>>8);
    data[pos++] = (unsigned char)(mod2&255);
    data[pos++] = (unsigned char)(class2>>8);
    data[pos++] = (unsigned char)(class2&255);
    data[pos++] = (unsigned char)(count2>>8);
    data[pos++] = (unsigned char)(count2&255);
    if (mod3_used) {
      data[pos++] = (unsigned char)(mod3>>8);
      data[pos++] = (unsigned char)(mod3&255);
      data[pos++] = (unsigned char)(class3>>8);
      data[pos++] = (unsigned char)(class3&255);
      data[pos++] = (unsigned char)(count3>>8);
      data[pos++] = (unsigned char)(count3&255);
      data[pos++] = (unsigned char)(level3>>8);
      data[pos++] = (unsigned char)(level3&255);
      data[pos++] = (unsigned char)(mod3_used | (class3_used<<1) |
                                     (level3_used<<2));
    }
    if (mod4_used) {
      data[pos++] = (unsigned char)(mod4>>8);
      data[pos++] = (unsigned char)(mod4&255);
      data[pos++] = (unsigned char)(class4>>8);
      data[pos++] = (unsigned char)(class4&255);
      data[pos++] = (unsigned char)(count4>>8);
      data[pos++] = (unsigned char)(count4&255);
      data[pos++] = (unsigned char)(level4>>8);
      data[pos++] = (unsigned char)(level4&255);
      data[pos++] = (unsigned char)(mod4_used | (class4_used<<1) |
                                     (level4_used<<2));
    }
    if (mod5_used) {
      data[pos++] = (unsigned char)(mod5>>8);
      data[pos++] = (unsigned char)(mod5&255);
      data[pos++] = (unsigned char)(class5>>8);
      data[pos++] = (unsigned char)(class5&255);
      data[pos++] = (unsigned char)(count5>>8);
      data[pos++] = (unsigned char)(count5&255);
      data[pos++] = (unsigned char)(level5>>8);
      data[pos++] = (unsigned char)(level5&255);
      data[pos++] = (unsigned char)(mod5_used | (class5_used<<1) |
                                     (level5_used<<2));
    }
    if (mod6_used) {
      data[pos++] = (unsigned char)(mod6>>8);
      data[pos++] = (unsigned char)(mod6&255);
      data[pos++] = (unsigned char)(class6>>8);
      data[pos++] = (unsigned char)(class6&255);
      data[pos++] = (unsigned char)(count6>>8);
      data[pos++] = (unsigned char)(count6&255);
      data[pos++] = (unsigned char)(level6>>8);
      data[pos++] = (unsigned char)(level6&255);
      data[pos++] = (unsigned char)(mod6_used | (class6_used<<1) |
                                     (level6_used<<2));
    }
    //    if (sizeof(int)<=4) {
#if (INT_MAX == 2147483647)
      data[pos++] = 0;  data[pos++] = 0;  
      data[pos++] = 0;  data[pos++] = 0;
      //}
#else // 64 bit
      //else {
      data[pos++] = (unsigned char)(hislen>>56);  
      data[pos++] = (unsigned char)((hislen>>48)&255);
      data[pos++] = (unsigned char)((hislen>>40)&255);
      data[pos++] = (unsigned char)((hislen>>32)&255);
      //}
#endif
    data[pos++] = (unsigned char)((hislen>>24)&255);
    data[pos++] = (unsigned char)((hislen>>16)&255);
    data[pos++] = (unsigned char)((hislen>>8)&255);
    data[pos++] = (unsigned char)(hislen&255);
    for (j=0; j<(size_t)hislen; j++) {   /* zweig[0] ist bei topdown immer 0 */
      //      if (sizeof(unsigned long)==4) {
#if (ULONG_MAX == 4294967295UL)
        data[pos++] = 0;  data[pos++] = 0;  
        data[pos++] = 0;  data[pos++] = 0;
	//}
#else // 64 bit
	//else {
        data[pos++] = (unsigned char)(zweig[j]>>56);  
        data[pos++] = (unsigned char)((zweig[j]>>48)&255);
        data[pos++] = (unsigned char)((zweig[j]>>40)&255);
        data[pos++] = (unsigned char)((zweig[j]>>32)&255);
	//}
#endif
      data[pos++] = (unsigned char)((zweig[j]>>24)&255);
      data[pos++] = (unsigned char)((zweig[j]>>16)&255);
      data[pos++] = (unsigned char)((zweig[j]>>8)&255);
      data[pos++] = (unsigned char)(zweig[j]&255);
    }
    //    if (sizeof(unsigned long)==4) {
#if (ULONG_MAX == 4294967295UL)
      data[pos++] = 0;  data[pos++] = 0;  
      data[pos++] = 0;  data[pos++] = 0;
      // }
#else // 64 bit
      //else {
      data[pos++] = (unsigned char)(nebenzweig[0]>>56);  
      data[pos++] = (unsigned char)((nebenzweig[0]>>48)&255);
      data[pos++] = (unsigned char)((nebenzweig[0]>>40)&255);
      data[pos++] = (unsigned char)((nebenzweig[0]>>32)&255);
      //}
#endif
    data[pos++] = (unsigned char)((nebenzweig[0]>>24)&255);
    data[pos++] = (unsigned char)((nebenzweig[0]>>16)&255);
    data[pos++] = (unsigned char)((nebenzweig[0]>>8)&255);
    data[pos++] = (unsigned char)(nebenzweig[0]&255);
    /* "nebenzweig[1]" und "nebenzweig[2]" sind nur wichtig bei "topdown" */
    //    if (sizeof(unsigned long)==4) {
#if (ULONG_MAX == 4294967295UL)
      data[pos++] = 0;  data[pos++] = 0;  
      data[pos++] = 0;  data[pos++] = 0;
      //}
#else // 64 bit
      //else {
      data[pos++] = (unsigned char)(nebenzweig[1]>>56);  
      data[pos++] = (unsigned char)((nebenzweig[1]>>48)&255);
      data[pos++] = (unsigned char)((nebenzweig[1]>>40)&255);
      data[pos++] = (unsigned char)((nebenzweig[1]>>32)&255);
      //}
#endif
    data[pos++] = (unsigned char)((nebenzweig[1]>>24)&255);
    data[pos++] = (unsigned char)((nebenzweig[1]>>16)&255);
    data[pos++] = (unsigned char)((nebenzweig[1]>>8)&255);
    data[pos++] = (unsigned char)(nebenzweig[1]&255);
    //    if (sizeof(unsigned long)==4) {
#if (ULONG_MAX == 4294967295UL)
      data[pos++] = 0;  data[pos++] = 0;  
      data[pos++] = 0;  data[pos++] = 0;
      //}
#else // 64 bit
      //else {
      data[pos++] = (unsigned char)(nebenzweig[2]>>56);  
      data[pos++] = (unsigned char)((nebenzweig[2]>>48)&255);
      data[pos++] = (unsigned char)((nebenzweig[2]>>40)&255);
      data[pos++] = (unsigned char)((nebenzweig[2]>>32)&255);
      //}
#endif
    data[pos++] = (unsigned char)((nebenzweig[2]>>24)&255);
    data[pos++] = (unsigned char)((nebenzweig[2]>>16)&255);
    data[pos++] = (unsigned char)((nebenzweig[2]>>8)&255);
    data[pos++] = (unsigned char)(nebenzweig[2]&255);
    data[pos++] = pfadtyp;
    data[pos++] = mgl;
    data[pos++] = submgl;                    /* unwichtig bei "topdown" */
    data[pos++] = (unsigned char)(l1>>8);
    data[pos++] = (unsigned char)(l1&255);
    data[pos++] = (unsigned char)(l2>>8);
    data[pos++] = (unsigned char)(l2&255);
    data[pos++] = (unsigned char)(l3>>8);
    data[pos++] = (unsigned char)(l3&255);
    data[pos++] = (unsigned char)(fl1>>8);
    data[pos++] = (unsigned char)(fl1&255);
    data[pos++] = (unsigned char)(fl2>>8);
    data[pos++] = (unsigned char)(fl2&255);
    data[pos++] = (unsigned char)(n>>8);
    data[pos++] = (unsigned char)(n&255);
    data[pos++] = (unsigned char)(g1>>8);
    data[pos++] = (unsigned char)(g1&255);
    data[pos++] = (unsigned char)(g2>>8);
    data[pos++] = (unsigned char)(g2&255);
    data[pos++] = (unsigned char)(g>>8);
    data[pos++] = (unsigned char)(g&255);
    data[pos++] = (unsigned char)(krit1>>8);
    data[pos++] = (unsigned char)(krit1&255);
    data[pos++] = (unsigned char)(krit2>>8);
    data[pos++] = (unsigned char)(krit2&255);
    data[pos++] = (unsigned char)(krit3>>8);
    data[pos++] = (unsigned char)(krit3&255);
    data[pos++] = (unsigned char)(gefunden1 + (gefunden2<<1) + (gefunden3<<2));
#ifndef NOTIMES
    dummy_ct = times(&TMS);
    medtime = TMS.tms_utime + prevtime;
    data[pos++] = (unsigned char)(medtime>>24);              /* Zeit */
    data[pos++] = (unsigned char)((medtime>>16)&255);
    data[pos++] = (unsigned char)((medtime>>8)&255);
    data[pos++] = (unsigned char)(medtime&255);
#endif //NOTIMES
  }

  /* dump-File oeffnen: */
  dummy = rename(recoversavefilename,recoverfilename_sk);
  if ((recoverfile = repeated_fopen(recoversavefilename,"wb",1))==nil) {
    sprintf(strpuf,"Could not open dump file %s!\n"
                   "Process continues without saving...\n",
                   recoversavefilename);
    logfile_entry(strpuf,True,True,True);
    perror((char *)"Error description");
  }   
  else {
    if ((written = fwrite(data,sizeof(unsigned char),pos,recoverfile)) < pos) 
        {schreibfehler(recoversavefilename,pos,written,True);}
    if (!finished && facestat)     /* Facestatbaum auslesen */
       {schreibe_facestatbaum_in_dumpfile(facestatbaum,faces,0,recoverfile);}
    fclose(recoverfile);
  }
  save_flag = 0;  save_flag2 = False;                  /* alles geschrieben */
}

/********************DUMP_ERROR**********************************************/

void dump_error(char *s) {
  sprintf(strpuf,"Error reading dump file: %s is not correct\n"
          "(dump file might have been renamed)!\n",s);
  logfile_entry(strpuf,True,True,True);
  exit(18);
}  
       
/********************ZWEIG_ERROR*********************************************/

void zweig_error(POSTYP i) {
  if (save) {   /* sonst egal */
    sprintf(strpuf,"Error:  Branching in level %d exceeds ULONG_MAX!\n",i);
    logfile_entry(strpuf,True,True,True);
    exit(173);
  }
}  
       
/**************LIES_DUMPFILE*************************************************/
/*  Liest zu Programmbeginn die erforderlichen Daten fuer einen Restart ein.
    Alle uebrigen Daten sind bereits unabhaengig vom Dumpfile wiederher-
    gestellt worden. */

void lies_dumpfile(void) {
  static FILE *recoverfile;                 /* dump-File */
  static unsigned char data[56];    /* Platz fuer 56 gelesene Eintraege */
  static size_t gelesen;
  static POSTYP hislen;
  static KNOTENTYP i;
  static FLAECHENTYP f,faces[MAXFTYPEN];
  static size_t pos,j,jj,written;
  static int dummy;
  static FILE *fbsy;

  if (fbsy = fopen(recoverreadflagfilename,"rb")) {
    logfile_entry((char *)"Warning:  Found file ",True,False,True);
    logfile_entry(recoverreadflagfilename,False,False,True);
    logfile_entry((char *)".\nLoading backup dump file ",False,False,
                  True);
    logfile_entry(recoverreadfilename_sk,False,False,True);
    logfile_entry((char *)"...\n",False,True,True);
    if ((recoverfile = repeated_fopen(recoverreadfilename_sk,"rb",1))==nil) {
      logfile_entry((char *)"Could not find backup dump file.\nI quit. If you"
              " want to restart the process without recovering, use option "
              "'-no_recover'.\n",True,True,True);
      exit(176);
    }
    else {logfile_entry((char *)"Okay.\n",True,True,True);}
  }
  else if ((recoverfile = repeated_fopen(recoverreadfilename,"rb",1))==nil) {
    sprintf(strpuf,"Could not find dump file %s.\nI will proceed without.\n",
            recoverreadfilename);
    logfile_entry(strpuf,True,True,True);
    recover = False;  return;
  }
  else {
    sprintf(strpuf,"Recovering from dump file %s...\n",recoverreadfilename);
    logfile_entry(strpuf,True,True,True);
  }

  if ((gelesen = fread(data,sizeof(unsigned char),1L,recoverfile))<1L)
     {lesefehler(recoverreadfilename,1L,gelesen,False);}
  if (data[0]==1) {                 /* finished-Flag ist gesetzt */
    logfile_entry((char *)"Process has already finished!\n",True,True,True);
    fclose(recoverfile);
    exit(19);
  }

  /* alles ok: einlesen */
  if ((gelesen = fread(data,sizeof(unsigned char),25L,recoverfile))<25L)
     {lesefehler(recoverreadfilename,25L,gelesen,False);}
  if (data[0] != (unsigned char)
                 (v_used + (output_used<<1) + (outputmem_used<<2) +
                 (types_used<<3) + (facecon_used<<4) + (logfile_used<<5) +
                 (g_used<<6) + (gs_used<<7))) 
                 {dump_error((char *)"First entry");};
  if (data[1] != (unsigned char)
                 (mapstat_used + (mapcon_used<<1) + (vs_used<<2) +
                 (f_used<<3) + (fileindex_used<<4) + (facestat_used<<5) +
                 (pv_used<<6) + (digon_path_used<<7)))
                 {dump_error((char *)"Second entry");}
  if (data[2] != (unsigned char)
                 (delaney_used + (logfilename_used<<1) + (topdown_used<<2) +
                 (patchstat_used<<3) + (patchcheck_used<<4) + (pid_used<<5) +
                 (priority_used<<6) + (patchcon_used<<7)))
                 {dump_error((char *)"Third entry");}
  if ((data[3]&127) != (unsigned char)
                 (alt_used + (dual_used<<1) + (db_used<<2) + 
                 (td_limits_used<<3) + (memory_used<<4) + (mod_used<<5) +
                 (class_used<<6)))
                 {dump_error((char *)"Fourth entry");}
  if (!topdown || (mod2_used && (!alias || old_mod2))) {
    if ((data[3]&128) != ((level_used|level2_used)<<7)) 
       {dump_error((char *)"Fourth entry (bit 7)");}
  }
  if (data[4] != (unsigned char)(n_anf_usr>>8)) 
                 {dump_error((char *)"'-vs'");}
  if (data[5] != (unsigned char)(n_anf_usr&255)) 
                 {dump_error((char *)"'-vs'");}
  if (data[6] != (unsigned char)(n_end_usr>>8)) 
                 {dump_error((char *)"'-v'");}
  if (data[7] != (unsigned char)(n_end_usr&255)) 
                 {dump_error((char *)"'-v'");}
  if (data[8] != (unsigned char)(genus_anf_usr>>8)) 
                 {dump_error((char *)"'-gs'");}
  if (data[9] != (unsigned char)(genus_anf_usr&255)) 
                 {dump_error((char *)"'-gs'");}
  if (data[10] != (unsigned char)(genus_end_usr>>8)) 
                 {dump_error((char *)"'-g'");}
  if (data[11] != (unsigned char)(genus_end_usr&255)) 
                 {dump_error((char *)"'-g'");}
  if (data[12] != (unsigned char)(anz_face>>8)) 
                 {dump_error((char *)"Number of allowed face degrees");}
  if (data[13] != (unsigned char)(anz_face&255)) 
                 {dump_error((char *)"Number of allowed face degrees");}
  if ((data[14]&247) != (unsigned char)
                  (facestat + (facerestrict<<1) + (facenumbers<<2) +
                  (output<<4) + (do_bauchbinde<<5) +
                  (do_sandwich<<6) + (do_brille<<7)))
                  {dump_error((char *)"15th entry");}
  if ((data[14]&8) != (unsigned char)((mod2_used && (!alias || old_mod2))<<3))
                  {dump_error((char *)"15th entry (bit 3)");}
  if (data[15] != (unsigned char)
                  (alternative + (dual<<1) + (conn1<<2) + 
                  (conn2<<3) + (conn3<<4) + (do_conn<<5) +
                  (patchconn<<6) + (graphstat<<7)))
                  {dump_error((char *)"16th entry");}
  if (data[16] != pv) {dump_error((char *)"'pv'");}
  if (data[17] != (unsigned char)(bauchbindenkennung>>8))
                  {dump_error((char *)"'priority'");}
  if (data[18] != (unsigned char)(bauchbindenkennung&255))
                  {dump_error((char *)"'priority'");}
  if (data[19] != (unsigned char)(sandwichkennung>>8))
                  {dump_error((char *)"'priority'");}
  if (data[20] != (unsigned char)(sandwichkennung&255))
                  {dump_error((char *)"'priority'");}
  if (data[21] != (unsigned char)(brillenkennung>>8))
                  {dump_error((char *)"'priority'");}
  if (data[22] != (unsigned char)(brillenkennung&255))
                  {dump_error((char *)"'priority'");}
  if (data[23] != (unsigned char)
                  (facecon1 + (facecon2<<1) + (doppelkanten<<2) + 
                  (delaney<<3) + (patchcheck<<4) + (pco<<5) +
                  (logfile_out<<6) + (stderr_out<<7)))
                  {dump_error((char *)"24th entry");}
  if ((data[24]&47) != (unsigned char)
                  (td_limits + (td_limits_auto<<1) + (digon_path<<2) +
		  (topdown<<3) + (mdeza1_used<<5)))
                  {dump_error((char *)"25th entry");}
  if ((data[24]&16) != (unsigned char)((class2_used && 
                  (!alias || old_mod2))<<4))
                  {dump_error((char *)"25th entry (bit 4)");}


  for (f=0; f<anz_face; f++) {
    if ((gelesen = fread(data,sizeof(unsigned char),6L,recoverfile))<6L)
       {lesefehler(recoverreadfilename,6L,gelesen,False);}
    if (data[0] != (unsigned char)(face[f]>>8)) 
                   {dump_error((char *)"Face degree");}
    if (data[1] != (unsigned char)(face[f]&255)) 
                   {dump_error((char *)"Face degree");}
    if (data[2] != (unsigned char)(facenum_min_usr[f]>>8)) 
                   {dump_error((char *)"Face limit");}
    if (data[3] != (unsigned char)(facenum_min_usr[f]&255)) 
                   {dump_error((char *)"Face limit");}
    if (data[4] != (unsigned char)(facenum_max_usr[f]>>8)) 
                   {dump_error((char *)"Face limit");}
    if (data[5] != (unsigned char)(facenum_max_usr[f]&255)) 
                   {dump_error((char *)"Face limit");}
  }    

  jj = ARRAYPOS_LN((size_t)genus_end_usr,(size_t)n_end_usr,4);
  for (j=0; j<jj; j++) {
    if ((gelesen = fread(data,sizeof(unsigned char),24L,recoverfile))<24L)
       {lesefehler(recoverreadfilename,24L,gelesen,False);}
    if (comp4) {    /* obere 4 Bytes ignorieren */
      graphenzahl[j] = (unsigned long)(data[4])<<24 |
                       (unsigned long)(data[5])<<16 |
                       (unsigned long)(data[6])<<8  |
                       (unsigned long)(data[7]);
    }
    else {
      //if (sizeof(unsigned long)==4) { 
#if (ULONG_MAX == 4294967295UL)  
        /* pruefen, ob zu grosse Zahl eingelesen wird (z.B. von alpha) */
        if (data[0] || data[1] || data[2] || data[3]) 
	   {logfile_entry((char *)"Error while reading dump file: Number too "
            "large (too small architecture?)\n",True,True,True); exit(160);}
        graphenzahl[j] = (unsigned long)(data[4])<<24 |
                         (unsigned long)(data[5])<<16 |
                         (unsigned long)(data[6])<<8  |
                         (unsigned long)(data[7]);
	//}
#else // 64 bit
	//else {       /* alle 8 Bytes werden ernst genommen */
        graphenzahl[j] =  (unsigned long)(data[0])<<56 |
                          (unsigned long)(data[1])<<48 |
                          (unsigned long)(data[2])<<40 |
                          (unsigned long)(data[3])<<32 |
                          (unsigned long)(data[4])<<24 |
                          (unsigned long)(data[5])<<16 |
                          (unsigned long)(data[6])<<8  |
                          (unsigned long)(data[7]);
	// }
#endif
    }
    if (comp4) {    /* obere 4 Bytes ignorieren */
      non_iso_graphenzahl[j] = (unsigned long)(data[12])<<24 |
                               (unsigned long)(data[13])<<16 |
                               (unsigned long)(data[14])<<8  |
                               (unsigned long)(data[15]);
    }
    else {
      //if (sizeof(unsigned long)==4) {   
#if (ULONG_MAX == 4294967295UL)
        /* pruefen, ob zu grosse Zahl eingelesen wird (z.B. von alpha) */
        if (data[8] || data[9] || data[10] || data[11]) 
	   {logfile_entry((char *)"Error while reading dump file: Number too "
            "large (too small architecture?)\n",True,True,True); exit(161);}
        non_iso_graphenzahl[j] = (unsigned long)(data[12])<<24 |
                                 (unsigned long)(data[13])<<16 |
                                 (unsigned long)(data[14])<<8  |
                                 (unsigned long)(data[15]);
	//}
#else // 64 bit
	//else {       /* alle 8 Bytes werden ernst genommen */
        non_iso_graphenzahl[j] =  (unsigned long)(data[8])<<56 |
                                  (unsigned long)(data[9])<<48 |
                                  (unsigned long)(data[10])<<40 |
                                  (unsigned long)(data[11])<<32 |
                                  (unsigned long)(data[12])<<24 |
                                  (unsigned long)(data[13])<<16 |
                                  (unsigned long)(data[14])<<8  |
                                  (unsigned long)(data[15]);
	//}
#endif
    }
    if (comp4) {    /* obere 4 Bytes ignorieren */
      connzahl[j] = (unsigned long)(data[20])<<24 |
                    (unsigned long)(data[21])<<16 |
                    (unsigned long)(data[22])<<8  |
                    (unsigned long)(data[23]);
    }
    else {
      //      if (sizeof(unsigned long)==4) {   
#if (ULONG_MAX == 4294967295UL)
        /* pruefen, ob zu grosse Zahl eingelesen wird (z.B. von alpha) */
        if (data[16] || data[17] || data[18] || data[19]) 
	   {logfile_entry((char *)"Error while reading dump file: Number too "
            "large (too small architecture?)\n",True,True,True); exit(162);}
        connzahl[j] = (unsigned long)(data[20])<<24 |
                      (unsigned long)(data[21])<<16 |
                      (unsigned long)(data[22])<<8  |
                      (unsigned long)(data[23]);
	//}
#else // 64 bit
	//else {       /* alle 8 Bytes werden ernst genommen */
        connzahl[j] =  (unsigned long)(data[16])<<56 |
                       (unsigned long)(data[17])<<48 |
                       (unsigned long)(data[18])<<40 |
                       (unsigned long)(data[19])<<32 |
                       (unsigned long)(data[20])<<24 |
                       (unsigned long)(data[21])<<16 |
                       (unsigned long)(data[22])<<8  |
                       (unsigned long)(data[23]);
	// }
#endif
    }
  }

  if (delaney) {
    for (f=1; f<=big_face; f++) {
      if ((gelesen = fread(data,sizeof(unsigned char),1L,recoverfile))<1L)
         {lesefehler(recoverreadfilename,1L,gelesen,False);}
      if (data[0] != dela_set[f]) {dump_error((char *)"Delaney set");}
    } 
  }

  if ((gelesen = fread(data,sizeof(unsigned char),24L,recoverfile))<24L)  
     {lesefehler(recoverreadfilename,24L,gelesen,False);}
  if (comp4) {    /* obere 4 Bytes ignorieren */
    if (basis != ((unsigned long)(data[4])<<24 |
                  (unsigned long)(data[5])<<16 |
                  (unsigned long)(data[6])<<8  |
                  (unsigned long)(data[7])))
                  {dump_error((char *)"'outputmem'");}
  }
  else {
    //if (sizeof(unsigned long)==4) {   
#if (ULONG_MAX == 4294967295UL)
      /* pruefen, ob zu grosse Zahl eingelesen wird (z.B. von alpha) */
      if (data[0] || data[1] || data[2] || data[3]) 
         {logfile_entry((char *)"Error while reading dump file: Number too "
          "large (too small architecture?)\n",True,True,True); exit(163);}
      if (basis != ((unsigned long)(data[4])<<24 |
                    (unsigned long)(data[5])<<16 |
                    (unsigned long)(data[6])<<8  |
                    (unsigned long)(data[7])))
                    {dump_error((char *)"'outputmem'");}
      //}
#else // 64 bit
      //else {       /* alle 8 Bytes werden ernst genommen */
      if (basis != ((unsigned long)(data[0])<<56 |
                    (unsigned long)(data[1])<<48 |
                    (unsigned long)(data[2])<<40 |
                    (unsigned long)(data[3])<<32 |
                    (unsigned long)(data[4])<<24 |
                    (unsigned long)(data[5])<<16 |
                    (unsigned long)(data[6])<<8  |
                    (unsigned long)(data[7]))) 
                    {dump_error((char *)"'outputmem'");}
      //}
#endif
  }
  if (comp4) {    /* obere 4 Bytes ignorieren */
    if (zusatz != ((unsigned long)(data[12])<<24 |
                   (unsigned long)(data[13])<<16 |
                   (unsigned long)(data[14])<<8  |
                   (unsigned long)(data[15])))
                   {dump_error((char *)"'outputmem'");}
  }
  else {
    //    if (sizeof(unsigned long)==4) { 
#if (ULONG_MAX == 4294967295UL)  
      /* pruefen, ob zu grosse Zahl eingelesen wird (z.B. von alpha) */
      if (data[8] || data[9] || data[10] || data[11]) 
         {logfile_entry((char *)"Error while reading dump file: Number too "
          "large (too small architecture?)\n",True,True,True); exit(164);}
      if (zusatz != ((unsigned long)(data[12])<<24 |
                     (unsigned long)(data[13])<<16 |
                     (unsigned long)(data[14])<<8  |
                     (unsigned long)(data[15])))
                     {dump_error((char *)"'outputmem'");}
      //}
#else // 64 bit
      //else {       /* alle 8 Bytes werden ernst genommen */
      if (zusatz != ((unsigned long)(data[8])<<56 |
                     (unsigned long)(data[9])<<48 |
                     (unsigned long)(data[10])<<40 |
                     (unsigned long)(data[11])<<32 |
                     (unsigned long)(data[12])<<24 |
                     (unsigned long)(data[13])<<16 |
                     (unsigned long)(data[14])<<8  |
                     (unsigned long)(data[15]))) 
                     {dump_error((char *)"'outputmem'");}
      //}
#endif
  }
  if (comp4) {    /* obere 4 Bytes ignorieren */
    if (mem_max != ((unsigned long)(data[20])<<24 |
                    (unsigned long)(data[21])<<16 |
                    (unsigned long)(data[22])<<8  |
                    (unsigned long)(data[23])))
                    {dump_error((char *)"'memory'");}
  }
  else {
    //    if (sizeof(unsigned long)==4) {
#if (ULONG_MAX == 4294967295UL)   
      /* pruefen, ob zu grosse Zahl eingelesen wird (z.B. von alpha) */
      if (data[16] || data[17] || data[18] || data[19]) 
         {logfile_entry((char *)"Error while reading dump file: Number too "
          "large (too small architecture?)\n",True,True,True); exit(165);}
      if (mem_max != ((unsigned long)(data[20])<<24 |
                      (unsigned long)(data[21])<<16 |
                      (unsigned long)(data[22])<<8  |
                      (unsigned long)(data[23])))
                      {dump_error((char *)"'memory'");}
      //}
#else // 64 bit
      //else {       /* alle 8 Bytes werden ernst genommen */
      if (mem_max != ((unsigned long)(data[16])<<56 |
                      (unsigned long)(data[17])<<48 |
                      (unsigned long)(data[18])<<40 |
                      (unsigned long)(data[19])<<32 |
                      (unsigned long)(data[20])<<24 |
                      (unsigned long)(data[21])<<16 |
                      (unsigned long)(data[22])<<8  |
                      (unsigned long)(data[23]))) 
                      {dump_error((char *)"'memory'");}
      //}
#endif
  }

  if (topdown) {
    for (i=0; i<=genus_end_usr; i++) {
      if ((gelesen = fread(data,sizeof(unsigned char),12L,recoverfile))<12L)
         {lesefehler(recoverreadfilename,12L,gelesen,False);}
      if (data[0] != (unsigned char)(cmax_g_usr[i]>>8))
         {dump_error((char *)"Top-down limit");}
      if (data[1] != (unsigned char)(cmax_g_usr[i]&255))
         {dump_error((char *)"Top-down limit");}
      if (data[2] != (unsigned char)(fmax_g_usr[i]>>8))
         {dump_error((char *)"Top-down limit");}
      if (data[3] != (unsigned char)(fmax_g_usr[i]&255))
         {dump_error((char *)"Top-down limit");}
      if (data[4] != (unsigned char)(bmax_g_usr[i]>>8))
         {dump_error((char *)"Top-down limit");}
      if (data[5] != (unsigned char)(bmax_g_usr[i]&255))
         {dump_error((char *)"Top-down limit");}
      cmax_g_rec[i] = (KNOTENTYP)(data[6])<<8  |
                      (KNOTENTYP)(data[7]);
      fmax_g_rec[i] = (KNOTENTYP)(data[8])<<8  |
                      (KNOTENTYP)(data[9]);
      bmax_g_rec[i] = (KNOTENTYP)(data[10])<<8  |
                      (KNOTENTYP)(data[11]);
    }
  }

  if ((gelesen = fread(data,sizeof(unsigned char),14L,recoverfile))<14L)
     {lesefehler(recoverreadfilename,14L,gelesen,False);}
  if (data[0] != (unsigned char)(mod>>8)) {dump_error((char *)"'mod'");} 
  if (data[1] != (unsigned char)(mod&255)) {dump_error((char *)"'mod'");}
  if (data[2] != (unsigned char)(class>>8)) {dump_error((char *)"'class'");}
  if (data[3] != (unsigned char)(class&255)) {dump_error((char *)"'class'");}
  if (topdown) {
    if (mod2_used && (!alias || old_mod2)) {
      if (data[4] != (unsigned char)(level2>>8)) 
         {dump_error((char *)"'level2'");}
      if (data[5] != (unsigned char)(level2&255)) 
         {dump_error((char *)"'level2'");}
    }
  }
  else {
    if (data[4] != (unsigned char)(level>>8)) {dump_error((char *)"'level'");}
    if (data[5] != (unsigned char)(level&255)) {dump_error((char *)"'level'");}
  }
  recovercount = (unsigned short)(data[6])<<8  |  (unsigned short)(data[7]);
  if (mod2_used) {
    if (!alias || old_mod2) {
      if (alias) {    /* mit 'old'-Werten vergleichen */
        if (data[8] != (unsigned char)(old_mod2>>8)) 
                       {dump_error((char *)"'old_mod2'");}
        if (data[9] != (unsigned char)(old_mod2&255)) 
                       {dump_error((char *)"'old_mod2'");}
        if (data[10] != (unsigned char)(old_class2>>8)) 
                        {dump_error((char *)"'old_class2'");}
        if (data[11] != (unsigned char)(old_class2&255)) 
                        {dump_error((char *)"'old_class2'");}
      }
      else {          /* mit Original-Werten vergleichen */
        if (data[8] != (unsigned char)(mod2>>8)) 
                       {dump_error((char *)"'mod2'");}
        if (data[9] != (unsigned char)(mod2&255)) 
                       {dump_error((char *)"'mod2'");}
        if (data[10] != (unsigned char)(class2>>8)) 
                        {dump_error((char *)"'class2'");}
        if (data[11] != (unsigned char)(class2&255)) 
                        {dump_error((char *)"'class2'");}
      }
      recovercount2 = (unsigned short)(data[12])<<8  |  
                      (unsigned short)(data[13]);
    }
    else {recovercount2 = 0;}
  }
  else {recovercount2 = 0;}
  /* der Unterschied zwischen der mod2-Abfrage und den anderen Abfragen ist
     der, dass die mod2-begleitenden Werte immer gespeichert werden, auch
     wenn "mod2" gar nicht benutzt wird. Ausserdem sind die restlichen Werte 
     leider etwas verstreut. */
  if (mod3_used) {
    if (!alias2 || old_mod3) {   /* Daten fuer Split 3 lesen */ 
      if ((gelesen = fread(data,sizeof(unsigned char),9L,recoverfile))<9L)
         {lesefehler(recoverreadfilename,9L,gelesen,False);}
      if (alias2) {    /* mit 'old'-Werten vergleichen */
        if (data[0] != (unsigned char)(old_mod3>>8)) 
                       {dump_error((char *)"'old_mod3'");}
        if (data[1] != (unsigned char)(old_mod3&255)) 
                       {dump_error((char *)"'old_mod3'");}
        if (data[2] != (unsigned char)(old_class3>>8)) 
                       {dump_error((char *)"'old_class3'");}
        if (data[3] != (unsigned char)(old_class3&255)) 
                       {dump_error((char *)"'old_class3'");}
      }
      else {          /* mit Original-Werten vergleichen */
        if (data[0] != (unsigned char)(mod3>>8)) 
                       {dump_error((char *)"'mod3'");}
        if (data[1] != (unsigned char)(mod3&255)) 
                       {dump_error((char *)"'mod3'");}
        if (data[2] != (unsigned char)(class3>>8)) 
                       {dump_error((char *)"'class3'");}
        if (data[3] != (unsigned char)(class3&255)) 
                       {dump_error((char *)"'class3'");}
      }
      recovercount3 = (unsigned short)(data[4])<<8  |  
                      (unsigned short)(data[5]);      
      if (data[6] != (unsigned char)(level3>>8)) 
                     {dump_error((char *)"'level3'");}
      if (data[7] != (unsigned char)(level3&255)) 
                     {dump_error((char *)"'level3'");}
      if (data[8] != (unsigned char)(mod3_used + (class3_used<<1) +
                                     (level3_used<<2)))
	             {dump_error((char *)"'level3_used'");}
    }
    else {recovercount3 = 0;}   /* wichtig */
  }
  else {recovercount3 = 0;}  /* wichtig, da nach dem Recovern 
                     "count3=recovercount3" gesetzt wird, wenn "alias=True" */
  if (mod4_used) {
    if (!alias3 || old_mod4) {   /* Daten fuer Split 4 lesen */ 
      if ((gelesen = fread(data,sizeof(unsigned char),9L,recoverfile))<9L)
         {lesefehler(recoverreadfilename,9L,gelesen,False);}
      if (alias3) {    /* mit 'old'-Werten vergleichen */
        if (data[0] != (unsigned char)(old_mod4>>8)) 
                       {dump_error((char *)"'old_mod4'");}
        if (data[1] != (unsigned char)(old_mod4&255)) 
                       {dump_error((char *)"'old_mod4'");}
        if (data[2] != (unsigned char)(old_class4>>8)) 
                       {dump_error((char *)"'old_class4'");}
        if (data[3] != (unsigned char)(old_class4&255)) 
                       {dump_error((char *)"'old_class4'");}
      }
      else {          /* mit Original-Werten vergleichen */
        if (data[0] != (unsigned char)(mod4>>8)) 
                       {dump_error((char *)"'mod4'");}
        if (data[1] != (unsigned char)(mod4&255)) 
                       {dump_error((char *)"'mod4'");}
        if (data[2] != (unsigned char)(class4>>8)) 
                       {dump_error((char *)"'class4'");}
        if (data[3] != (unsigned char)(class4&255)) 
                       {dump_error((char *)"'class4'");}
      }
      recovercount4 = (unsigned short)(data[4])<<8  |  
                      (unsigned short)(data[5]);      
      if (data[6] != (unsigned char)(level4>>8)) 
                     {dump_error((char *)"'level4'");}
      if (data[7] != (unsigned char)(level4&255)) 
                     {dump_error((char *)"'level4'");}
      if (data[8] != (unsigned char)(mod4_used + (class4_used<<1) +
                                     (level4_used<<2)))
	             {dump_error((char *)"'level4_used'");}
    }
    else {recovercount4 = 0;}   /* wichtig */
  }
  else {recovercount4 = 0;}  /* wichtig, da nach dem Recovern 
                     "count4=recovercount4" gesetzt wird, wenn "alias=True" */
  if (mod5_used) {
    if (!alias4 || old_mod5) {   /* Daten fuer Split 5 lesen */ 
      if ((gelesen = fread(data,sizeof(unsigned char),9L,recoverfile))<9L)
         {lesefehler(recoverreadfilename,9L,gelesen,False);}
      if (alias4) {    /* mit 'old'-Werten vergleichen */
        if (data[0] != (unsigned char)(old_mod5>>8)) 
                       {dump_error((char *)"'old_mod5'");}
        if (data[1] != (unsigned char)(old_mod5&255)) 
                       {dump_error((char *)"'old_mod5'");}
        if (data[2] != (unsigned char)(old_class5>>8)) 
                       {dump_error((char *)"'old_class5'");}
        if (data[3] != (unsigned char)(old_class5&255)) 
                       {dump_error((char *)"'old_class5'");}
      }
      else {          /* mit Original-Werten vergleichen */
        if (data[0] != (unsigned char)(mod5>>8)) 
                       {dump_error((char *)"'mod5'");}
        if (data[1] != (unsigned char)(mod5&255)) 
                       {dump_error((char *)"'mod5'");}
        if (data[2] != (unsigned char)(class5>>8)) 
                       {dump_error((char *)"'class5'");}
        if (data[3] != (unsigned char)(class5&255)) 
                       {dump_error((char *)"'class5'");}
      }
      recovercount5 = (unsigned short)(data[4])<<8  |  
                      (unsigned short)(data[5]);      
      if (data[6] != (unsigned char)(level5>>8)) 
                     {dump_error((char *)"'level5'");}
      if (data[7] != (unsigned char)(level5&255)) 
                     {dump_error((char *)"'level5'");}
      if (data[8] != (unsigned char)(mod5_used + (class5_used<<1) +
                                     (level5_used<<2)))
	             {dump_error((char *)"'level5_used'");}
    }
    else {recovercount5 = 0;}   /* wichtig */
  }
  else {recovercount5 = 0;}  /* wichtig, da nach dem Recovern 
                     "count5=recovercount5" gesetzt wird, wenn "alias=True" */
  if (mod6_used) {
    if (!alias5 || old_mod6) {   /* Daten fuer Split 6 lesen */ 
      if ((gelesen = fread(data,sizeof(unsigned char),9L,recoverfile))<9L)
         {lesefehler(recoverreadfilename,9L,gelesen,False);}
      if (alias5) {    /* mit 'old'-Werten vergleichen */
        if (data[0] != (unsigned char)(old_mod6>>8)) 
                       {dump_error((char *)"'old_mod6'");}
        if (data[1] != (unsigned char)(old_mod6&255)) 
                       {dump_error((char *)"'old_mod6'");}
        if (data[2] != (unsigned char)(old_class6>>8)) 
                       {dump_error((char *)"'old_class6'");}
        if (data[3] != (unsigned char)(old_class6&255)) 
                       {dump_error((char *)"'old_class6'");}
      }
      else {          /* mit Original-Werten vergleichen */
        if (data[0] != (unsigned char)(mod6>>8)) 
                       {dump_error((char *)"'mod6'");}
        if (data[1] != (unsigned char)(mod6&255)) 
                       {dump_error((char *)"'mod6'");}
        if (data[2] != (unsigned char)(class6>>8)) 
                       {dump_error((char *)"'class6'");}
        if (data[3] != (unsigned char)(class6&255)) 
                       {dump_error((char *)"'class6'");}
      }
      recovercount6 = (unsigned short)(data[4])<<8  |  
                      (unsigned short)(data[5]);      
      if (data[6] != (unsigned char)(level6>>8)) 
                     {dump_error((char *)"'level6'");}
      if (data[7] != (unsigned char)(level6&255)) 
                     {dump_error((char *)"'level6'");}
      if (data[8] != (unsigned char)(mod6_used + (class6_used<<1) +
                                     (level6_used<<2)))
	             {dump_error((char *)"'level6_used'");}
    }
    else {recovercount6 = 0;}   /* wichtig */
  }
  else {recovercount6 = 0;}  /* wichtig, da nach dem Recovern 
                     "count6=recovercount6" gesetzt wird, wenn "alias=True" */
  if ((gelesen = fread(data,sizeof(unsigned char),8L,recoverfile))<8L)
     {lesefehler(recoverreadfilename,8L,gelesen,False);}
  if (comp4) {    /* obere 4 Bytes ignorieren */
    recover_hislen = (unsigned long)(data[4])<<24 |
                     (unsigned long)(data[5])<<16 |
                     (unsigned long)(data[6])<<8  |
                     (unsigned long)(data[7]);
  }
  else {
    //if (sizeof(unsigned long)==4) {
#if (ULONG_MAX == 4294967295UL)   
      /* pruefen, ob zu grosse Zahl eingelesen wird (z.B. von alpha) */
      if (data[0] || data[1] || data[2] || data[3]) 
         {logfile_entry((char *)"Error while reading dump file: Number too "
          "large (too small architecture?)\n",True,True,True); exit(166);}
      recover_hislen = (unsigned long)(data[4])<<24 |
                       (unsigned long)(data[5])<<16 |
                       (unsigned long)(data[6])<<8  |
                       (unsigned long)(data[7]);
      //}
#else // 64 bit
      //else {       /* alle 8 Bytes werden ernst genommen */
      recover_hislen = (unsigned long)(data[0])<<56 |
                       (unsigned long)(data[1])<<48 |
                       (unsigned long)(data[2])<<40 |
                       (unsigned long)(data[3])<<32 |
                       (unsigned long)(data[4])<<24 |
                       (unsigned long)(data[5])<<16 |
                       (unsigned long)(data[6])<<8  |
                       (unsigned long)(data[7]);
      //}
#endif
  }
  for (j=0; j<(size_t)recover_hislen; j++) {    
    /* "zweig[0]" ist nur bei bottom-up wichtig */
    if ((gelesen = fread(data,sizeof(unsigned char),8L,recoverfile))<8L)
       {lesefehler(recoverreadfilename,8L,gelesen,False);}
    if (comp4) {    /* obere 4 Bytes ignorieren */
      recoverzweig[j] = (unsigned long)(data[4])<<24 |
                        (unsigned long)(data[5])<<16 |
                        (unsigned long)(data[6])<<8  |
                        (unsigned long)(data[7]);
    }
    else {
      //      if (sizeof(unsigned long)==4) {  
#if (ULONG_MAX == 4294967295UL) 
        /* pruefen, ob zu grosse Zahl eingelesen wird (z.B. von alpha) */
        if (data[0] || data[1] || data[2] || data[3]) 
           {logfile_entry((char *)"Error while reading dump file: Number too "
            "large (too small architecture?)\n",True,True,True); exit(167);}
        recoverzweig[j] = (unsigned long)(data[4])<<24 |
                          (unsigned long)(data[5])<<16 |
                          (unsigned long)(data[6])<<8  |
                          (unsigned long)(data[7]);
	//}
#else // 64 bit
	//else {       /* alle 8 Bytes werden ernst genommen */
        recoverzweig[j] = (unsigned long)(data[0])<<56 |
                          (unsigned long)(data[1])<<48 |
                          (unsigned long)(data[2])<<40 |
                          (unsigned long)(data[3])<<32 |
                          (unsigned long)(data[4])<<24 |
                          (unsigned long)(data[5])<<16 |
                          (unsigned long)(data[6])<<8  |
                          (unsigned long)(data[7]);
	//}
#endif
    }
  }

  if ((gelesen = fread(data,sizeof(unsigned char),56L,recoverfile))<56L)
     {lesefehler(recoverreadfilename,56L,gelesen,False);}
  if (comp4) {    /* obere 4 Bytes ignorieren */
    recovernebenzweig[0] = (unsigned long)(data[4])<<24 |
                           (unsigned long)(data[5])<<16 |
                           (unsigned long)(data[6])<<8  |
                           (unsigned long)(data[7]);
  }
  else {
    //if (sizeof(unsigned long)==4) { 
#if (ULONG_MAX == 4294967295UL)  
      /* pruefen, ob zu grosse Zahl eingelesen wird (z.B. von alpha) */
      if (data[0] || data[1] || data[2] || data[3]) 
         {logfile_entry((char *)"Error while reading dump file: Number too "
          "large (too small architecture?)\n",True,True,True); exit(168);}
      recovernebenzweig[0] = (unsigned long)(data[4])<<24 |
                             (unsigned long)(data[5])<<16 |
                             (unsigned long)(data[6])<<8  |
                             (unsigned long)(data[7]);
      //}
#else // 64 bit
      // else {       /* alle 8 Bytes werden ernst genommen */
      recovernebenzweig[0] = (unsigned long)(data[0])<<56 |
                             (unsigned long)(data[1])<<48 |
                             (unsigned long)(data[2])<<40 |
                             (unsigned long)(data[3])<<32 |
                             (unsigned long)(data[4])<<24 |
                             (unsigned long)(data[5])<<16 |
                             (unsigned long)(data[6])<<8  |
                             (unsigned long)(data[7]);
      //}
#endif
  }
  if (comp4) {    /* obere 4 Bytes ignorieren */
    recovernebenzweig[1] = (unsigned long)(data[12])<<24 |
                           (unsigned long)(data[13])<<16 |
                           (unsigned long)(data[14])<<8  |
                           (unsigned long)(data[15]);
  }
  else {
    //   if (sizeof(unsigned long)==4) {   
#if (ULONG_MAX == 4294967295UL)
      /* pruefen, ob zu grosse Zahl eingelesen wird (z.B. von alpha) */
      if (data[8] || data[9] || data[10] || data[11]) 
         {logfile_entry((char *)"Error while reading dump file: Number too "
          "large (too small architecture?)\n",True,True,True); exit(169);}
      recovernebenzweig[1] = (unsigned long)(data[12])<<24 |
                             (unsigned long)(data[13])<<16 |
                             (unsigned long)(data[14])<<8  |
                             (unsigned long)(data[15]);
      //}
#else // 64 bit
      //else {       /* alle 8 Bytes werden ernst genommen */
      recovernebenzweig[1] = (unsigned long)(data[8])<<56 |
                             (unsigned long)(data[9])<<48 |
                             (unsigned long)(data[10])<<40 |
                             (unsigned long)(data[11])<<32 |
                             (unsigned long)(data[12])<<24 |
                             (unsigned long)(data[13])<<16 |
                             (unsigned long)(data[14])<<8  |
                             (unsigned long)(data[15]);
      // }
#endif
  }
  if (comp4) {    /* obere 4 Bytes ignorieren */
    recovernebenzweig[2] = (unsigned long)(data[20])<<24 |
                           (unsigned long)(data[21])<<16 |
                           (unsigned long)(data[22])<<8  |
                           (unsigned long)(data[23]);
  }
  else {
    //if (sizeof(unsigned long)==4) {
#if (ULONG_MAX == 4294967295UL)   
      /* pruefen, ob zu grosse Zahl eingelesen wird (z.B. von alpha) */
      if (data[16] || data[17] || data[18] || data[19]) 
         {logfile_entry((char *)"Error while reading dump file: Number too "
          "large (too small architecture?)\n",True,True,True); exit(170);}
      recovernebenzweig[2] = (unsigned long)(data[20])<<24 |
                             (unsigned long)(data[21])<<16 |
                             (unsigned long)(data[22])<<8  |
                             (unsigned long)(data[23]);
      //}
#else // 64 bit
      //else {       /* alle 8 Bytes werden ernst genommen */
      recovernebenzweig[2] = (unsigned long)(data[16])<<56 |
                             (unsigned long)(data[17])<<48 |
                             (unsigned long)(data[18])<<40 |
                             (unsigned long)(data[19])<<32 |
                             (unsigned long)(data[20])<<24 |
                             (unsigned long)(data[21])<<16 |
                             (unsigned long)(data[22])<<8  |
                             (unsigned long)(data[23]);
      //}
#endif
  }
  pfadtyp_rec = data[24];
  mgl_rec = data[25];
  submgl_rec = data[26];
  l1_rec = (KNOTENTYP)(data[27])<<8 | (KNOTENTYP)(data[28]);
  l2_rec = (KNOTENTYP)(data[29])<<8 | (KNOTENTYP)(data[30]);
  l3_rec = (KNOTENTYP)(data[31])<<8 | (KNOTENTYP)(data[32]);
  fln1_rec = (KNOTENTYP)(data[33])<<8 | (KNOTENTYP)(data[34]);
  fln2_rec = (KNOTENTYP)(data[35])<<8 | (KNOTENTYP)(data[36]);
  n_rec = (KNOTENTYP)(data[37])<<8 | (KNOTENTYP)(data[38]);
  g1_rec = (KNOTENTYP)(data[39])<<8 | (KNOTENTYP)(data[40]);
  g2_rec = (KNOTENTYP)(data[41])<<8 | (KNOTENTYP)(data[42]);
  g_rec = (KNOTENTYP)(data[43])<<8 | (KNOTENTYP)(data[44]);
  krit1_rec = (KNOTENTYP)(data[45])<<8 | (KNOTENTYP)(data[46]);
  krit2_rec = (KNOTENTYP)(data[47])<<8 | (KNOTENTYP)(data[48]);
  krit3_rec = (KNOTENTYP)(data[49])<<8 | (KNOTENTYP)(data[50]);
  gefunden1 = (BOOL)(data[51]&1);
  gefunden2 = (BOOL)((data[51]&2)!=0);
  gefunden3 = (BOOL)((data[51]&4)!=0);
#ifndef NOTIMES
  prevtime = (clock_t)(data[52])<<24 |
             (clock_t)(data[53])<<16 |
             (clock_t)(data[54])<<8  |
             (clock_t)(data[55]);
#endif //NOTIMES
  if (facestat) {lies_facestat_aus_dumpfile(recoverfile);}
  if (ferror(recoverfile)) {
    fprintf(stderr,"Error while reading dump file %s!\n",recoverreadfilename);
    fclose(recoverfile);
    exit(20);
  }
  fclose(recoverfile);
}


/************************************/
/* Low-Level-Umwandlungsfunktionen: */
/************************************/

/********************PATCHMAP_2_PLANARCODE***********************************/
/*   Fuer Patches, die beliebig numeriert sind.                             */
/*   Der planarcode wird typunabhaengig erzeugt, d.h. die fuehrende 0 ist
     beim Speichern selbst vorauszuschicken.                                */
/*   "code" muss ausreichend Speicherplatz bereithalten.                    */
/*   Die Funktion gibt die Laenge des Codes zurueck.                        */

size_t patchmap_2_planarcode(PLANMAP m, KNOTENTYP *code, KNOTENTYP n) {
  static size_t i;
  static KNOTENTYP k,j;
  i = 0;
  code[i++] = n;
  for (k=0; k<n; k++) {
    for (j=0; j<3; j++) {if (m[k][j]) {code[i++] = m[k][j]->name;} }
    code[i++] = 0;
  }
  return(i);
}

/********************PATCHMAP_2_EMBEDCODE************************************/
/*   Fuer Patches, die beliebig numeriert sind.                             */
/*   Die ersten beiden Eintraege "1" und "2" werden nicht erzeugt.          */
/*   "code" muss ausreichend Speicherplatz bereithalten.                    */
/*   Die Funktion gibt die Laenge des Codes zurueck.                        */

size_t patchmap_2_embedcode(PLANMAP m, KNOTENTYP *code, KNOTENTYP n) {
  static size_t i;
  static KNOTENTYP k,j;
  i = 0;
  code[i++] = n;
  for (k=0; k<n; k++) {
    for (j=0; j<3; j++) {
      if (m[k][j]) {code[i++] = m[k][j]->embed_nr;} 
    }
    code[i++] = 0;
  }
  return(i);
}

/*************************MAP_2_PLANARCODE***********************************/
/*   Fuer komplette Graphen, die beliebig numeriert sind.                   */
/*   "code" muss ausreichend Speicherplatz bereithalten.                    */

void map_2_planarcode(PLANMAP m, KNOTENTYP *code, KNOTENTYP n) {
  static size_t i;
  static KNOTENTYP k,j;
  i = 0;
  code[i++] = n;
  for (k=0; k<n; k++) {
    for (j=0; j<3; j++) {code[i++] = m[k][j]->name;}
    code[i++] = 0;
  }
}

/*************************MAP_2_EMBEDCODE************************************/
/*   Fuer komplette Graphen, die beliebig numeriert sind.                   */
/*   "code" muss ausreichend Speicherplatz bereithalten.                    */

void map_2_embedcode(PLANMAP m, KNOTENTYP *code, KNOTENTYP n) {
  static size_t i;
  static KNOTENTYP k,j;
  i = 0;
  code[i++] = n;
  for (k=0; k<n; k++) {
    for (j=0; j<3; j++) {code[i++] = m[k][j]->embed_nr;}
    code[i++] = 0;
  }
}

/*************************MAP_2_PLANARCODE2**********************************/
/*   wie "map_2_planarcode", aber fuer die alternative Numerierung          */

void map_2_planarcode2(PLANMAP m, KNOTENTYP *code, KNOTENTYP n) {
  static size_t i;
  static KNOTENTYP k,j;
  i = 0;
  code[i++] = n;
  for (k=0; k<n; k++) {
    for (j=0; j<3; j++) {code[i++] = m[k][j]->name2;}
    code[i++] = 0;
  }
}

/*************************MAP_2_EMBEDCODE2***********************************/
/*   wie "map_2_planarcode", aber fuer die alternative Numerierung          */

void map_2_embedcode2(PLANMAP m, KNOTENTYP *code, KNOTENTYP n) {
  static size_t i;
  static KNOTENTYP k,j;
  i = 0;
  code[i++] = n;
  for (k=0; k<n; k++) {
    for (j=0; j<3; j++) {code[i++] = m[k][j]->embed_nr2;}
    code[i++] = 0;
  }
}


/********************************/
/* Low-Level-Ausgabefunktionen: */
/********************************/

/**********SPEICHERE_GRAPHEN_AUS_OUTPUTLISTE_IN_FILES************************/
/*  Diese Funktion schreibt alle Daten aus der Outputliste in die
    zugehoerigen Files, wobei diese zuvor geoeffnet und anschliessend
    geschlossen werden. Die letzten 15 Argumente sind nur fuer das
    dump-File gedacht. */

void speichere_graphen_aus_outputliste_in_files(POSTYP hislen,unsigned char
     pfadtyp,unsigned char mgl,unsigned char submgl,KNOTENTYP l1,KNOTENTYP l2,
     KNOTENTYP l3,KNOTENTYP fl1,KNOTENTYP fl2,KNOTENTYP n,KNOTENTYP g1,
     KNOTENTYP g2,KNOTENTYP g,KNOTENTYP krit1,KNOTENTYP krit2,
     KNOTENTYP krit3) {
  static size_t i,j;
  static FILE *logfile,*f,*fbsy;
  static size_t to_write,written,written_gesamt;
  static int save_flag3;
  
  save_flag3 = (int)save_flag;  
     /* weil sich "save_flag" waehrend der Ausfuehrung
        der vorliegenden Funktion veraendern kann */
  if (save && (!lazydump_used || save_flag3)) {
    if ((fbsy = fopen(recoverflagfilename,"wb"))==nil) 
       {logfile_entry((char *)"saving\n",True,True,True);}
  }

  if (output) {      /* Karten speichern */
    i = ARRAYPOS_N((size_t)(genus_end_usr+1),n_anf_usr);    /* Arraygroesse */
    for (j=0; j<i; j++) {
      if (outputbufferused[j]) {     /* gibt's was zu schreiben? */

        /* Datei oeffnen */
        if (outputfile[j]==2) {f = stdout;}
        else {
          f = repeated_fopen(outputfilename[j],"ab",5);
          if (f==nil) { 
            fprintf(stderr,"Can't open output file %s!\n",outputfilename[j]);
            perror((char *)"Error description"); 
            if (logfile = repeated_fopen(logfilename,"a",5)) {
              fprintf(logfile,"Can't open output file %s!\n",
                      outputfilename[j]);
              fclose(logfile);
            }
            exit(21);
          }
        }

        /* schreiben (haeppchenweise wegen "interrupted system call") */
        written_gesamt = 0L;     /* geschriebene Bytes in diesem Durchgang */
        while (written_gesamt < outputbufferused[j]) {
          to_write = MIN(OUTPUT_ONE_ROW,outputbufferused[j]-written_gesamt);
          if ((written = fwrite(outputbuffer[j]+written_gesamt,
              sizeof(char),to_write,f)) < to_write) /* Fehler */
  	     {schreibfehler(outputfilename[j],to_write,written,False);}
          written_gesamt += to_write;
        }
        outputbufferused[j] = 0L;

        /* Datei schliessen */
        if (outputfile[j]==1) {        /* keine stdout-Ausgabe */
          if (ferror(f)) { 
            fprintf(stderr,"Error while writing into file %s!\n",
                    outputfilename[j]);
            perror((char *)"Error description");
            if (logfile = repeated_fopen(logfilename,"a",5)) {
              fprintf(logfile,"Error while writing into file %s!\n",
                      outputfilename[j]);
              fclose(logfile);
            }
            exit(22);
          }
          if (fclose(f)) {        /* Fehler */
            fprintf(stderr,"Error while closing file %s!\n",
                    outputfilename[j]);
            perror((char *)"Error description");
            if (logfile = repeated_fopen(logfilename,"a",5)) {
              fprintf(logfile,"Error while closing file %s!\n",
                      outputfilename[j]);
              fclose(logfile);
            }
            exit(23);
          }
        }
      }
    }
  }
 
  if (save && (!lazydump_used || save_flag)) {  /* Dumpfile speichern */
     /* weil die Karten beim Restart nicht mehr produziert werden */
     /* Falls "lazydump":  Dumpfile nur schreiben, wenn wirklich ein Zeitintervall
        vergangen ist. Sonst nur Karten schreiben. Das ist sinnvoll bei Pipes, wo
        es nicht schlimm ist, wenn nach einem Restart Karten doppelt gepiped
        werden. */
     /* Dumpfile nach den Karten schreiben, denn wenn beim Schreiben etwas
        schief geht, dann ist es besser, ein etwas veraltetes Dumpfile zu
        haben und Karten doppelt zu produzieren (zumal man weiss, wo man evtl.
        mit doppelten Karten rechnen muss), als wenn Karten fehlen, weil schon
        ein neues Dumpfile geschrieben wurde, bei dem die zugehoerigen Karten
        nicht angekommen sind. */
    if (lazydump_used && (int)save_flag != save_flag3) {  
      /* "save_flag" hat sich waehrend des Abspeicherns der Karten veraendert. 
         Die Wahrscheinlichkeit hierfuer ist relativ gross, wenn staendig Karten 
         gespeichert werden muessen. Deshalb schnell noch nachtraeglich
         .bsy-File oeffnen -> als waer's von Anfang an geoeffnet gewesen. */ 
      if ((fbsy = fopen(recoverflagfilename,"wb"))==nil) 
         {logfile_entry((char *)"saving\n",True,True,True);}
    }
    schreibe_dumpfile(False,hislen,recoverdata,pfadtyp,mgl,submgl,l1,l2,l3,fl1,
                      fl2,n,g1,g2,g,krit1,krit2,krit3); 
    if (fbsy==nil) 
       {logfile_entry((char *)"end of saving\n",True,True,True);}
    else {
      if (fclose(fbsy)) {logfile_entry((char *)"Warning: Could not close "
				       ".bsy-File.\n",True,True,True);}
      if (remove(recoverflagfilename))
         {logfile_entry((char *)"Warning: Could not remove .bsy-File.\n",
                        True,True,True);}
    }
    /* Wenn nach einem Abbruch des Programms das zugehoerige .bsy-File
       existiert, so war das Programm zum Zeitpunkt des Abbruchs gerade beim
       Schreiben der Karten oder des dump-Files. In dem Fall muss man von
       doppelten Karten oder einem zerstoerten dump-File ausgehen. */
  }
  else {save_flag = 0;  save_flag2 = False;}  
       /* steht sonst in "schreibe_dumpfile" */
}   

/*************************SCHREIBE_PLANARCODE*********************************/
/* Diese Funktion schreibt den Planarcode mit unsigned chars, wenn moeglich. */

void schreibe_planarcode(KNOTENTYP *planarcode,size_t file,size_t size) {
  static size_t i;
     
  if (sizeof(KNOTENTYP)==sizeof(char)) {
     /* Inhalt von "planarcode" kann direkt kopiert werden */
    memcpy(&outputbuffer[file][outputbufferused[file]],planarcode,
           sizeof(KNOTENTYP)*size);
    outputbufferused[file] += size;
  }  /* Zwischenspeicher ist voll - anschliessend alles ausgeben */
  else {    /* Zeichen fuer Zeichen kopieren */
    if (planarcode[0]>254) {   /* grosser Code */
      outputbuffer[file][outputbufferused[file]++] = 0;   /* big-Zeichen */
      for (i=0; i<size; i++) {    
        if (!bigendian) {          /* Big endian */ 
          outputbuffer[file][outputbufferused[file]++] = 
            (char)(planarcode[i]&255);       
          outputbuffer[file][outputbufferused[file]++] = 
            (char)(planarcode[i]>>8);
        }
        else {                    /* Little endian */  
          outputbuffer[file][outputbufferused[file]++] = 
            (char)(planarcode[i]>>8);
          outputbuffer[file][outputbufferused[file]++] = 
            (char)(planarcode[i]&255);
	}
      }
    }
    else {        /* kleiner Code */
      for (i=0; i<size; i++)
        {outputbuffer[file][outputbufferused[file]++] = (char)(planarcode[i]);}
    }
  }    
  if (outputbufferused[file] > outputbufferlen[file]) {save_flag2 = True;}
}
       

/*************************SCHREIBE_EMBEDCODE*********************************/
/* Diese Funktion schreibt den Embedcode mit unsigned chars, wenn moeglich. */

void schreibe_embedcode(KNOTENTYP *code,size_t file,size_t size) {
  static size_t i;
     
  outputbuffer[file][outputbufferused[file]++] = 1;   /* embed-code-Kennung */
  outputbuffer[file][outputbufferused[file]++] = 2;   /* embed-code-Kennung */
  if (sizeof(KNOTENTYP)==sizeof(char)) {
     /* Inhalt von "planarcode" kann direkt kopiert werden */
    memcpy(&outputbuffer[file][outputbufferused[file]],code,
           sizeof(KNOTENTYP)*size);
    outputbufferused[file] += size;
  }  /* Zwischenspeicher ist voll - anschliessend alles ausgeben */
  else {    /* Zeichen fuer Zeichen kopieren */
    if (code[0]>170) {   /* grosser Code */
      outputbuffer[file][outputbufferused[file]++] = 0;   /* big-Zeichen */
      for (i=0; i<size; i++) {    
        if (!bigendian) {          /* Little endian */ 
          outputbuffer[file][outputbufferused[file]++] = 
            (char)(code[i]&255);       
          outputbuffer[file][outputbufferused[file]++] = 
            (char)(code[i]>>8);
        }
        else {                    /* Big endian */  
          outputbuffer[file][outputbufferused[file]++] = 
            (char)(code[i]>>8);
          outputbuffer[file][outputbufferused[file]++] = 
            (char)(code[i]&255);
        }
      }
    }
    else {        /* kleiner Code */
      for (i=0; i<size; i++)
        {outputbuffer[file][outputbufferused[file]++] = (char)(code[i]);}
    }
  }    
  if (outputbufferused[file] > outputbufferlen[file]) {save_flag2 = True;}
}
       

/***************************************************************/
/* Low-Level-Funktionen zur Codierung von Graphen und Patches: */
/***************************************************************/

/************************DUALPLANARCODE**********************************/
/* Berechnet das Dual und schreibt es als planarcode in code.           */
/* Der "all"-Wert jeder Kante passt in eine Variable vom Typ KNOTENTYP. */

size_t dualplanarcode(KNOTENTYP *code, PLANMAP m, KNOTENTYP knotenzahl, 
                      KNOTENTYP genus) {
  static KNOTENTYP flaechenzahl,i,j;
  static size_t codelaenge;
  static KANTE *startedge[F_MAXANZ+1];
  static KANTE *run, *merke;

  code[0] = flaechenzahl = 2 + knotenzahl/2 - 2*genus;
  codelaenge = 1;

  for (i=0; i<knotenzahl; i++) {   /* fuer jede Flaeche eine Kante aussuchen */
    for (j=0; j<3; j++) {
      startedge[m[i][j]->connfl] = m[i][j];
      /* "startedge" wird mehrfach ueberschrieben, aber macht ja nichts.
         Am Ende bleibt jedenfalls eine gueltige Kante */
    }
  } 

  for (i=1; i<=flaechenzahl; i++) { 
    run = merke = startedge[i]; 
    do {
      code[codelaenge++] = run->invers->connfl;
      run = run->invers->prev;
    } while (run!=merke);
    code[codelaenge++] = 0;
  }
  return(codelaenge);
}

/************************DUALEMBEDCODE***********************************/
/* Berechnet das Dual und schreibt es als embedcode in code.            */
/* Der "all"-Wert jeder Kante passt in eine Variable vom Typ KNOTENTYP. */

size_t dualembedcode(KNOTENTYP *code, PLANMAP m, KNOTENTYP knotenzahl, 
                     KNOTENTYP genus) {
  static KNOTENTYP flaechenzahl,i,j;
  static size_t codelaenge;
  static KANTE *startedge[F_MAXANZ+1];
  static KANTE *run, *merke;

  code[0] = flaechenzahl = 2 + knotenzahl/2 - 2*genus;
  codelaenge = 1;

  for (i=0; i<knotenzahl; i++) {   /* fuer jede Flaeche eine Kante aussuchen */
    for (j=0; j<3; j++) {
      startedge[m[i][j]->connfl] = m[i][j];
      /* "startedge" wird mehrfach ueberschrieben, aber macht ja nichts.
         Am Ende bleibt jedenfalls eine gueltige Kante */
    }
  } 

  for (i=1; i<=flaechenzahl; i++) { 
    run = merke = startedge[i]; 
    do {
      code[codelaenge++] = run->invers->embed_nr;
      run = run->invers->prev;
    } while (run!=merke);
    code[codelaenge++] = 0;
  }
  return(codelaenge);
}

/*************************NUMERIERE_GRAPH************************************/
/*  Findet Numerierung fuer Graphen, wobei der markierte Knoten die
    1 erhaelt. Es wird vorausgesetzt, dass im Graphen alle Knoten mit 0 
    numeriert sind (also alle "ursprung"-Eintraege und alle "name"-Eintraege).
    Das Ergebnis der Numerierung steht in m. Ueber m sind dann auch alle
    Kanten ansprechbar, denn jede (gerichtete) Kante besitzt genau einen
    Eintrag in m. Deshalb wird das Numerieren von Graphen oftmals nur benutzt,
    um das Array m zu erhalten.  
    Markiert wird der Knoten k->ursprung. Der gesamte Graph wird von k aus
    erreicht, so dass k als Zeiger auf den gesamten Graphen dient. */
/*  Die Funktion kann auch dann benutzt werden, wenn "k" noch gar keinen 
    3-regulaeren Graphen, sondern nur einen Patch oder ein Geruest
    kennzeichnet. Falls "k" nur auf einen Patch zeigt, so ist "k" die
    Grundkante, d.h. k->prev existiert nicht. Falls "k" auf ein Geruest 
    zeigt, so ist "k" ebenfalls eine Grundkante, aber "k->prev" existiert.
    Auf jeden Fall existiert "k->next".                                     */
/*  Die Funktion gibt die Knotenzahl im Graphen bzw. Patch zurueck.         */
/*  Die Funktion klappt auch bei Loops und Doppelkanten, wobei dann
    zusaetzlich die Kanten numeriert werden. Die Kanten muessen zu Beginn
    ebenfalls mit 0 numeriert sein.                                         */

KNOTENTYP numeriere_graph(PLANMAP m,KANTE *k) {
  static KNOTENTYP i,j;      /* j = hoechste bisher vergebene Nummer */
  static KNOTENTYP jj;       /* jj = hoechste bisher vergebene Kantennummer */

  /*  m erhaelt korrekte Numerierung: */ 
  j = k->ursprung = k->next->ursprung = 1;
  if (k->prev) {k->prev->ursprung = 1;}
  m[0][0] = k;  m[0][1] = k->next;  m[0][2] = k->prev;  
  if (k->fl_rechts==1) {k = k->prev;}
  else if (k->invers->fl_rechts==1) {k = k->next;}
  /* Nun zeigt "k" auf jeden Fall auf einen zweiten Knoten. */
  /* Wichtig: erst werden die m[0]-Elemente gesetzt, dann wird "k" veraendert,
     denn sonst wuerden zwei verschiedene roots zum selben kanonischen
     embed_code fuehren. */
  m[j][0] = k->invers;
  j++;
  k->name = k->invers->ursprung = j;
  if (k->invers->next) {k->invers->next->ursprung = j;}
  if (k->invers->prev) {k->invers->prev->ursprung = j;}

  i = 0;
  while (i<j) {              /* es gibt noch unbelegte Knoten */
    k = m[i][0];             /* diese Kante ist bereits verknuepft worden */
    k->name = k->invers->ursprung;   /* darum existiert dieser Wert */  
    if (k->next) {
      if (k->next->invers->ursprung==0) {   /* ist bei Loops nicht der Fall */
        k->next->name = ++j;   m[j-1][0] = k->next->invers;
        m[j-1][0]->ursprung = j;
        if (m[j-1][0]->prev) {m[j-1][0]->prev->ursprung = j;} 
        if (m[j-1][0]->next) {m[j-1][0]->next->ursprung = j;}
      }
      else {k->next->name = k->next->invers->ursprung;}
    }
    if (k->prev) {
      if (k->prev->invers->ursprung==0) {
        k->prev->name = ++j;   m[j-1][0] = k->prev->invers;
        m[j-1][0]->ursprung = j;
        if (m[j-1][0]->prev) {m[j-1][0]->prev->ursprung = j;} 
        if (m[j-1][0]->next) {m[j-1][0]->next->ursprung = j;}
      }
      else {k->prev->name = k->prev->invers->ursprung;}
    }
    m[i][1] = k->next;
    m[i][2] = k->prev;
    i++;
  }

  /* Kanten numerieren: */
  if (doppelkanten || dual) {
    jj = m[0][0]->embed_nr = 1;
    if (m[0][1]) {jj = m[0][1]->embed_nr = (m[0][1]!=m[0][0]->invers) ? 2 : 1;}
    if (m[0][2]) {
      if (m[0][1] && m[0][2]==m[0][1]->invers) 
         {m[0][2]->embed_nr = m[0][1]->embed_nr;}
      else if (m[0][2]==m[0][0]->invers) 
              {m[0][2]->embed_nr = m[0][0]->embed_nr;}
      else {m[0][2]->embed_nr = ++jj;}
    }
    for (i=1; i<j; i++) {
      m[i][0]->embed_nr = m[i][0]->invers->embed_nr;
      if (m[i][1]) {
        if (m[i][1]->invers->embed_nr) 
           {m[i][1]->embed_nr = m[i][1]->invers->embed_nr;}
        else {m[i][1]->embed_nr = ++jj;}
      }
      if (m[i][2]) {
        if (m[i][2]->invers->embed_nr) 
           {m[i][2]->embed_nr = m[i][2]->invers->embed_nr;}
        else {m[i][2]->embed_nr = ++jj;}
      }
    }
  }
  return(j);
}

/*************************NUMERIERE_GRAPH2***********************************/
/*  Funktioniert wie "numeriere_graph", aber benutzt den alternativen
    Speicherplatz in der Struktur "kante". Die Funktion ist nur fuer 
    S3Z--Karten vorgesehen, nicht aber fuer Patches. Deshalb entfallen 
    Abfragen, ob eine Kante existiert.                                      */

KNOTENTYP numeriere_graph2(PLANMAP m,KANTE *k) {
  static KNOTENTYP i,j;
  static KNOTENTYP jj;      /* jj = hoechste bisher vergebene Kantennummer */

  /*  m erhaelt korrekte Numerierung: */ 
  j = k->ursprung2 = k->next->ursprung2 = k->prev->ursprung2 = 1;
  m[0][0] = k;  m[0][1] = k->next;  m[0][2] = k->prev;  
  if (k->fl_rechts==1) {k = k->prev;}
  else if (k->invers->fl_rechts==1) {k = k->next;}
  m[j][0] = k->invers;
  j++; 
  k->name2 = k->invers->ursprung2 = k->invers->next->ursprung2 = 
                                    k->invers->prev->ursprung2 = j;
  i = 0;
  while (i<j) {              /* es gibt noch unbelegte Knoten */
    k = m[i][0];             /* diese Kante ist bereits verknuepft worden */
    k->name2 = k->invers->ursprung2;   /* darum existiert dieser Wert */  
    if (k->next->invers->ursprung2==0) {
      k->next->name2 = ++j;   m[j-1][0] = k->next->invers;
      m[j-1][0]->ursprung2 = m[j-1][0]->prev->ursprung2 =  
                             m[j-1][0]->next->ursprung2 = j;
    }
    else {k->next->name2 = k->next->invers->ursprung2;}
    if (k->prev->invers->ursprung2==0) {
      k->prev->name2 = ++j;   m[j-1][0] = k->prev->invers;
      m[j-1][0]->ursprung2 = m[j-1][0]->prev->ursprung2 = 
                             m[j-1][0]->next->ursprung2 = j;
    }
    else {k->prev->name2 = k->prev->invers->ursprung2;}
    m[i][1] = k->next;
    m[i][2] = k->prev;
    i++;
  }

  /* Kanten numerieren: */
  if (doppelkanten || dual) {
    m[0][0]->embed_nr2 = 1;
    jj = m[0][1]->embed_nr2 = (m[0][1]!=m[0][0]->invers) ? 2 : 1;
    if (m[0][2]==m[0][1]->invers) 
       {m[0][2]->embed_nr2 = m[0][1]->embed_nr2;}
    else if (m[0][2]==m[0][0]->invers) 
            {m[0][2]->embed_nr2 = m[0][0]->embed_nr2;}
    else {m[0][2]->embed_nr2 = ++jj;}
    for (i=1; i<j; i++) {
      m[i][0]->embed_nr2 = m[i][0]->invers->embed_nr2;
      if (m[i][1]->invers->embed_nr2) 
         {m[i][1]->embed_nr2 = m[i][1]->invers->embed_nr2;}
      else {m[i][1]->embed_nr2 = ++jj;}
      if (m[i][2]->invers->embed_nr2) 
         {m[i][2]->embed_nr2 = m[i][2]->invers->embed_nr2;}
      else {m[i][2]->embed_nr2 = ++jj;}
    }
  }
  return(j);
}

/*************************NUMERIERE_GRAPH_SP********************************/
/*  Funktioniert wie "numeriere_graph", aber numeriert spiegelverkehrt.    */
/*  Diese Funktion wird nur fuer komplette 3-regulaere Graphen gebraucht,
    deshalb entfallen Abfragen, ob eine Kante existiert.                   */

KNOTENTYP numeriere_graph_sp(PLANMAP m,KANTE *k) {
  static KNOTENTYP i,j;
  static KNOTENTYP jj;       /* jj = hoechste bisher vergebene Kantennummer */

  /*  m erhaelt korrekte Numerierung: */ 
  j = k->ursprung = k->next->ursprung = k->prev->ursprung = 1;
  m[0][0] = k;  m[0][1] = k->prev;  m[0][2] = k->next;  
  if (k->fl_rechts==1) {k = k->prev;}
  else if (k->invers->fl_rechts==1) {k = k->next;}
  m[j][0] = k->invers;
  j++;
  k->name = k->invers->ursprung = k->invers->next->ursprung = 
                                  k->invers->prev->ursprung = j;
  i = 0;
  while (i<j) {              /* es gibt noch unbelegte Knoten */
    k = m[i][0];             /* diese Kante ist bereits verknuepft worden */
    k->name = k->invers->ursprung;   /* darum existiert dieser Wert */  
    if (k->prev->invers->ursprung==0) {
      k->prev->name = ++j;   m[j-1][0] = k->prev->invers;
      m[j-1][0]->ursprung = m[j-1][0]->prev->ursprung = 
                            m[j-1][0]->next->ursprung = j;
    }
    else {k->prev->name = k->prev->invers->ursprung;}
    if (k->next->invers->ursprung==0) {
      k->next->name = ++j;   m[j-1][0] = k->next->invers;
      m[j-1][0]->ursprung = m[j-1][0]->prev->ursprung = 
                            m[j-1][0]->next->ursprung = j;
    }
    else {k->next->name = k->next->invers->ursprung;}
    m[i][1] = k->prev;
    m[i][2] = k->next;
    i++;
  }

  /* Kanten numerieren: */
  if (doppelkanten || dual) {
    m[0][0]->embed_nr = 1;
    jj = m[0][1]->embed_nr = (m[0][1]!=m[0][0]->invers) ? 2 : 1;
    if (m[0][2]==m[0][1]->invers) 
       {m[0][2]->embed_nr = m[0][1]->embed_nr;}
    else if (m[0][2]==m[0][0]->invers) 
            {m[0][2]->embed_nr = m[0][0]->embed_nr;}
    else {m[0][2]->embed_nr = ++jj;}
    for (i=1; i<j; i++) {
      m[i][0]->embed_nr = m[i][0]->invers->embed_nr;
      if (m[i][1]->invers->embed_nr) 
         {m[i][1]->embed_nr = m[i][1]->invers->embed_nr;}
      else {m[i][1]->embed_nr = ++jj;}
      if (m[i][2]->invers->embed_nr) 
         {m[i][2]->embed_nr = m[i][2]->invers->embed_nr;}
      else {m[i][2]->embed_nr = ++jj;}
    }
  }
  return(j);
}

/*************************NUMERIERE_GRAPH2_SP********************************/
/*  Funktioniert wie "numeriere_graph2", aber numeriert spiegelverkehrt.    */
/*  Diese Funktion wird nur fuer komplette 3-regulaere Graphen gebraucht,
    deshalb entfallen Abfragen, ob eine Kante existiert.                   */

KNOTENTYP numeriere_graph2_sp(PLANMAP m,KANTE *k) {
  static KNOTENTYP i,j;
  static KNOTENTYP jj;      /* jj = hoechste bisher vergebene Kantennummer */

  /*  m erhaelt korrekte Numerierung: */ 
  j = k->ursprung2 = k->next->ursprung2 = k->prev->ursprung2 = 1;
  m[0][0] = k;  m[0][1] = k->prev;  m[0][2] = k->next;  
  if (k->fl_rechts==1) {k = k->prev;}
  else if (k->invers->fl_rechts==1) {k = k->next;}
  m[j][0] = k->invers;
  j++;
  k->name2 = k->invers->ursprung2 = k->invers->next->ursprung2 = 
                                    k->invers->prev->ursprung2 = 2;
  i = 0;
  while (i<j) {              /* es gibt noch unbelegte Knoten */
    k = m[i][0];             /* diese Kante ist bereits verknuepft worden */
    k->name2 = k->invers->ursprung2;   /* darum existiert dieser Wert */  
    if (k->prev->invers->ursprung2==0) {
      k->prev->name2 = ++j;   m[j-1][0] = k->prev->invers;
      m[j-1][0]->ursprung2 = m[j-1][0]->prev->ursprung2 = 
                             m[j-1][0]->next->ursprung2 = j;
    }
    else {k->prev->name2 = k->prev->invers->ursprung2;}
    if (k->next->invers->ursprung2==0) {
      k->next->name2 = ++j;   m[j-1][0] = k->next->invers;
      m[j-1][0]->ursprung2 = m[j-1][0]->prev->ursprung2 =
                             m[j-1][0]->next->ursprung2 = j;
    }
    else {k->next->name2 = k->next->invers->ursprung2;}
    m[i][1] = k->prev;
    m[i][2] = k->next;
    i++;
  }

  /* Kanten numerieren: */
  if (doppelkanten || dual) {
    m[0][0]->embed_nr2 = 1;
    jj = m[0][1]->embed_nr2 = (m[0][1]!=m[0][0]->invers) ? 2 : 1;
    if (m[0][2]==m[0][1]->invers) 
       {m[0][2]->embed_nr2 = m[0][1]->embed_nr2;}
    else if (m[0][2]==m[0][0]->invers) 
            {m[0][2]->embed_nr2 = m[0][0]->embed_nr2;}
    else {m[0][2]->embed_nr2 = ++jj;}
    for (i=1; i<j; i++) {
      m[i][0]->embed_nr2 = m[i][0]->invers->embed_nr2;
      if (m[i][1]->invers->embed_nr2) 
         {m[i][1]->embed_nr2 = m[i][1]->invers->embed_nr2;}
      else {m[i][1]->embed_nr2 = ++jj;}
      if (m[i][2]->invers->embed_nr2) 
         {m[i][2]->embed_nr2 = m[i][2]->invers->embed_nr2;}
      else {m[i][2]->embed_nr2 = ++jj;}
    }
  }
  return(j);
}

/*******************LOESCHE_NUMERIERUNG**************************************/
/*  Diese Funktion loescht die Originalnumerierung im fertigen Graphen m. 
    m muss ein fertiger Graph sein.                                         */

void loesche_numerierung(PLANMAP m,KNOTENTYP n) {
  static KNOTENTYP i,j;
  for (i=0; i<n; i++) {
    for (j=0; j<3; j++) 
      {m[i][j]->ursprung = m[i][j]->name = m[i][j]->embed_nr = 0;}
  }
}
 
/*******************LOESCHE_NUMERIERUNG2*************************************/
/*  Diese Funktion loescht die alternativen Numerierungen im fertigen 
    Graphen m. m muss ein fertiger Graph sein.                              */

void loesche_numerierung2(PLANMAP m,KNOTENTYP n) {
  static KNOTENTYP i,j;
  for (i=0; i<n; i++) {
    for (j=0; j<3; j++) 
      {m[i][j]->ursprung2 = m[i][j]->name2 = m[i][j]->embed_nr2 = 0;}
  }
}
 
/*******************LOESCHE_PATCHNUMERIERUNG*********************************/
/*  Diese Funktion loescht die Originalnumerierung im Patch m. 
    m muss kein fertiger Graph sein.                                        */

void loesche_patchnumerierung(PLANMAP m,KNOTENTYP n) {
  static KNOTENTYP i,j;
  for (i=0; i<n; i++) {
    for (j=0; j<3; j++) {
      if (m[i][j]) {m[i][j]->ursprung = m[i][j]->name = m[i][j]->embed_nr = 0;}
    }
  }
}
 
/***************************VERGLEICHE_CODES*********************************/
/*  Fuer Randcodes, Patchcodes und Pfadcodes                                */
/*  kein memcmp, um endian-Probleme zu vermeiden                            */

signed char vergleiche_codes(KNOTENTYP *code1,POSTYP len1,KNOTENTYP *code2,
                             POSTYP len2) {
  static POSTYP i;
  if (len1>len2) {return(1);} else if (len1<len2) {return(-1);}
  /* ab hier gilt: beide Codes sind gleich lang */
  for (i=0; i<len1; i++) {
    if (*code1 > *code2) {return(1);}
    else if (*code1 < *code2) {return(-1);}
    code1++;  code2++;
  }
  return(0);
}


/*************************************************************/
/* Low-Level-Funktionen zur Ueberwachung der Flaechenzahlen: */
/*************************************************************/

/*****************FLAECHENZAHLEN_OK****************************************/
/*  Prueft, ob die vom Benutzer geforderten Flaechenzahlen eingehalten
    werden. "e" ist der Patch, der mit sich selbst zu einer kompletten
    Karte verklebt werden soll.                                           */

BOOL flaechenzahlen_ok(ELEM *e) {
  static FLAECHENTYP f;
  static KNOTENTYP f_anz;
  for (f=0; f<anz_face; f++) {
    if ((f_anz = (e->flaechenzahl)[f]) > facenum_max[f]  || 
         f_anz < facenum_min[f])
       {return(False);}
  }
  return(True);
}

/*****************FLAECHENZAHLEN2_OK***************************************/
/*  Prueft, ob die vom Benutzer geforderten oberen Flaechenzahlgrenzen 
    eingehalten werden. "e1" und "e2" sind die beiden Patches, die miteinander
    verklebt werden sollen. Im Gegensatz zu "flaechenzahlen_ok" und
    "flaechenzahlen3_ok" werden NICHT die Mindestzahlen geprueft.         */
/*  Falls ein Patch mit sich selbst verklebt werden soll, so wird nil an e2
    uebergeben.  */
/*  Falls "digon_path==True", so wird noch ein Zweieck hinzugezaehlt, da 
    noch keine kompletten Karten erzeugt werden und kein Patch alle Zweiecke
    besitzen kann. Das setzt voraus, dass aus "e1" und "e2" nur EIN Patch
    entsteht.                                                             */

BOOL flaechenzahlen2_ok(ELEM *e1,ELEM *e2) {
  static FLAECHENTYP f;
  for (f=0; f<anz_face; f++) {
    if ((e1->flaechenzahl)[f]+ (e2 ? (e2->flaechenzahl)[f] : 0)
        + (digon_path && face[f]==2) > facenum_max[f]) {return(False);}
  }
  return(True);
}

/*****************FLAECHENZAHLEN3_OK***************************************/
/*  Prueft, ob die vom Benutzer geforderten Flaechenzahlen eingehalten
    werden. "e1", "e2" und "e3" sind die drei Patches, 
    die miteinander verklebt werden sollen. Falls nicht alle Patches 
    verschieden sind, so wird nil an e2 und/oder e3 uebergeben, so dass 
    genau so viele Werte ungleich nil und voneinander verschieden sind, 
    wie Patches beteiligt sind.   */

BOOL flaechenzahlen3_ok(ELEM *e1,ELEM *e2,ELEM *e3) {
  static FLAECHENTYP f;
  static KNOTENTYP f_anz;
  for (f=0; f<anz_face; f++) {
    if ((f_anz = (e1->flaechenzahl)[f]+(e2 ? (e2->flaechenzahl)[f] : 0)+
        (e3 ? (e3->flaechenzahl)[f] : 0)) > facenum_max[f]  ||  
        f_anz<facenum_min[f])
      {return(False);}
  }
  return(True);
}

/**************FLAECHENVORAUSSCHAU_OK**************************************/
/*  Diese Funktion prueft fuer zwei Patches "e1" und "e2", die miteinander
    verklebt werden sollen, ob aus dem Ergebnispatch ueberhaupt noch etwas
    werden kann, wenn man die Mindestzahlen pro Flaechentyp, die im Graphen
    herauskommen sollen, mitberuecksichtigt. Der Ergebnispatch besitzt
    "fl" Flaechen, Geschlecht "g", "r" Raender und eine Flaechendifferenz 
    "fd". */
/* Falls e1 und e2 identisch sind (also ein Patch mit sich selbst verklebt
   wird), so wird an e2 der Wert nil uebergeben. */
/* Es wird vorausgesetzt, dass das Array "face[f]" in aufsteigender
   Reihenfolge sortiert ist. Diese Funktion ist im Vergleich zu derjenigen
   in CPF.c weiterfuehrend:  Es werden ausserdem noch die Maximalzahlen pro
   Flaechentyp beruecksichtigt, d.h. es wird nicht nur versucht, eine 
   Flaechendifferenz mit der kleinsten oder groessten Flaeche auszugleichen,
   sondern es wird auch beruecksichtigt, wie oft diese Flaeche ueberhaupt
   noch eingesetzt werden darf. Manchmal muss auf die naechstgroessere bzw.
   -kleinere Flaeche zugegriffen werden.                                  */
/* "mingen" ist das kleinstmoegliche Geschlecht, das eine
   Zielkarte, die Nachfolger des Ergebnispatcheses ist, besitzen kann.    */
   
BOOL flaechenvorausschau_ok(ELEM *e1,ELEM *e2,KNOTENTYP g,KNOTENTYP fl,
                            KNOTENTYP r,POSTYP fd) {
  static POSTYP fd_neu;
  static KNOTENTYP fl_neu;
  static FLAECHENTYP f;
  static EULERTYP f_anz;
  static KNOTENTYP flaechenzahl[MAXFTYPEN];
  static KNOTENTYP mingen;
  static KNOTENTYP fl_alt;                /* ??? */

  mingen = MAX(genus_anf,g+r-1);  
  fl_alt = fl;     /* ??? */

  /* Schleife 1: */
  for (f=0; f<anz_face; f++) {
    flaechenzahl[f] = (e1->flaechenzahl)[f] + (e2 ? (e2->flaechenzahl)[f] : 0);
    if ((f_anz = facenum_min[f]-(EULERTYP)flaechenzahl[f]) > 0) {
      fl += f_anz;     /* f_anz Flaechen kommen mindestens hinzu */
      fd += (6-(EULERTYP)face[f])*(EULERTYP)f_anz;   /* fd aendert sich auch */
    }
  }  
  if (fl>f_max[mingen]) {return(False);}  
      /* zu viele Flaechen kommen hinzu */

  /* Es gilt immer:  genus_anf_fd >= genus_end_fd */
  /* Schleife 2: */
  f = anz_face;        /* face[f-1] = groesste Flaeche */
  fl_neu = 0;   fd_neu = 0;
  while (fd+fd_neu > genus_anf_fd) {
    /* grosse Flaechen muessen hinzu */
    if (f==0 || fl+fl_neu>=f_max[mingen]) {return(False);}
       /* keine Flaeche mehr uebrig zum Ausgleichen */
    f--;      /* naechstkleinere Flaeche ansteuern */
    if (face[f]<=6) {return(False);}   /* fd wird nicht mehr kleiner */
    f_anz = (EULERTYP)MIN(facenum_max[f]-MAX(facenum_min[f],flaechenzahl[f]),
                          f_max[mingen]-fl-fl_neu);               
      /* f_anz Flaechen der Groesse face[f] koennen noch hinzukommen */ 
      /* MAX, weil durch Schleife 1 mindestens facenum_min[f] Flaechen bereits
         beruecksichtigt sind, auch wenn flaechenzahl[f] < facenum_min[f] */
      /* MIN, damit auf keinen Fall f_max ueberschritten wird */
    fl_neu += f_anz;
    fd_neu += (6-(EULERTYP)face[f])*(EULERTYP)f_anz;
  }  
                   
  /* Schleife 3: */
  f = 0;               /* face[0] = kleinste Flaeche */
  fl_neu = 0;   fd_neu = 0;
  while (fd+fd_neu < genus_end_fd) {
    /* kleine Flaechen muessen hinzu */
    if (f==anz_face || fl+fl_neu>=f_max[mingen] || face[f]>=6) {return(False);}
       /* keine Flaeche mehr uebrig zum Ausgleichen */
    f_anz = (EULERTYP)MIN(facenum_max[f]-MAX(facenum_min[f],flaechenzahl[f]),
                          f_max[mingen]-fl-fl_neu);               
      /* f_anz Flaechen der Groesse face[f] koennen noch hinzukommen */ 
    fl_neu += f_anz;
    fd_neu += (6-(EULERTYP)face[f])*(EULERTYP)f_anz;
    f++;    /* naechstgroessere Flaeche ansteuern */
  }  
  return(True);
}
         

/*******************************************************/
/* Low-Level-Funktionen zur Ueberwachung der Struktur: */
/*******************************************************/

/********************ALL_3_VAL***********************************************/
/*  Diese Funktion prueft, ob alle Knoten, die vom Knoten k->ursprung aus
    erreichbar sind, 3-valent sind. Knoten, die mit 2 markiert sind,
    duerfen nicht ueberquert werden. Die Funktion arbeitet rekursiv. Die 
    Markierungen befinden sich im Array "mark".                             */
/*  Bevor ein 2-valenter Randknoten erreicht wird, bricht die Rekursion ab,
    weil ein 3-valenter Randknoten erreicht wird. Deshalb muss nicht abgefragt
    werden, ob k->prev oder k->next existiert.                              */
/*  Es gilt:  k->name braucht nicht untersucht zu werden, weil entweder die
    Rekursion von dort kommt oder der zugehoerige Ursprungsknoten nicht zu
    dem zu untersuchenden Bereich gehoert (oberste Rekursionsebene).        */
   
BOOL all_3_val(KANTE *k,unsigned char *mark) {
  mark[k->ursprung] |= 2;
  if ((mark[k->prev->name]&1) || (mark[k->next->name]&1)) {return(False);}
     /* Randknoten erreicht */
  return(((mark[k->prev->name]&2) || all_3_val(k->prev->invers,mark)) &&
         ((mark[k->next->name]&2) || all_3_val(k->next->invers,mark)));
} 

/*************************GETCONN********************************************/
/* Liefert die Zusammenhangszahl z von m oder den Wert 0, wenn der Patch/die
   Karte aufgrund der Kriterien "facecon1" und "facecon2" aussortiert werden
   soll. Es gilt immer: facecon2==False => facecon1==False.                 */
/* Die "connfl"-Eintraege muessen gueltige Werte zwischen 1 und n/2+2
   besitzen.                                                                */
/* Es gilt nicht unbedingt m[i-1][j]->ursprung==i (beim Isomorphietest
   koennen Veraenderungen auftreten), aber m[i-1][j]->ursprung ist gleich 
   fuer alle j.                                                             */
/* Die Funktion liefert nur den korrekten Wert fuer 1-zusammenhaengende 
   Karten und Karten vom Geschlecht g==0. Ansonsten liefert sie die untere
   Schranke 2.                                                              */

unsigned char getconn(PLANMAP m, KNOTENTYP n, KANTE **grundkante, KNOTENTYP
                      gklen) {
  static unsigned char connerg;
  static KANTE *k1;
  static KNOTENTYP i,j,ii;
  static KNOTENTYP inner[N_MAX_P/2];    /* Speicher fuer innere Knoten und
         3-valente Randknoten (N_MAX_P/2 genuegt, weil nur jeder zweite
         Knoten ein 3-valenter Randknoten sein kann. Jeder innere Knoten wiegt
         sogar das Dreifache eines 2-valenten Randknotens) */
  static KNOTENTYP anz1,anz2;   /* anz1 = Anzahl der gespeicherten 3-valenten 
      Randknoten, anz2 = anz1 + Anzahl der inneren Knoten */
  static KNOTENTYP anz;
  static KNOTENTYP fl2;   /* Nummer einer ausgewaehlten Flaeche */
  static unsigned char mark[N_MAX_P+1]; /* Speicher fuer Knotenmarkierungen */
         /* Bit 0:  es handelt sich um einen Randknoten */
         /* Bit 1:  der Knoten gilt als nicht erreichbar bzw. verarbeitet */
  
  connerg = 2;   /* vorerst */

  /* Markierungen loeschen: */
  for (i=1; i<=n; i++) {mark[i] = 0;}
  anz1 = 0;

  /* Randknoten markieren und eventuell speichern: */
  for (i=0; i<gklen; i++) {     /* kein Durchlauf bei kompletten S3Z-Graphen */
    k1 = grundkante[i];
    do {
      mark[k1->ursprung] = 1;        /* 1 => Randknoten */
      if (k1->prev && k1->next && (!facecon1 || !facecon2))     
         {inner[anz1++] = k1->ursprung;}            /* Randknoten 3-valent */
      if (k1->invers->next) {k1 = k1->invers->next;} 
      else                  {k1 = k1->invers->prev;}
    } while (k1 != grundkante[i]);
  }
  /* Innere Knoten speichern: */
  anz2 = anz1;
  for (i=0; i<n; i++) {
    if (mark[m[i][0]->ursprung]==0)
       {inner[anz2++] = m[i][0]->ursprung;}   /* Knoten speichern */
  }
 
  /* Schritt 1a:  Feststellen, ob Flaeche mit sich selbst verklebt ist
     (da duerfen nicht nur die inneren Knoten - siehe Schritt 1b - 
      betrachtet werden, sondern es
      muessen auch die Kanten betrachtet werden, die zwei 3-valente Randknoten
      miteinander verbinden. Diese Kanten werden in Schritt 1a 
      betrachtet). */
  if (!facecon1) {
    for (i=0; i<anz1; i++) {      /* 3-valente Randknoten durchgehen */
      for (j=0; j<3; j++) {
        k1 = m[inner[i]-1][j];   /* inner[i] ist Randknoten */
        if (k1->connfl==k1->invers->connfl)
           /* beide "connfl"-Werte ungleich 0, da beide =0 nicht moeglich */
           {return(0);}
      }
    }
  }

  /* Schritt 1b:  feststellen, ob Zusammenhangszahl == 1 */
  for (i=anz1; i<anz2; i++) {      /* innere Knoten durchgehen */
    for (j=0; j<3; j++) {
      k1 = m[inner[i]-1][j];
      if (k1->connfl == k1->invers->connfl) {   /* gleiche Flaeche */
        if (!facecon1) {return(0);}          /* Patch aussortieren */
        if (genus_end==0 && facecon2) {return(1);} 
        if (genus_end==0 || (all_3_val(k1,mark) && (mark[k1->name]&2)==0))
           {connerg = 1;}
           /* Wichtig: Reihenfolge der Bedingungen */
           /* Dritte Bedingung: Knoten k1->name wird nicht erreicht, also 
              sind k1->ursprung und k1->name (==m[inner[i]-1][j]->ursprung) 
              nur durch k1 verbunden. */ 
        for (ii=0; ii<anz2; ii++) {mark[inner[ii]] &= 1;} 
                                     /* Sperren loeschen */
      }
    }
  }

  if (genus_end>0 && facecon2) {return(connerg);}
     /* Schritt 2 nicht mehr notwendig */

  /* Schritt 2:  feststellen, ob 2 Flaechen an 2 Kanten miteinander verklebt 
                 sind */
  if (genus_end==0 && connerg==2) {connerg = 3;}
  for (i=0; i<anz2; i++) {       /* gespeicherte Knoten durchgehen */
    for (j=0; j<3; j++) {        /* Kanten auswaehlen */
      k1 = m[inner[i]-1][j];
      if (k1->fl_rechts && k1->invers->fl_rechts) {     /* innere Kante */
        /*fl1 = k1->connfl;*/  fl2 = k1->invers->connfl;
        anz = 0;     /* Anzahl gemeinsamer Kanten von "fl1" und "fl2" */
        do {              /* an "fl1" und "fl2" angrenzende Kanten speichern */
          k1 = k1->invers->prev;
          if (k1->invers->connfl==fl2) {anz++;}
        } while (k1!=m[inner[i]-1][j]);
        if (anz>1) {    /* mehr als eine gemeinsame Kante */
          if (!facecon2) {return(0);}          /* Patch aussortieren */
          if (genus_end==0) {return(2);}      /* an dieser Stelle gilt: 
              "facecon2==True", sonst waere return(0) wirksam geworden */
        }
      }
    }
  }
  return(connerg);    /* nichts Gegenteiliges gefunden */
}
     
/*********************MARK_ALL***********************************************/
/*  Diese Funktion markiert aehnlich wie "all_3_val" alle Knoten, die 
    vom Knoten k->ursprung aus erreichbar sind. Die Funktion ist nur fuer
    komplette Karten konzipiert. Knoten, die bereits markiert sind,
    duerfen nicht ueberquert werden. Die Funktion arbeitet rekursiv. Die 
    Markierungen befinden sich im Array "mark".                             */
/*  Es gilt:  k->name braucht nicht untersucht zu werden, weil entweder die
    Rekursion von dort kommt oder der zugehoerige Ursprungsknoten nicht zu
    dem zu untersuchenden Bereich gehoert (oberste Rekursionsebene).        */
   
void mark_all(KANTE *k,BOOL *mark) {
  mark[k->ursprung] = True;
  if (!mark[k->prev->name]) {mark_all(k->prev->invers,mark);}
  if (!mark[k->next->name]) {mark_all(k->next->invers,mark);}
} 

/*************************GETCONN_MAP****************************************/
/* Aehnlich wie "getconn", aber ausschliesslich fuer komplette Karten
   konzipiert. Die Funktion liefert die Zusammenhangszahl in "connerg" 
   (Einschraenkungen siehe "getconn") und die Flaechenzusammenhangszahl in
   "faceconnerg". Diese wird eventuell bei der Erzeugung des dualen Codes
   benoetigt.                                                               */

void getconn_map(PLANMAP m, KNOTENTYP n, unsigned char *connerg, unsigned char
                 *faceconnerg) {
  static KANTE *k1;
  static KNOTENTYP i,j,ii;
  static KNOTENTYP anz;
  static KNOTENTYP fl2;   /* Nummer einer ausgewaehlten Flaeche */
  static BOOL mark[N_MAX_P+1];   /* Speicher fuer Knotenmarkierungen */
  
  *connerg = genus_end==0 ? 3 : 2;   *faceconnerg = 3;     /* vorerst */

  /* Schritt 1:  feststellen, ob Zusammenhangszahl == 1 */
  for (i=0; i<n; i++) {            /* Knoten durchgehen */
    for (j=0; j<3; j++) {
      k1 = m[i][j];
      if (k1->connfl == k1->invers->connfl) {      /* gleiche Flaeche */
        *faceconnerg = 1;
        if (genus_end==0) {*connerg = 1;}
        else {
          for (ii=1; ii<=n; ii++) {mark[ii] = False;}
          mark_all(k1,mark);
          if (!mark[k1->name]) {*connerg = 1;}
        }
        if (*connerg==1) {return;}      /* besser wird's nicht mehr */
      }
    }
  }
  if (/*genus_end>0 && */ *faceconnerg==1) {return;} 
     /* "faceconnerg==1", "connerg==2": besser wird's nicht mehr */

  /* es verbleibt der Fall "faceconnerg>1" (noch nichts gefunden) */
  /* Schritt 2:  feststellen, ob 2 Flaechen an 2 Kanten miteinander verklebt 
                 sind */
  for (i=0; i<n; i++) {   
    for (j=0; j<3; j++) {        /* Kanten auswaehlen */
      k1 = m[i][j];
      /*fl1 = k1->connfl;*/  fl2 = k1->invers->connfl;
      anz = 0;          /* Anzahl gemeinsamer Kanten von "fl1" und "fl2" */
      do {              /* an "fl1" und "fl2" angrenzende Kanten speichern */
        k1 = k1->invers->prev;
        if (k1->invers->connfl==fl2) {anz++;}
      } while (k1!=m[i][j]);
      if (anz>1) {    /* mehr als eine gemeinsame Kante */
        *faceconnerg = 2;    /* "faceconnerg==1" ist hier ausgeschlossen */
        *connerg = 2;        /* nur bei "genus_end==0" ist dieser Wert neu */
        return;           /* besser wird's nicht */
      }
    }
  }
}
     
/*************************DELANEYTEST****************************************/
/* Die Flaechentypen sind in drei nicht unbedingt disjunkte Mengen aufgeteilt.
   Die vorliegende Funktion prueft, ob an jedem Knoten eine Flaeche aus 
   jeder Menge anliegt. Bei inneren Knoten kann diese Aussage definitiv
   getroffen werden. Bei 3-valenten Randknoten kann die Frage verneint werden,
   wenn beide anliegenden Flaechen nur in einer Menge liegen. Bei 2-valenten
   Randknoten kann keine Aussage getroffen werden.                          */
/* Es gilt nicht unbedingt m[i-1][j]->ursprung==i (beim Isomorphietest
   koennen Veraenderungen auftreten), aber m[i-1][j]->ursprung ist gleich 
   fuer alle j.                                                             */
/* Weitere Kommentare siehe "getconn".                                      */

BOOL delaneytest(PLANMAP m, KNOTENTYP n, KANTE **grundkante, KNOTENTYP gklen) {
  static unsigned char ii;
  static KANTE *k1;
  static KNOTENTYP i,j;
  static KNOTENTYP inner[N_MAX_P/2];    /* Speicher fuer innere Knoten und
         3-valente Randknoten (N_MAX_P/2 genuegt, weil nur jeder zweite
         Knoten ein 3-valenter Randknoten sein kann. Jeder innere Knoten wiegt
         sogar das Dreifache eines 2-valenten Randknotens) */
  static KNOTENTYP anz1,anz2;   /* anz1 = Anzahl der gespeicherten 3-valenten 
      Randknoten, anz2 = anz1 + Anzahl der inneren Knoten */
  static KNOTENTYP anz;
  static KNOTENTYP fl2;   /* Nummer einer ausgewaehlten Flaeche */
  static unsigned char mark[N_MAX_P+1];  /* Speicher fuer Knotenmarkierungen */
         /* Bit 0:  es handelt sich um einen Randknoten */
         /* Bit 1:  der Knoten gilt als nicht erreichbar bzw. verarbeitet */

  /* Markierungen loeschen: */
  for (i=1; i<=n; i++) {mark[i] = 0;}
  anz1 = 0;

  /* Randknoten markieren und 3-valente Randknoten speichern: */
  for (i=0; i<gklen; i++) {     /* kein Durchlauf bei kompletten S3Z-Graphen */
    k1 = grundkante[i];
    do {
      mark[k1->ursprung] = 1;        /* 1 => Randknoten */
      if (k1->prev && k1->next) {inner[anz1++] = k1->ursprung;} 
         /* Randknoten 3-valent */
      if (k1->invers->next) {k1 = k1->invers->next;} 
      else                  {k1 = k1->invers->prev;}
    } while (k1 != grundkante[i]);
  }
  /* Innere Knoten speichern: */
  anz2 = anz1;
  for (i=0; i<n; i++) {
    if (mark[m[i][0]->ursprung]==0)
       {inner[anz2++] = m[i][0]->ursprung;}   /* Knoten speichern */
  }
 
  /* Schritt 1:  3-valente Randknoten und innere Knoten testen */
  for (i=0; i<anz2; i++) {      /* 3-valente Knoten durchgehen */
    for (j=0; j<3; j++) {
      k1 = m[inner[i]-1][j];
      if ((i>=anz1 || (k1->fl_rechts && k1->invers->fl_rechts)) &&   
           /* innere Kante */ 
          ((ii = dela_set[k1->fl_rechts] | dela_set[k1->invers->fl_rechts])==1
            || ii==2 || ii==4))     /* 2 Flaechen decken nur 1 Menge ab */
         {return(False);}  /* 3.Flaeche kann nicht mehr ausgleichen, sowohl bei
                              Randknoten als auch bei inneren Knoten */
    }
  }

  /* Schritt 2:  innere Knoten testen */
  for (i=anz1; i<anz2; i++) {      /* innere Knoten durchgehen */
    for (j=0; j<3; j++) {
      k1 = m[inner[i]-1][0];
      if ((dela_set[k1->fl_rechts] | dela_set[k1->invers->fl_rechts] | 
           dela_set[k1->next->fl_rechts]) != 7)  /* nicht alles abgedeckt */
         {return(False);}
    }
  }
  return(True);       /* Test bestanden */
}


/***************************************/
/* Funktionen fuer den Isomorphietest: */
/***************************************/

/*********************VERGLEICHE_ANGRENZENDE_FLAECHEN************************/
/*  Diese Funktion vergleicht die an zwei Petriepfaden angrenzenden Flaechen
    und gibt daraufhin eine Bewertung der Pfade ab.
    "pfad1" und "pfad2" sind die Anfangskanten der beiden Pfade. "sp1" und 
    "sp2" geben an, ob Pfad 1 bzw. Pfad 2 spiegelverkehrt zu durchlaufen ist.
    Die Pfade muessen gleichlang sein, naemlich beide "len" Kanten lang sein.
    Die Funktion gibt den Wert 1 zurueck, wenn Pfad 1 besser ist, im umge-
    kehrten Fall den Wert 2. Wenn beide Pfade gleich gut bewertet werden,
    gibt die Funktion den Wert 0 zurueck. */
/*  Konvention: erst werden die linken Flaechen, dann die rechten Flaechen
    miteinander verglichen (falls nicht spiegelverkehrt) */

char vergleiche_angrenzende_flaechen(KANTE *pfad1,KANTE *pfad2,BOOL sp1,
     BOOL sp2,KNOTENTYP len) {
  static KNOTENTYP i;     /* zurueckgelegte Wegstrecke */
  static FLAECHENTYP fl_l1,fl_l2,fl_r1,fl_r2;   /* die vier Flaechen, die
                                      jeweils am Vergleich beteiligt sind */
  i = 0;
  while (i<len) {
    if (sp1) {fl_l1 = pfad1->fl_rechts;    fl_r1 = pfad1->invers->fl_rechts;}
    else     {fl_l1 = pfad1->invers->fl_rechts;    fl_r1 = pfad1->fl_rechts;}
    if (sp2) {fl_l2 = pfad2->fl_rechts;    fl_r2 = pfad2->invers->fl_rechts;}
    else     {fl_l2 = pfad2->invers->fl_rechts;    fl_r2 = pfad2->fl_rechts;}
    if (fl_l1 != fl_l2)  {return(fl_l1<fl_l2 ? 1 : 2);}
    if (fl_r1 != fl_r2)  {return(fl_r1<fl_r2 ? 1 : 2);}    
    pfad1 = (i&1)!=sp1 ? pfad1->invers->next : pfad1->invers->prev;
    pfad2 = (i&1)!=sp2 ? pfad2->invers->next : pfad2->invers->prev;
    i++;
  }
  return(0);      /* keinen Unterschied festgestellt */
}

/***********************MARKIERE_PETRIEPFAD**********************************/
/*  Diese Funktion verfolgt von der Kante "k" ausgehend den Petriepfad im
    Graphen und numeriert alle auftretenden Kanten mit "farbe" (dies erfolgt im
    "all"-Element jeder Kante). Falls "links" den Wert True besitzt, geht
    die Funktion zuerst nach links ("spiegelverkehrt"), andernfalls nach rechts
    ("normal").
    An "pfadcode" gibt die Funktion die Bewertung des gefundenen Pfades
    zurueck und an "codelen" wird die Laenge dieses Bewertungscodes
    uebergeben.
    Die Funktion markiert alle Kanten, deren Fortsetzung zum selben Petriepfad
    fuehren wuerde wie der gerade markierte, als unbrauchbar. */
/*  An "f" uebergibt die Funktion einen Zeiger auf die erste Kante des
    Petriepfades, an "l" einen Zeiger auf das Inverse der letzten Kante
    (Startkante fuer die andere Richtung). */
/*  Die Richtung, die bei Kante i eingeschlagen wird (links oder rechts),
    ist die gleiche, die bei Kante -i in der entgegengesetzten Laufrichtung
    eingeschlagen wird. Das erspart Fallunterscheidungen, wenn die Lauf-
    richtung des Pfades umgedreht wird, um Kanonizitaet zu erreichen. */
/*  Der Rueckgabewert der Funktion ist "True", wenn die Richtung des Pfades
    allein aufgrund des Pfades selbst noch nicht eindeutig ist. */
/*  Falls der Pfad ein Sandwichpfad ist, so werden an "anfang" und "ende" die
    Werte von "anf" und "end" uebergeben. */
/*  Wichtig: Die nr-Eintraege in den Kanten des Graphen brauchen zu Beginn der
    Funktion NICHT gleich 0 zu sein (also kann z.B. eine Funktion wie 
    "drei_vierecke" aus CPF zuvor ohne Bedenken angewendet werden). */

BOOL markiere_petriepfad(KANTE *k,BOOL links,KNOTENTYP farbe,KNOTENTYP 
     *pfadcode,KNOTENTYP *codelen,KANTE **f,KANTE **l) {
  static KANTE *k2;           /* Laufvariable */
  static KANTE *first,*last;  /* Zeiger auf erste und letzte Kante des
    gefundenen Pfades, die zuletzt auch an "f" und "l" uebergeben werden. 
    Der Grund dafuer, dass nicht direkt die Variablen "f" und "l"  benutzt 
    werden, liegt darin, dass diese "nil" sein koennen. */
  static KNOTENTYP h,i;       /* Hilfsvariable */
  static KNOTENTYP lv,lr; /* zaehlt die Schritte mit (vorwaerts/rueckwaerts) */
  static KNOTENTYP l1,l2,l3;  /* Laengen der einzelnen Pfadteile, falls es sich
                                 beim Petriepfad nicht um Bauchbinde handelt */
  static EULERTYP nr;         /* fuer die Numerierung der einzelnen Kanten von
                                 der Ausgangskante aus gesehen */
  static BOOL sp;             /* True => gesamter Pfad ist spiegelverkehrt */
  static KNOTENTYP anf,end;   /* Anzahl der Kanten, die vom Anfang bzw. vom
                                 Ende des Pfades vorwaerts bzw. rueckwaerts
                       durchlaufen als Startkanten zum selben Pfad fuehren. */
  static BOOL erg;            /* Rueckgabewert */
                                
  /* zunaechst vorwaerts laufen: */
  k2 = k;   nr = 0;
  while (k2->all != farbe) {    /* Kreis ist noch nicht geschlossen */
    k2->all = k2->invers->all = farbe;
    k2->nr  = k2->invers->nr  = nr++;
    k2 = (nr&1)==links ? k2->invers->next : k2->invers->prev;
  }
  lv = (KNOTENTYP)nr;
  last = (nr&1)==links ? k2->prev : k2->next;    
          /* Schritt zurueck und umdrehen */
  
  /* nun rueckwaerts laufen: */
  k2 = links ? k->next->invers : k->prev->invers;   nr = -1;
  while (k2->all != farbe) {
    k2->all = k2->invers->all = farbe;
    k2->nr  = k2->invers->nr  = nr--;
    k2 = (nr&1)==links ? k2->next->invers : k2->prev->invers;
  }
  lr = (KNOTENTYP)(-nr)-1;
  first = (nr&1)==links ? k2->invers->prev : k2->invers->next;
  /* Schritt zurueck */
  

  /* Pfad analysieren: */
  if (lr==0 && (k->prev->all!=farbe || k->next->all!=farbe)) { 
    /* Bauchbinde gefunden */
    pfadcode[0] = bauchbindenkennung;      /* pfadcode fuer Bauchbinde */
    if (lv&1) {fprintf(stderr,"Logischer Fehler in markiere_petriepfad\n");
               exit(24);}
    pfadcode[1] = lv;           /* Laenge der Bauchbinde */
    *codelen = 2;
    last = first->invers;
    anf = end = lv;
    erg = True;
  }
  else if (first->prev->nr + first->next->nr < last->prev->nr 
           + last->next->nr) {    /* Brillenpfad */
    /* Addition der beiden "nr"-Werte, um Gleichheit auszuschliessen 
       (falls eine Kante in beiden Summen vorkommt) */
    pfadcode[0] = brillenkennung;       /* Kennzeichnung fuer Brillenpfad */
    l1 = (KNOTENTYP)(MAX(first->prev->nr,first->next->nr) - 
         first->nr);    /* erstes Brillenglas */
    l3 = (KNOTENTYP)(last->nr - MIN(last->prev->nr,last->next->nr));
         /* zweites Brillenglas */
    l2 = (KNOTENTYP)(MIN(last->prev->nr,last->next->nr) 
         - MIN(first->prev->nr,first->next->nr));    /* Mittelteil */
    if (l1>l3) {k2 = last;  last = first;  first = k2;  
                 h = l1;  l1 = l3;  l3 = h;}    
                /* der Pfad beginnt am kleineren Glas */
    pfadcode[1] = l1;          /* kleineres Glas */
    pfadcode[2] = l2;          /* Mittelteil */
    pfadcode[3] = l3;          /* groesseres Glas */
    *codelen = 4;
    anf = l1+l2+(l3&1);    end = l2+l3+(l1&1);
    erg = (l1==l3);  
  }
  else {                                              /* Sandwichpfad */
    pfadcode[0] = sandwichkennung;       /* Kennzeichnung fuer Sandwichpfad */
    l1 = (KNOTENTYP)(MAX(last->prev->nr,last->next->nr) - first->nr);
         /* erster Aussenteil (in Dokumentationsentwurf Laenge "3") */
    l2 = (KNOTENTYP)(MAX(first->prev->nr,first->next->nr) - 
                  MAX(last->prev->nr,last->next->nr)); /* Mittelteil */
    l3 = (KNOTENTYP)(last->nr - MIN(first->prev->nr,first->next->nr));
         /* zweiter Aussenteil (in Dokumentationsentwurf Laenge "1") */
    if (l1>l3) {k2 = last;  last = first;  first = k2;
                h = l1;  l1 = l3;  l3 = h;}
               /* der Pfad beginnt am kuerzeren Aussenteil */
    pfadcode[1] = l1;          /* kleinerer Aussenteil */
    pfadcode[2] = l2;          /* Mittelteil */
    pfadcode[3] = l3;          /* groesserer Aussenteil */
    *codelen = 4;
    anf = l1+((l2+l3)&1);   end = l3+((l1+l2)&1);
    erg = (l1==l3);  
  }

  /* Nun werden "anf" bzw. "end" Kanten als unbrauchbar markiert: */
  sp = (links != (first->nr & 1));    /* Ausrichtung des Pfades */
  k2 = first;
  for (i=0; i<anf; i++) {
    if ((i&1)==sp) {k2->pfadanfang = False;     k2 = k2->invers->prev;}
    else           {k2->sp_pfadanfang = False;  k2 = k2->invers->next;}
  }
  sp = (links != (last->nr & 1));    /* Ausrichtung des Pfades */
  k2 = last;
  for (i=0; i<end; i++) {
    if ((i&1)==sp) {k2->pfadanfang = False;     k2 = k2->invers->prev;}
    else           {k2->sp_pfadanfang = False;  k2 = k2->invers->next;}
  }
  if (f) {*f = first;}
  if (l) {*l = last;}
  return(erg);
}

/**************NUMERIERE_GRAPH_VOM_PFAD**************************************/
/*  Diese Funktion numeriert einen Graphen von der Kante "first" ausgehend.
    Dies ist die Anfangskante eines Pfades. Die Numerierung wird im alter-
    nativen Speicherplatz von "m" festgehalten. Der zugehoerige Planarcode
    wird an "graph" zurueckgegeben (dort muss ausreichend Speicherplatz
    vorhanden sein). Falls "sp==True", so wird spiegelverkehrt numeriert.   */
 
void numeriere_graph_vom_pfad(KANTE *first,BOOL sp,KNOTENTYP *graph,
     PLANMAP m,KNOTENTYP n) {
  loesche_numerierung2(m,n);
  if (sp) {n = numeriere_graph2_sp(m,first);} 
  else {n = numeriere_graph2(m,first);}
  if (doppelkanten) {map_2_embedcode2(m,graph,n);}
  else              {map_2_planarcode2(m,graph,n);}
}  
  
/*******************VERGLEICHE_PETRIEPFADE***********************************/
/*  Vergleicht zwei Pfade mit feststehenden Anfangskanten und gleichen
    Laengen. Auch die Pfadteile sind gleich lang. Wenn "beide_richtungen==
    True", so muss, wenn der Vergleich vom Anfang aus gesehen noch kein 
    eindeutiges Ergebnis bringt, auch noch der Vergleich mit dem
    Ende von Pfad 2 vorgenommen werden.                                     */
/*  "first1" ist die Anfangskante von Pfad 1, "first2" von Pfad 2. "last2"
    ist die Endkante von Pfad 2.                                            */
/*  "g1" ist der planar-Code des Graphen von "first1" aus gesehen.           */
/*  Der Graph ist in "m" gespeichert (die Referenznumerierung aus "g1" ist
    im Originalspeicherplatz gespeichert) und besitzt "n" Knoten.           */
/*  "is_g1" gibt an, ob "g1" sinnvolle Werte enthaelt oder erst noch
    berechnet werden muss. "len" ist die Laenge der Pfade.                  */
/*  "sp1" gibt an, ob Pfad 1 spiegelverkehrt verlaeuft, "sp2f" gibt an, ob
    Pfad 2 vom Anfang an durchlaufen spiegelverkehrt verlaeuft, "sp2l" gibt
    an, ob Pfad 2 vom Ende an durchlaufen spiegelverkehrt verlaeuft.        */
/*  "sp2l" und "last2" sind nur von Bedeutung, wenn beide_richtungen==True. */

BOOL vergleiche_petriepfade(KANTE *first1,KANTE *first2,KANTE *last2,BOOL sp1,
     BOOL sp2f,BOOL sp2l,KNOTENTYP *g1,PLANMAP m,KNOTENTYP n,
     BOOL beide_richtungen,KNOTENTYP len,BOOL *is_g1) {
  static KNOTENTYP g2[CODESIZE(N_MAX)];
  static signed char erg;                   /* Vergleichsergebnis */  

  if ((erg = vergleiche_angrenzende_flaechen(first1,first2,sp1,sp2f,len))==2)
     {return(False);}
  else if (erg==1) {return(True);}
  /* Falls beide_richtungen==True => Vergleich von "first1" und "last2"
     wuerde dasselbe Ergebnis bringen, da die Flaechensequenzen von "first2"
     und "last2" aus betrachtet dann gleichwertig sind. */

  /* ab hier gilt: erg==0 => Pfade mitsamt Sequenzen gleichwertig */
  if (!(*is_g1)) {
    if (doppelkanten) {map_2_embedcode(m,g1,n);}
    else              {map_2_planarcode(m,g1,n);}
    *is_g1 = True;
  } 
  /* Der Wert von "beide_richtungen" passt auch bei pfad1, da pfad1 und 
         pfad2 die gleiche Flaechensequenz haben. */
  numeriere_graph_vom_pfad(first2,sp2f,g2,m,n);
  erg = vergleiche_codes(g1,(POSTYP)CODESIZE(n),g2,(POSTYP)CODESIZE(n));
  if (erg > 0) {return(False);}
  if (beide_richtungen) {           /* andersherum auch codieren */
    numeriere_graph_vom_pfad(last2,sp2l,g2,m,n);
    erg = vergleiche_codes(g1,(POSTYP)CODESIZE(n),g2,(POSTYP)CODESIZE(n));
    if (erg > 0) {return(False);}
  }
  return(True);                     /* nichts Besseres gefunden */   
}
  
/*******************VERGLEICHE_BAUCHBINDENMENGE******************************/
/*  Diese Funktion vergleicht die Bauchbinde "pfad2" und alle sich hieraus
    ergebenden Pfade mit der Referenzbauchbinde "pfad1". Wenn es eine bessere
    findet, uebergibt sie "False", sonst "True". Der Pfad "pfad2" ist normal
    zu durchlaufen. "pfad2" kann gleich "pfad1->invers->next" sein. 
    "m", "n", und "g1" siehe "vergleiche_bauchbinden". 
    "pfad1" ist spiegelverkehrt. Die Laengen der Referenzbauchbinde und der 
    Vergleichsbauchbinden muessen gleich sein.                              */

BOOL vergleiche_bauchbindenmenge(KANTE *pfad1,KANTE *pfad2,KNOTENTYP *g1,
     PLANMAP m,KNOTENTYP n,KNOTENTYP len,BOOL *is_g1) {
  static KANTE *p;
  static char erg;

  /* zunaechst pfad2 normal durchlaufen: */
  p = pfad2;
  do {
    /* eindeutige Richtung im Pfad anhand der Flaechensequenzen festlegen: */
    erg = vergleiche_angrenzende_flaechen(p,p->invers,False,False,len);
    if (vergleiche_petriepfade(pfad1,erg==2 ? p->invers : p,erg==2 ? p : 
        p->invers,True,False,False,g1,m,n,erg==0,len,is_g1)==False)
          {return(False);}
    p = p->invers->prev->invers->next;
  } while (p!=pfad2);                /* einmal rundherum */  

  /* nun die spiegelverkehrten Pfade durchlaufen: */
  p = pfad2->invers->prev;
  do {
    if (p!=pfad1) {
      erg = vergleiche_angrenzende_flaechen(p,p->invers,True,True,len);
      if (vergleiche_petriepfade(pfad1,erg==2 ? p->invers : p,erg==2 ? p :
          p->invers,True,True,True,g1,m,n,erg==0,len,is_g1)==False)
            {return(False);}
    }
    p = p->invers->next->invers->prev;
  } while (p!=pfad2->invers->prev);   /* einmal rundherum */

  return(True);
}

/***************************BESTER_PETRIEPFAD********************************/
/*  Diese Funktion bildet aus allen Kanten der Karte Petriepfade.
    Diese Pfade werden mit dem Referenz-
    pfad, dessen Bewertung durch "pfadcode", "codelen" und dem Planarcode
    "g1" gegeben ist, verglichen. Falls sich ein besserer Pfad findet, wird 
    "False" zurueckgegeben, andernfalls "True". Die "all"-Werte in allen 
    Kanten des Graphen muessen <= 1 sein. "first" zeigt auf die erste Kante 
    des Originalpetriepfades, "sp" gibt an, ob der Pfad spiegelverkehrt 
    verlaeuft (muss bei Bauchbinde immer "True" sein). 
    Wenn "is_g1==True", so enthaelt "g1" bereits den
    korrekten Code, andernfalls muss er bei Bedarf erst noch uebergeben
    werden, und zwar aus "m". */

BOOL bester_petriepfad(KNOTENTYP *pfadcode,KNOTENTYP
     codelen,KANTE *first,BOOL sp,PLANMAP m,KNOTENTYP n,KNOTENTYP *g1,
     BOOL *is_g1) {
  static KNOTENTYP farbe;        /* fuer die Markierung eines Pfades */
  static POSTYP i,j;             /* fuer die betrachteten Kante */
  static KANTE *vglfirst, *vgllast, *h;    /* Endkanten eines Petriepfades */ 
  static KNOTENTYP vglcode[4];   /* fuer den betrachteten Petriepfad */
  static KNOTENTYP vgllen;       /* fuer den betrachteten Petriepfad */  
  static signed char erg;        /* Vergleichsergebnis               */
  static BOOL beide_richtungen;  /* Muss ein Pfad in beiden Richtungen 
                                    bewertet werden? */
  static KNOTENTYP dummy,len;    /* len = Pfadlaenge */
  static PLANMAP m2;             /* Sicherheitskopie der ANFAENGLICHEN
                                    Belegung */

  memcpy(m2,m,sizeof(KANTE *)*n*3L);   /* Es werden nacheinander die 
      Kanten der ANFAENGLICHEN Belegung durchgegangen. Auf diese Weise ist 
      sichergestellt, dass jede Kante genau einmal gewaehlt wird, denn
      "m" kann sich im Gegensatz zu "m2" veraendern. */

  farbe = 1;

  /* zunaechst nach rechts fortsetzen ("normal"): */
  for (i=0; i<n; i++) {
    for (j=0; j<3; j++) {
      if (m2[i][j]->pfadanfang==True) {  
        /* Petriepfad wurde noch nicht erzeugt */
        farbe++;
        beide_richtungen = markiere_petriepfad(m2[i][j],False,farbe,vglcode,
                             &vgllen,&vglfirst,&vgllast);
        if ((erg = vergleiche_codes(pfadcode,MIN(codelen,vgllen),vglcode,
                   MIN(codelen,vgllen))) > 0) {return(False);}
                 /* besseren Petriepfad gefunden: an beide Laengen muss das
                    Minimum der Laengen uebergeben werden, da sonst ein
                    BB-Pfad immer besser bewertet wird als ein anderer Pfad,
                    auch wenn man "priority" anders gesetzt hat. */
        else if (erg==0) {
          /* ab hier gilt:  Die Pfade sind vom Typ und von der Laenge gleich */

          if (pfadcode[0]==bauchbindenkennung) {            /* Bauchbinde */
            if (vergleiche_bauchbindenmenge(first,vglfirst,g1,m,n,
                pfadcode[1],is_g1)==False) {return(False);}
          }
          else {          /* Sandwich oder Brille */
            len = pfadcode[1]+pfadcode[2]+pfadcode[3];
            if (beide_richtungen) {
               /* neuer Versuch, die Richtung festzulegen */
              erg = vergleiche_angrenzende_flaechen(vglfirst,vgllast,
                    (vglfirst->nr & 1),(vgllast->nr & 1),len);
              if (erg==2) {h = vglfirst;  vglfirst = vgllast;  vgllast = h;}
                 /* pfadcode[2] und pfadcode[3] brauchen nicht vertauscht zu 
                  werden, denn sie sind gleich, wenn beide_richtungen==True. */
              beide_richtungen = (erg==0);
            }
            if (vergleiche_petriepfade(first,vglfirst,vgllast,sp,
                  (vglfirst->nr & 1),(vgllast->nr & 1),g1,m,n,beide_richtungen,
                  len,is_g1)==False)  {return(False);}      
          }
        }
      }
    }
  }
   
  /* nun nach links fortsetzen ("spiegelverkehrt"): */
  if (bauchbindenkennung>1 || pfadcode[0]!=bauchbindenkennung) {
     /* Alle Bauchbindenpfade sind bereits gefunden worden. Wenn also der
        Referenzpfad ein Bauchbindenpfad ist und ein Bauchbindenpfad die
        beste Bewertung bekommt, so kann kein besserer Pfad mehr gefunden
        werden. */
    for (i=0; i<n; i++) {
      for (j=0; j<3; j++) {
        if (m2[i][j]->sp_pfadanfang==True) {  
          /* Petriepfad wurde noch nicht erzeugt */
          farbe++;
          beide_richtungen = markiere_petriepfad(m2[i][j],True,farbe,vglcode,
                               &vgllen,&vglfirst,&vgllast);

          /* Bauchbinden sind alle abgegrast */
          /* if (vglcode[0]==bauchbindenkennung) {
            fprintf(stderr,"Logischer Fehler 2 in bester_pfad!\n"); exit(25);
          } */        

          if ((erg = vergleiche_codes(pfadcode,MIN(codelen,vgllen),vglcode,
                     MIN(codelen,vgllen))) > 0) {return(False);}  
          else if (erg==0) {
            len = pfadcode[1]+pfadcode[2]+pfadcode[3];
            if (beide_richtungen) {
              /* neuer Versuch, die Richtung festzulegen */
              erg = vergleiche_angrenzende_flaechen(vglfirst,vgllast,
                    (vglfirst->nr & 1)==0,(vgllast->nr & 1)==0,len); 
              if (erg==2) {h = vglfirst;  vglfirst = vgllast;  vgllast = h;}
              beide_richtungen = (erg==0);
            }
            if (vergleiche_petriepfade(first,vglfirst,vgllast,sp,
                  (vglfirst->nr & 1)==0,(vgllast->nr & 1)==0,g1,m,n,
                  beide_richtungen,len,is_g1)==False)  {return(False);}
          }
        }
      }
    }
  }
  return(True);
}
         

/*************************************************/
/* Funktionen fuer die Konstruktion von Patches: */
/*************************************************/

/***********************IS_MAXIMAL******************************************/
/*  Prueft einen Randcode auf Maximalitaet.                                */
/*  Der Randcode muss zweimal hintereinander im Speicher stehen.           */
/*  Falls der Randcode maximal ist, wird die Wiederholungszahl zurueck-
    gegeben, andernfalls eine Null.                                        */

KNOTENTYP is_maximal(KNOTENTYP *code,KNOTENTYP len) {
  static POSTYP i,j;       /* i = offset */
  static EULERTYP vgl;
  i = 1;
  while (i<(POSTYP)len) {
    j=0;
    while (j<(POSTYP)len) {  
      if ((vgl = (EULERTYP)(code[j]-code[i+j]))<0) {return(0);}
      else if (vgl>0) {j=len;}
      else {j++; if (j==len) {return(i);} }
    }
    i++;
  }
  return(len);
} 

/***********************MACHE_MAXIMAL***************************************/
/*  Verschiebt einen Randcode so, dass er maximal wird. Genaugenommen wird
    nur ein Offset auf eine Stelle im Randcode zurueckgegeben, so dass der
    Code von dort ab gelesen maximal ist. Deshalb muss der Randcode zweimal
    hintereinander im Speicher stehen. */

KNOTENTYP mache_maximal(KNOTENTYP *code,KNOTENTYP len) {
  static KNOTENTYP i,j;       /* i = offset. KNOTENTYP reicht, da i,j<len */
  static EULERTYP vgl;
  static KNOTENTYP anf;
  anf = 0;
  i = 1;
  while (i+anf<len) {
    j=0;
    while (j<len) {  
      if ((vgl = (EULERTYP)(code[j]-code[i+j]))<0) 
        {j = len;   code += i;   anf += i;   i = 0;}
      else if (vgl>0) {j = len;}
      else {j++; if (j==len) {return(anf);} }
    }
    i++;
  }
  return(anf);
} 

/*********MACHE_MAXIMAL_UND_ERMITTLE_WH************************************/
/*  Kombiation aus den Funktionen "mache_maximal" und "ermittle_wh".      */

KNOTENTYP mache_maximal_und_ermittle_wh(KNOTENTYP *code,KNOTENTYP len,
          KNOTENTYP *wh) {
  static KNOTENTYP i,j;       /* i = offset. KNOTENTYP reicht, da i,j<len */
  static EULERTYP vgl;
  static KNOTENTYP anf;
  anf = 0;
  i = 1;
  while (i+anf<len) {
    j=0;
    while (j<len) {  
      if ((vgl = (EULERTYP)(code[j]-code[i+j]))<0) 
        {j = len;   code += i;   anf += i;   i = 0;}
      else if (vgl>0) {j = len;}
      else {j++; if (j==len) {*wh = i;  return(anf);} }
    }
    i++;
  }
  *wh = len;
  return(anf);
} 

/***********************RANDLAENGE********************************************/
/*  Diese Funktion ermittelt die Laenge des durch die Werte code[anf] bis
    code[end] repraesentierten Randteils.                                    */

KNOTENTYP randlaenge(KNOTENTYP *randcode,KNOTENTYP anf,KNOTENTYP end) {
  static KNOTENTYP erg;
  erg = 0;
  while (anf<=end) {
    erg += (randcode[anf]<<1)+1;
    anf++;
  }
  return(erg);
}

/**********************ERMITTLE_WH*******************************************/
/*  Diese Funktion ermittelt die Wiederholungszahl (Periode) im uebergebenen
    Randcode.                                                               */

KNOTENTYP ermittle_wh(KNOTENTYP *code,KNOTENTYP len) {
  static KNOTENTYP i,j;    /* Knotentyp reicht, da Summe zweier KNOTENTYP-
                              Zahlen noch in KNOTENTYP passt */
                           /* i = offset */
  i = 1;                   /* Kandidat fuer Wiederholungszahl */
  while (i<len) {
    if (len%i==0) {        /* sonst unmoeglich */
      j=0;
      while (code[j]==code[j+i]) {
        if (j+i==len-1) {return(i);}    /* gesamter Randcode passt */
        j++;
      }
    }
    i++;
  }
  return(len);             /* keinen kleineren Kandidaten gefunden */
} 

/***********************VERKNUEPFE_RANDCODES**********************************/
/*  Ermittelt aus einem oder zwei Randcodes (Bruchkantencodes) einen oder zwei
    neue Randcodes und prueft den ersten auf Maximalitaet, falls test==True 
    (andernfalls ist Testergebnis unwichtig). */
/*  Der Ergebniscode wird fuer den Test zweimal hintereinander in den 
    Speicher geschrieben, deshalb muss dafuer genuegend Speicherplatz 
    vorhanden sein.                                                          */
/*  i und j sind die Drehungen der beiden beteiligten Raender.               */
/*  Es gilt immer: j2>j1, i2>i1, aber nach Modulorechnungen koennen die Werte
    gleich sein.                                                             */
/*  Falls art==EINSCHLUSS, so sind die Werte j, j2, len2 und randcode2 
    unwichtig (an "randcode2" muss "nil" uebergeben werden). 
    Falls art==VERBINDUNG, 
    so ist der Wert len2 wichtig (obwohl immer len2==len1)!                  */
/*  Die Werte ergcode2, erglen2 und jnr2 werden nur dann belegt, wenn Fall 1 
    vorliegt (art==VERBINDUNG). Es wird aber auch dann nur ergcode auf 
    Maximalitaet geprueft, nicht aber ergcode2. Desweiteren wird dann das 
    Array code2 nicht ausgelesen. "jnr2" erhaelt die kleinstmoegliche 
    Belegung des Elements e->j.nr.                                           */
/*  "nahtlen" und - bei Bedarf - "schleifenlen" enthalten die Laengen der
    Naht und der Schleife (bei Einschluss)                                   */

KNOTENTYP verknuepfe_randcodes(KNOTENTYP *randcode1,KNOTENTYP *randcode2,
          KNOTENTYP len1,KNOTENTYP len2,POSTYP i,POSTYP j,unsigned char art,
          KNOTENTYP *ergcode,KNOTENTYP *erglen,KNOTENTYP *ergcode2,
          KNOTENTYP *erglen2,KNOTENTYP *offset2,BOOL test,KNOTENTYP *jnr2,
          KNOTENTYP nahtlen,KNOTENTYP schleifenlen) {
  static POSTYP i2,j2;           /* Enden der Naehte */
  static KNOTENTYP code1[3*N_MAX_P],code2[3*N_MAX_P]; 
         /* Kopien der Randcodes */
         /*  ???? eventuell schneller durch Modulorechnung --- ausprobieren */
 
  /* Randcodes dreimal hintereinander kopieren, um Modulorechnung zu sparen: */
  memcpy(code1,randcode1,sizeof(KNOTENTYP)*len1);
  memcpy(&code1[len1],randcode1,sizeof(KNOTENTYP)*len1);
  memcpy(&code1[len1<<1],randcode1,sizeof(KNOTENTYP)*len1);
  if (randcode2) {
    memcpy(code2,randcode2,sizeof(KNOTENTYP)*len2);
    memcpy(&code2[len2],randcode2,sizeof(KNOTENTYP)*len2);
    memcpy(&code2[len2<<1],randcode2,sizeof(KNOTENTYP)*len2);
  }
  i += (POSTYP)len1-1;   j += (POSTYP)len2-1;    /* Anfaenge der Naehte */

  if (art==VERBINDUNG) {  
    /* Fall 1 --- Ein Rand wird mit sich selbst verklebt */
    i2 = i + 4 - (nahtlen&1);   j2 = j + 2 + (nahtlen&1);
    /* Rand 1: */
    if (i+(POSTYP)len1==j2 || i==j2) {      /* Bauchbinde */
      ergcode[0]=BB_KENNUNG;  ergcode[1]=code1[j2]+1;
      *erglen = 2;
    } 
    else {                             /* Bruchkantenrand */
      if (code1[i]!=0) {return(0);}    /* nicht erlaubte Markierung */
         /* vielleicht sollte diese Abfrage aus Zeitersparnisgruenden
            schon in der aufrufenden Funktion vorgenommen werden */
      ergcode[0] = code1[j2]+1;     /* im Prinzip + code1[i], aber der muss
                                       sowieso gleich 0 sein */
      *erglen = 1;
      if (j2>i) {i+=(POSTYP)len1;}      /* nun ist i groesser gleich j2 */ 
      j2++;
      if (j2<i)  {              /* es gibt Eintraege zu kopieren */ 
        memcpy(&ergcode[1],&code1[j2],sizeof(KNOTENTYP)*(size_t)(i-j2));
        *erglen += (KNOTENTYP)(i-j2);
      }
    }
    /* Rand 2: */
    if (j==i2 || j+(POSTYP)len1==i2) {      /* Bauchbinde */
      ergcode2[0]=BB_KENNUNG;  ergcode2[1]=code1[i2]+1;
      *erglen2 = 2;
    } 
    else {                          /* Bruchkantenrand */
      ergcode2[0] = code1[i2]+code1[j]+1;
      *erglen2 = 1;
      if (i2>j) {j+=(POSTYP)len2;}      /* nun ist j groesser gleich i2 */ 
      i2++;
      if (i2<j)  {              /* es gibt Eintraege zu kopieren */ 
        memcpy(&ergcode2[1],&code1[i2],sizeof(KNOTENTYP)*(size_t)(j-i2));
        *erglen2 += (KNOTENTYP)(j-i2);
      }
    }
    /* Rand 2 maximieren und Raender miteinander vergleichen: */
    if (test && *erglen2>*erglen) {return(0);}   
       /* Jetzt schon klar: zweiter Code besser als erster */
    if (test && !doppelkanten && ergcode2[0]==BB_KENNUNG && ergcode2[1]==1)
       {return(0);}    /* Doppelkante entdeckt */
    if (ergcode2[0]==BB_KENNUNG) {*offset2 = 0;  *jnr2 = 1;}
    else {
      memcpy(&ergcode2[*erglen2],ergcode2,sizeof(KNOTENTYP)*(*erglen2));
      *offset2 = mache_maximal(ergcode2,*erglen2);   /* 2.Code maximieren */
      *jnr2 = (*offset2==0) ? (code1[j]<<1)+1 : randlaenge(code1,
              j - (ermittle_wh(ergcode2,*erglen2) - *offset2),j);
              /* alle Parameter >= 0 */
    }
    if (test && *erglen==*erglen2 && 
        vergleiche_codes(ergcode,*erglen,&ergcode2[*offset2],*erglen2)<0) 
       {return(0);}
        /* zweiter Code ist besser als der erste */
        /* Erster Code braucht nicht maximiert zu werden, denn wenn er nicht
           maximal ist, dann wird spaeter sowieso 0 zurueckgegeben. */
  }

  else if (art==DURCHSCHNITT) {             /* Durchschnitt */
    i2 = i + 4 - (nahtlen&1);   j2 = j + 2 + (nahtlen&1);
    if (len1+len2==6) {         /* Es entsteht Bauchbinde */ 
      ergcode[0]=BB_KENNUNG;  ergcode[1]=code2[j2]+code1[i2]+2;  
      *erglen = 2;
    }
    else {  
      ergcode[0] = (j+(POSTYP)len2==j2) ? 2+code2[j2]+code1[i2] : 1+code2[j2];
      *erglen=1;
      if (j+(POSTYP)len2!=j2) {
        j2++;
        if (j2<j+(POSTYP)len2) {memcpy(&ergcode[1],&code2[j2],
                                       sizeof(KNOTENTYP)*(size_t)(j+len2-j2));}
        *erglen += j+(POSTYP)len2-j2;
        ergcode[(*erglen)++] = code2[j]+1+code1[i2];
      }
      i2++;
      if (i2<i+(POSTYP)len1) {memcpy(&ergcode[*erglen],&code1[i2],
                                     sizeof(KNOTENTYP)*(size_t)(i+len1-i2));}
      *erglen += i+(POSTYP)len1-i2;
    }
  }

  else {                        /* Einschluss */
    i2 = i + 4 + (schleifenlen&1);
    if (i+(POSTYP)len1==i2) {           /* es entsteht Bauchbinde */
      ergcode[0]=BB_KENNUNG;  ergcode[1]=code1[i2]+1;
      *erglen = 2;
    }
    else {
      ergcode[0] = code1[i2]+1;
      *erglen = 1;
      i2++;
      if (i2<i+(POSTYP)len1) {memcpy(&ergcode[1],&code1[i2],
                                     sizeof(KNOTENTYP)*(size_t)(i+len1-i2));}  
      *erglen += i+(POSTYP)len1-i2;
    }
  }

  if (test) {             /* Tests durchfuehren */
    if (*erglen>2 || (*erglen==2 && ergcode[0]!=BB_KENNUNG)) {
      /* keine Bauchbinde und min. 2 Bruchkanten => Maximalitaet pruefen */
      memcpy(&ergcode[*erglen],ergcode,sizeof(KNOTENTYP)*(*erglen));
      return(is_maximal(ergcode,*erglen));
    }
    else if (!doppelkanten && ergcode[0]==BB_KENNUNG && ergcode[1]==1)  
      {return(0);}    /* Doppelkante am Rand (nur bei Einschluss moeglich) */
  }
  return(2);     /* Kein Test erforderlich. 2 ist gleichzeitig die 
                    Wiederholungszahl eines BB-Randes */
}

/*********************ERMITTLE_ANZ_BB***************************************/
/*  Diese Funktion ermittelt die Anzahl der Bauchbindenraender in einem 
    Patch.                                                                 */

KNOTENTYP ermittle_anz_bb(KNOTENTYP *code) {
  static KNOTENTYP i,erg;
  erg = 0;
  for (i=1; i<=code[0]; i++) {if (code[code[i]]==BB_KENNUNG) {erg++;} }
  return(erg);
}

/*********************PASST_ANZ_BB******************************************/
/*  Ein Patch mit mehr als 2 Bauchbindenraendern ist unbrauchbar.
    Ein Patch mit 2 Bauchbindenraendern und einem weiteren Rand ist 
    unbrauchbar. Ein Patch mit 2 Bauchbindenraendern ungleicher Laenge ist
    unbrauchbar. Die Funktion gibt zurueck, ob der Patch aufgrund der 
    Anzahl von Bauchbindenraendern brauchbar ist.                          */

BOOL passt_anz_bb(KNOTENTYP *code) {
  static KNOTENTYP erg;
  erg = ermittle_anz_bb(code);
  return(erg<2 || (erg==2 && code[0]==2 && code[5]==code[7]));
}

/***********SPEICHERE_GK_NUMERIERUNG*****************************************/
/* Diese Funktion speichert die Numerierung der an den Grundkanten 
   beteiligten Knoten in der Form (nr->pos) im Array "gknum" ab. Zeiger auf 
   die "anz" Grundkanten befinden sich im Array "gk".                       */ 
/* Die Grundkante mit der Nummer "ausnahme" wird nicht beruecksichtigt, da
   sie durch eine andere Grundkante (im selben Rand) ersetzt worden sein
   kann. Sowohl das Original als auch der Ersatz sind aber sowieso mit 1->2
   numeriert (siehe aufrufende Funktion).                                   */

void speichere_gk_numerierung(KANTE **gk,KNOTENTYP anz,BORDERPOS *gknum,
     KNOTENTYP ausnahme) {
  static KNOTENTYP i,jj,ii;
  static BORDERPOS h;
  static BOOL vertauscht;
  ii = 0;
  for (i=0; i<anz; i++) {
    if (i!=ausnahme) {gknum[ii].nr = gk[i]->ursprung;   
                      gknum[ii].pos = gk[i]->name;  ii++;}
  }
  /* Nun anz-1 Eintraege aufsteigend sortieren (Bubblesort): */
  vertauscht = True;     /* mindestens eine Runde durchlaufen */
  for (jj=1; jj<anz-1 && vertauscht; jj++) {    /* Anfang des Suchbereichs */
    vertauscht = False;
    for (ii=anz-2; ii>=jj; ii--) {       /* Vergleichsstelle */
      if (gknum[ii-1].nr > gknum[ii].nr ||
          (gknum[ii-1].nr==gknum[ii].nr && gknum[ii-1].pos > gknum[ii].pos)) {
        h = gknum[ii];  gknum[ii] = gknum[ii-1];  gknum[ii-1] = h;      
        vertauscht = True;
      }
    }
    /* nun steht der beste Code vorn (an der Stelle jj-1) */
  }  
}  

/***********************SORTIERE_RANDCODES*********************************/
/*  Diese Funktion bildet einen durch das Verkleben eines oder zweier 
    Raender entstehenden Bordercode aus seinen Vorgaengercodes, indem es
    den/die durch die Verklebung entstehenden Randcode(s) an die passende
    Stelle im Bordercode einsortiert. 
    Der entstehende Bordercode wird an "ergcode" und "erglen" uebergeben.
    "code1" enthaelt den ersten Vorgaengercode, "code2" den
    zweiten (bei Fall 1 ohne Bedeutung). Falls Fall 1 vorliegt, so enthaelt
    "fall1" den Wert "True". "nr1" und "nr2" enthalten die Nummern der
    Raender in dem/den Vorgaengerpatch(es), die miteinander verklebt werden.
    "code3/len3" und "code4/len4" (letztere nur bei Fall 1) enthalten den/die
    Randcode(s), der/die bei der Verklebung entsteht/entstehen. Bei Fall 1 
    erhaelt "r2" die Position, an der "code4" einsortiert wurde. */
/*  "gk1" und "gk2" enthalten die Arrays mit den Grundkanten der zu "code1"
    und "code2" (falls vorhanden) gehoerenden Patches oder nil, wenn die
    Arrays nicht gebraucht werden. Die Laengen der Arrays
    gehen aus "code1[0]" und "code2[0]" hervor. Mitsamt den Randcodes werden
    auch die Grundkanten neu sortiert und an "erggk" uebergeben, sofern 
    "erggk" auf ein Array zeigt. Das erste Element von "erggk" wird nicht 
    angetastet (es wird in der uebergeordneten Funktion gesetzt). Falls Fall 1
    vorliegt, so wird an "fall1gk" die Grundkante des Randes uebergeben, der
    von "code4" repraesentiert wird. */   
/*  Falls test==True, so wird geprueft, ob der neue Randcode "code3" der
    beste im gesamten Bordercode ist und ob die erlaubte Anzahl Bauchbinden-
    raender eingehalten wird. In dem Fall wird "True" zurueckgegeben.
    Andernfalls wird NICHT der gesamte Bordercode berechnet und zurueckgegeben.
    Der Vergleich zweier gleicher Randcodes anhand der planar_codes erfolgt
    erst unmittelbar vor dem Abspeichern der Patches, da der Test von Patch zu
    Patch verschieden ausgehen kann. 
    Es wird immer vorausgesetzt, dass nach der Verklebung noch ein Rand 
    uebrigbleibt. */
/*  Falls fall1==True => nr2, code2, gk2 ohne Bedeutung,
    falls fall1==False => code4, len4, fall1gk ohne Bedeutung.   
    Falls code2==nil (nur ein Vorgaengerpatch) => len2, pos2, gk2 ohne 
    Bedeutung. */

BOOL sortiere_randcodes(KNOTENTYP nr1,KNOTENTYP nr2,BOOL fall1,KNOTENTYP
     *code1,KNOTENTYP *code2,KNOTENTYP
     *code3,KNOTENTYP len3,KNOTENTYP *code4,KNOTENTYP len4,KNOTENTYP 
     *ergcode,BOOL test,KANTE **gk1,KANTE **gk2,
     KANTE **erggk,KANTE *fall1gk,KNOTENTYP *r2) {
  static KNOTENTYP pos1,pos2;    /* Anzahl der bereits verarbeiteten Raender
                                    in den beiden Bordercodes */
  static KNOTENTYP pos3;         /* Anzahl der bereits verarbeiteten Raender
                                    im Zielcode */
  static KNOTENTYP erglen;       /* Laenge des erzeugten Bordercodes
                                    (Zwischenstaende) */
  static KNOTENTYP ref;  /* bester (verbleibender) Randcode:
                            0 = neuer Rand ist einziger Rand => kein Test, 
                            1 = erster Randcode in code1,
                            2 = zweiter Randcode in code1,
                            3 = dritter Randcode in code1,
                            4 = erster Randcode in code2,
                            5 = zweiter Randcode in code2 */
  static KNOTENTYP i,j;
  
  /* Test: Teil 1 gleich zu Beginn, da eventuell uebrige Arbeit entfaellt */
  if (test) {               /* code3 vergleichen */
    /* besten verbleibenden Randcode unter den bisherigen Randcodes finden: */
    if (fall1) {
      if (code1[0]==1) {ref=0;}
      else {ref = (nr1==0) ? 2 : 1;}
    }
    else if (code2) {       /* zwei Vorgaengerpatches */
      if (code1[0]==1 && code2[0]==1) {ref=0;}
      else if (code1[0]==1) {ref = (nr2==0) ? 5 : 4;}
      else if (code2[0]==1) {ref = (nr1==0) ? 2 : 1;}
      else {     /* Von jedem Patch bleibt mindestens ein Rand uebrig */
        i = (nr1==0);   j = (nr2==0);
        /* nun sind Code i in Patch 1 und Code j in Patch 2 die besten 
           verbleibenden Randcodes */
        if (vergleiche_codes(&code1[code1[i+1]],code1[i+2]-code1[i+1],
                             &code2[code2[j+1]],code2[j+2]-code2[j+1])>=0)
             {ref = i+1;}
        else {ref = j+4;}
      }
    }
    else {                  /* ein Vorgaengerpatch */
      if (code1[0]==2) {ref=0;}
      else if (nr1==0) {ref = (nr2==1) ? 3 : 2;}
      else if (nr2==0) {ref = (nr1==1) ? 3 : 2;}
      else {ref = 1;}
    }
    if (ref>3) {
      if (vergleiche_codes(code3,len3,&code2[code2[ref-3]],
          code2[ref-2]-code2[ref-3])<0) {return(False);}
    }
    else if (ref>0) {
      if (vergleiche_codes(code3,len3,&code1[code1[ref]],
          code1[ref+1]-code1[ref])<0) {return(False);}
    }
  }      /* if test */

  /* Nun neuen Bordercode berechnen: */
  ergcode[0] = fall1 ? code1[0]+1 : (code2 ? code1[0]+code2[0]-1 : code1[0]-1);
               /* Anzahl der Raender */
  erglen = ergcode[1] = ergcode[0]+2;     /* Hier beginnen die Randcodes */
  memcpy(&ergcode[erglen],code3,sizeof(KNOTENTYP)*(size_t)len3);    
        /* code3 ist der beste */
  erglen += len3;
  pos1 = pos2 = 0;    pos3 = 1;

  if (fall1) {
    /* Bei Fall 1 hat pos2 folgende Bedeutung: Sobald code4 kopiert werden 
       soll, bekommt pos2 den Wert 1, vorher ist der Wert 0. */
    do {   /* Schritt 1:  Randcodes kopieren, die besser sind als code4 */
      if (pos1==nr1) {pos1++;}         /* verklebten Rand ueberspringen */
      if (pos1<code1[0]) {      /* es sind noch Raender in code1 uebrig */
        if (vergleiche_codes(&code1[code1[pos1+1]],
                             code1[pos1+2]-code1[pos1+1],code4,len4)>0) {
          if (erggk) {erggk[pos3] = gk1[pos1];}
          ergcode[++pos3] = erglen;
          memcpy(&ergcode[erglen],&code1[code1[pos1+1]],(size_t)
                 (code1[pos1+2]-code1[pos1+1])*sizeof(KNOTENTYP));
          erglen += code1[pos1+2]-code1[pos1+1];     /* Codelaenge */      
          pos1++;
        }
        else {pos2 = 1;}    /* bei gleichen Randcodes wird code4 bevorzugt */
      }
    } while (pos2==0 && pos1<code1[0]);
    /* Schritt 2:  code4 kopieren */
    if (erggk) {erggk[pos3] = fall1gk;}
    *r2 = pos3;     /* Nummer von code4 in der Liste der Raender */
    ergcode[++pos3] = erglen;
    memcpy(&ergcode[erglen],code4,sizeof(KNOTENTYP)*(size_t)len4);
    erglen += len4;
    do {   /* Schritt 3:  Randcodes kopieren, die schlechter sind als code4 */
      if (pos1==nr1) {pos1++;}         /* verklebten Rand ueberspringen */
      if (pos1<code1[0]) {      /* es sind noch Raender in code1 uebrig */
        if (erggk) {erggk[pos3] = gk1[pos1];}
        ergcode[++pos3] = erglen;
        memcpy(&ergcode[erglen],&code1[code1[pos1+1]],(size_t)
               (code1[pos1+2]-code1[pos1+1])*sizeof(KNOTENTYP));
        erglen += code1[pos1+2]-code1[pos1+1];     /* Codelaenge */      
        pos1++;
      }
    } while (pos1<code1[0]);
    ergcode[++pos3] = erglen;         /* Ende-Kennzeichen */
  }      /* if fall1 */

  else if (code2) {               /* zwei Vorgaengerpatches */
    do {      /* Schritt 1:  Randcodes nach vorherigem Vergleich kopieren */
      if (pos1==nr1) {pos1++;}    /* verklebten Rand ueberspringen */
      if (pos2==nr2) {pos2++;}    /* verklebten Rand ueberspringen */
      if (pos1<code1[0] && pos2<code2[0]) {    /* noch Reste uebrig */
        if (vergleiche_codes(&code1[code1[pos1+1]],code1[pos1+2]-code1[pos1+1],
                             &code2[code2[pos2+1]],code2[pos2+2]-code2[pos2+1])
            >=0) {
          if (erggk) {erggk[pos3] = gk1[pos1];}
          ergcode[++pos3] = erglen;
          memcpy(&ergcode[erglen],&code1[code1[pos1+1]],(size_t)
                 (code1[pos1+2]-code1[pos1+1])*sizeof(KNOTENTYP));
          erglen += code1[pos1+2]-code1[pos1+1];     /* Codelaenge */      
          pos1++;
        }
        else {
          if (erggk) {erggk[pos3] = gk2[pos2];}
          ergcode[++pos3] = erglen;
          memcpy(&ergcode[erglen],&code2[code2[pos2+1]],(size_t)
                 (code2[pos2+2]-code2[pos2+1])*sizeof(KNOTENTYP));
          erglen += code2[pos2+2]-code2[pos2+1];     /* Codelaenge */      
          pos2++;
        }
      }
    } while (pos1<code1[0] && pos2<code2[0]);
    /* Schritt 2:  Rest kopieren */
    while (pos1<code1[0]) {      /* Rest von code1 kopieren, falls vorhanden */
      if (pos1==nr1) {pos1++;}   /* verklebten Rand ueberspringen */
      if (pos1<code1[0]) {       /* noch Reste uebrig */
        if (erggk) {erggk[pos3] = gk1[pos1];}
        ergcode[++pos3] = erglen;
        memcpy(&ergcode[erglen],&code1[code1[pos1+1]],(size_t)
               (code1[pos1+2]-code1[pos1+1])*sizeof(KNOTENTYP));
        erglen += code1[pos1+2]-code1[pos1+1];     /* Codelaenge */      
        pos1++;
      }
    }
    while (pos2<code2[0]) {      /* Rest von code2 kopieren, falls vorhanden */
      if (pos2==nr2) {pos2++;}   /* verklebten Rand ueberspringen */      
      if (pos2<code2[0]) {
        if (erggk) {erggk[pos3] = gk2[pos2];}
        ergcode[++pos3] = erglen;
        memcpy(&ergcode[erglen],&code2[code2[pos2+1]],(size_t)
               (code2[pos2+2]-code2[pos2+1])*sizeof(KNOTENTYP));
        erglen += code2[pos2+2]-code2[pos2+1];     /* Codelaenge */      
        pos2++;
      }
    }
    ergcode[++pos3] = erglen;         /* Ende-Kennzeichen */
  }        /* if code2 */

  else {         /* ein Vorgaengerpatch */
    /* nur 1 Schritt: alle Raender bis auf die beiden beteiligten kopieren */
    do {
      while (pos1==nr1 || pos1==nr2) {pos1++;}
      if (pos1<code1[0]) {
        if (erggk) {erggk[pos3] = gk1[pos1];}
        ergcode[++pos3] = erglen;
        memcpy(&ergcode[erglen],&code1[code1[pos1+1]],(size_t)
               (code1[pos1+2]-code1[pos1+1])*sizeof(KNOTENTYP));
        erglen += code1[pos1+2]-code1[pos1+1];     /* Codelaenge */      
        pos1++;
      }
    } while (pos1<code1[0]);
    ergcode[++pos3] = erglen;         /* Ende-Kennzeichen */
  }    /* else */

  /* Test Teil 2:  Anzahl der Bauchbinden ueberpruefen */
  return(!test || passt_anz_bb(ergcode));
}

/********************SORTIERE_RANDCODES2**************************************/
/*  Diese Funktion sortiert den bereits vorsortierten Bordercode "code"
    eines Patch weiter,
    indem sie bei gleichen Randcodes die Planarcodes von den zugehoerigen
    Grundkanten aus zu Hilfe nimmt. Die Grundkanten sind in "gk" enthalten.
    Der Patch ist bereits konstruiert. Die Grundkanten werden an "gk" 
    uebergeben. 
    Da angenommen wird, dass der erste Rand der beste ist, wird dieser nicht
    mitsortiert.  */
/*  Falls der Patch durch Fall 1 entstanden ist, so enthaelt "nr2" die Nummer 
    des Randes, der die Rolle von Rand 2 spielt.
    Falls dieser verschoben wird, so veraendert sich auch der Inhalt von 
    "nr2".  */

void sortiere_randcodes2(KNOTENTYP *code,KANTE **gk,KNOTENTYP *nr2) {
  static PLANMAP m; 
  static KNOTENTYP planarcode[G_MAX][CODESIZE_MAX_P]; 
         /* fuer Planarcodes von jeder Grundkante aus gesehen, G_MAX reicht,
            da erster Rand nie codiert wird */
  static BORDERPOS gknum[G_MAX][G_MAX];       /* Zur Speicherung der 
         Numerierung der Grundkanten (von jeder Grundkante aus gesehen): 
         "nr" enthaelt die Nummer des Ursprungs,
         "pos" die des Ziels. G_MAX in der zweiten Dimension reicht, 
         da jeweils eine Grundkante nicht beruecksichtigt wird. G_MAX in der
         ersten Dimension reicht, da erster Rand nie codiert wird. */
  static KNOTENTYP zeiger[G_MAX];   /* damit beim Vertauschen von Raendern
         nicht die gesamten Codes umkopiert werden muessen */
  static KNOTENTYP h,i,j,ii,jj;  
  static KANTE *hh;
  static size_t size;       /* bei allen zu vergleichenden Codes gleich */
  static KNOTENTYP n;
  static BOOL vertauscht;   /* fuer Bubblesort */
  static signed char erg;

  for (i=1; i+1<code[0]; i+=j) {
    j = 1;              /* Codes i und i+j vergleichen */
    while (i+j<code[0] && vergleiche_codes(&code[code[i+1]],
           (POSTYP)(code[i+2]-code[i+1]),
           &code[code[i+j+1]],(POSTYP)(code[i+j+2]-code[i+j+1]))==0) {
      n = numeriere_graph(m,gk[i+j]); 
      speichere_gk_numerierung(gk,code[0],gknum[i+j-1],i+j);
      size = doppelkanten ? patchmap_2_embedcode(m,planarcode[i+j-1],n) :
                            patchmap_2_planarcode(m,planarcode[i+j-1],n);
      loesche_patchnumerierung(m,n);
      zeiger[i+j-1]  = i+j;       /* Speicherplatz i+j-1 enthaelt Code i+j */
      j++;
    }
    if (j>1) {       /* => Patch ist numeriert worden */
      /* Rand "i" codieren */  
      n = numeriere_graph(m,gk[i]);  
      speichere_gk_numerierung(gk,code[0],gknum[i-1],i);
      size = doppelkanten ? patchmap_2_embedcode(m,planarcode[i-1],n) :
                            patchmap_2_planarcode(m,planarcode[i-1],n);
      loesche_patchnumerierung(m,n);
      zeiger[i-1] = i;              /* Speicherplatz i-1 enthaelt Code i */
      /* nun Codes "i" bis "i+j-1" vergleichen (Bubblesort): */
      vertauscht = True;     /* mindestens eine Runde durchlaufen */
      for (jj=1; jj<j && vertauscht; jj++) {    /* Anfang des Suchbereichs */
        vertauscht = False;
        for (ii=j-1; ii>=jj; ii--) {       /* Vergleichsstelle */
          if ((erg = vergleiche_codes(planarcode[zeiger[i+ii-2]-1],size,
                     planarcode[zeiger[i+ii-1]-1],size))==-1 || erg==0) {
            if (erg==0) {
              /* Die gesamten Codes sind gleich, also liegt ein Automorphismus
                 vor. Nun wird untersucht, ob der Automorphismus auch die 
                 Grundkanten aufeinander abbildet. */ 
              if (bo_memcmp(gknum[zeiger[i+ii-2]-1],gknum[zeiger[i+ii-1]-1],
                  code[0]-1)<0) {erg = -1;}   
                 /* => vertauschen */
            }
            if (erg==-1) {  /* entweder sofort oder durch 2.Test nach erg==0 */
              h = zeiger[i+ii-2];  zeiger[i+ii-2] = zeiger[i+ii-1];
              zeiger[i+ii-1] = h;  /* Codes + Grundkantenarrays vertauschen */
              hh = gk[i+ii-1];   gk[i+ii-1] = gk[i+ii];  gk[i+ii] = hh;
                                      /* Grundkanten vertauschen */
              if (nr2) {
                if (*nr2 == i+ii-1) {*nr2 = i+ii;}
                else if (*nr2 == i+ii) {*nr2 = i+ii-1;}  /* "nr2" angleichen */
              }
              vertauscht = True;
            }
          }
        }
        /* nun steht der beste Code vorn (an der Stelle i+jj-1) */
      }  
    }  
  }     /* for */
}
   
/***********************KONSTRUIERE_N_ECK**********************************/
/*  - im Kantenarray ("pos" ist das erste freie Element im Array)         */
/*  - alle Knotennummern werden auf 0 gesetzt                             */
/*  - n>=1                                                                */
/*  - an "bordercode" wird der Code des Randes uebergeben                 */
/*  - "connfl": Nummer, mit der die Flaeche gekennzeichnet wird           */

void konstruiere_n_eck(FLAECHENTYP n, KANTENARRAY map, POSTYP pos,
                       KNOTENTYP *bordercode,KNOTENTYP connfl) {
  static KNOTENTYP defaultbordercode[32] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                                            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
  static KNOTENTYP j;
  static FLAECHENTYP k;
  j = pos;   
  for (k=0; k<n; k++) {               /* Kanten einrichten */
    memcpy(&map[j],&defaultkante,sizeof(KANTE));
    memcpy(&map[j+1],&defaultkante,sizeof(KANTE));
    map[j].prev = &map[j+1];
    map[j+1].next = &map[j];
    map[j].next = map[j+1].prev = nil;
    map[j+1].connfl = connfl;
    map[j+1].fl_rechts = n;
    /* die anderen fl_rechts-Elemente werden nicht initialisiert,
       da sie nie gebraucht werden */ 
    /*  Das Element "nr" braucht nicht initialisiert zu werden, da nur die
        Elemente ausgelesen werden, die zuvor innerhalb der Funktion
        "markiere_petriepfad" initialisiert wurden. */
    j+=2;
  }
  j = pos;
  for (k=0; k<n-1; k++) {             /* Kanten verknuepfen */
    map[j+1].invers = &map[j+2];
    map[j+2].invers = &map[j+1];
    j+=2;
  }
  map[j+1].invers = &map[pos];
  map[pos].invers = &map[j+1];

  bordercode[0] = 1;
  bordercode[1] = 3;
  bordercode[2] = (KNOTENTYP)n+3;
  if (n>32) {bordercode+=3;  for (k=3; k<n+3; k++) {*(bordercode++) = 0;} }
  else {memcpy(&bordercode[3],defaultbordercode,sizeof(KNOTENTYP)*n);}
  /* Laenge des Codes braucht nicht zurueckgegeben zu werden, da immer = n+3 */
  /* Neuer Wert von "pos" braucht nicht zurueckgegeben zu werden, da immer
     += 2*n */
} 

/************************SUCHE_NAHT*****************************************/
/*  Uebergibt die Bruchkante, die sich vor dem durch "pos" bestimmten Kanten-
    zug befindet. k ist die Grundkante. "Code" enthaelt den Randcode.      */

KANTE *suche_naht(KNOTENTYP *code,KNOTENTYP pos,KANTE *k) {
  static int i,j;        /* i = Teil der Border, der uebersprungen wird */
  i = 0;
  while (i<pos) {             /* einen Teil der Border ueberspringen */
    for (j=0; j<code[i]; j++) {k = k->invers->next->invers->prev;}
    k = k->invers->prev;      /* break-edge ueberspringen */
    i++;
  }
  k = k->next->invers;   /* einen Schritt zurueck */
  return(k);
}
  
/************************SUCHE_KANTE****************************************/
/*  Durchlaeuft "pos" Randkanten gegen den Uhrzeigersinn.
    Fuer Fall 1:  Uebergibt die Grundkante im zweiten Rand. Entweder:
    "k" ist die von der Funktion "mache_verknuepfung" uebergebene Kante und 
    "pos" der Abstand zwischen "k" und der Grundkante gegen den Uhrzeigersinn
    (= Abstand zwischen Endpunkt der Naht und markiertem Knoten).
    Oder: "k" ist eine Grundkante (von Rand 2) und "pos" der Abstand zur 
    naechstmoeglichen Grundkante (Periodenlaenge).                         */
 
KANTE *suche_kante(KNOTENTYP pos,KANTE *k) {
  while (pos>0) {
    if (k->prev) {k = k->prev->invers;} else {k = k->next->invers;}
    pos--;
  }
  return(k);
}
  
/************************SUCHE_KANTE2****************************************/
/*  Wie suche_kante, aber die Suche fuehrt von Kante "k" aus im Uhrzeigersinn
    weiter. "k" zeigt im Uhrzeigersinn.                                     */
 
KANTE *suche_kante2(KNOTENTYP pos,KANTE *k) {
  while (pos>0) {
    if (k->invers->next) {k = k->invers->next;} else {k = k->invers->prev;}
    pos--;
  }
  return(k);
}
  
/*********************MACHE_VERKNUEPFUNG************************************/
/* Die Codes sind die zu den Raendern gehoerenden Randcodes (Bruchkanten-
   raender)                                                                */
/* i,j: siehe "verknuepfe_patches"                                         */
/* bei den vier Einschlussarten gilt:
   j muss 0 sein, da code2[j]>0 und code2[0] der einzige Eintrag > 0 ist.
   len2 steht je nach Einschlussart auch fest. Deshalb werden diese beiden
   Werte bei einem Einschluss nicht benutzt.                               */ 
/* k1 ist die Grundkante im linken Patch bzw. in Patch A. k3 ist die 
   Grundkante in Patch B bzw. Patch 2
   (Patch A == Patch B ist moeglich, ebenso k1==k3 bei Fall 1).            */
/* Nach der Verknuepfung:  kk = Zeiger auf Grundkante,
   bei Fall 1 zusaetzlich: kk2 = Zeiger auf Kante, die vom Auftreffpunkt
   der Naht wegfuehrt und deren next-Element eine Kante der Naht ist
   (also: "im Uhrzeigersinn").                                             */

void mache_verknuepfung(KANTE *k1,KNOTENTYP *code1,KNOTENTYP i,
     KNOTENTYP len1,KANTE *k3,KNOTENTYP *code2,KNOTENTYP j,KNOTENTYP len2,
     KANTE **kk,KANTE **kk2,unsigned char art,KNOTENTYP nahtlen,
     KNOTENTYP schleifenlen) {
  static KNOTENTYP l;     /* l = Anzahl der zu identifizierenden Knoten (bis 
                             vor den Einschluss bzw. bis zum Nahtende) */
  static KANTE *k2,*k4;
  /* die Reihenfolge der drei folgenden Zeilen MUSS erhalten bleiben,
     da durch die dritte Zeile der alte Wert von k1 zerstoert wird */
  if (art==EINSCHLUSS)  
               {k4 = suche_naht(code1,(i+(schleifenlen&1 ? 4 : 3))%len1,k1);
                l = nahtlen-1;}
  else         {k4 = suche_naht(code2,(j+1+(KNOTENTYP)(nahtlen&1))%len2,k3);
                l = nahtlen;}
  k1 = (*kk = suche_naht(code1,i,k1))->invers;
  /* nun ist (k1,k4) die Kerbe, in der die Naht beginnt */
  /* Kerbe vernetzen: */
  k1->next = k1->prev->prev = k4;
  k4->prev = k1;
  k2 = k4->next->invers;
  k4->next = k1->prev;
  k1 = k1->prev->invers;      /* Reihenfolge wichtig */
  k1->fl_rechts = k2->fl_rechts;
  k1->connfl = k2->connfl;

  /* bis zum Einschluss vernetzen: rechts wird zerstoert (bei k2) */
  while (l>0) {                                /* Naht entlanggehen */  
    if (k1->next) {
      k1 = k1->next->invers;  k2 = k2->next->invers;
      k1->fl_rechts = k2->fl_rechts;
      k1->connfl = k2->connfl;
    }
    else {         /* keine Kante vorhanden => Aussenseite */
      k1->next = k1->prev->prev = k2->next;
      /* die folgenden Operationen zerstoeren nicht die Route k2 */
      k2->next->prev = k1;
      k2->next->next = k1->prev;
      k1 = k1->prev->invers;      
      if (k2->prev) {
        k2 = k2->prev->invers;
        k1->fl_rechts = k2->fl_rechts;
        k1->connfl = k2->connfl;
      }
      /* k2->prev existiert immer, wenn art==EINSCHLUSS. 
         Wenn es nicht existiert,
         so ist das Nahtende erreicht, so dass kein neuer Wert und keine
         Flaechengroesse mehr bestimmt zu werden brauchen. */
    }  
    l--;
  }
 
  if (art!=EINSCHLUSS) {*kk2 = k1->invers; return;}     /* Nahtende erreicht */

  /* ab hier gilt: Einschluss wird gemacht */   
  /* dreifachen Treffpunkt vernetzen: */
  if ((nahtlen&1)==0 || (schleifenlen&1)==0) {           /* != 4*/
    k3 = k3->next;           k1->next = k3->invers;
    k3->invers->prev = k1;   k2 = k2->next->invers;
  }
  else {              /* bei Eineck kein Unterschied */
    k1->next = k3;           k3->prev = k1;
    k2 = k2->next->invers;   k3 = k3->invers;
  }

  /* nun zeigen k2 und k3 parallel zum dreifachen Treffpunkt */
  /* B vernetzen: Kanten von B bleiben erhalten,
     Kanten von A werden entfernt */
  l = schleifenlen-1;   /* Anzahl der zu identifizierenden Knoten */
  while (l>0) {        /* Naht entlanggehen */  
    k3->fl_rechts = k2->fl_rechts;
    k3->connfl = k2->connfl;
    if (k3->next) {k3 = k3->next->invers;  k2 = k2->next->invers;}
    else {         /* keine Kante vorhanden => Aussenseite */ 
      k3->next = k3->prev->prev = k2->next;
      /* die folgenden Operationen zerstoeren nicht die Route k2 */
      k2->next->prev = k3;
      k2->next->next = k3->prev;
      k3 = k3->prev->invers;   k2 = k2->prev->invers;
    }
    l--;
  }

  /* dreifachen Treffpunkt komplett vernetzen: */
  k3->fl_rechts = k2->fl_rechts;
  k3->connfl = k2->connfl;
  k3->next = k1;   k1->prev = k3;
}

/*********************KONSTRUIERE_PATCH*************************************/
/* Konstruiert den Patch e rekursiv. Der Patch wird an m uebergeben,
   der zugehoerige Bordercode an "ergcode". 
   "start" ist die Nummer des ersten freien Elements im Array m.     */
/* An "erggrundkante" wird das Array mit den Zeigern auf die Grundkanten
   der einzelnen Raender uebergeben (die Groesse des Arrays steht in 
   "ergcode[0]"). "erggrundkante[0]" ist demzufolge die Grundkante,
   an der die kanonische Naht beginnt, deren Ursprung also markiert wird.  */
/* Falls "nr2" existiert, so zeigt der Parameter auf die Nummer eines Randes.
   Dieser Rand uebernimmt die Rolle von Rand 2 bei Fall 1. Sofern die Funktion
   "sortiere_randcodes2" den Rand mit dieser Nummer verschiebt, wird dies
   in "nr2" festgehalten, so dass anschliessend der Inhalt immer noch korrekt
   ist. Die resultierende Nummer wird an die aufrufende Funktion zurueck-
   gegeben. "nr2" spielt nur in der obersten Rekursionsebene eine Rolle und
   wird deshalb nie an tiefere Ebenen uebergeben. */
/* "connfl" enthaelt die zuletzt an eine Flaeche vergebene Nummer. */
/* "arraypos" ist nicht der Rekursionslevel, sondern zeigt auf einen freien
   Platz in den Arrays "code1_kon" etc. Falls die Funktion von der Funktion
   "konstruiere_patch_top_down" aus aufgerufen wird, so sind die gesamten
   Arrays frei, und es wird eine 0 uebergeben. Falls "his_len" die Anzahl der 
   durch die rekursive Patchgenerierung belegten Elemente ist, so sind alle 
   Elemente mit einem Index >=his_len unbelegt, so dass zu Beginn "his_len"
   uebergeben wird. Im Uebrigen gilt: sobald die Funktion nach oben verlassen
   wird, werden die Arrayinhalte nicht mehr gebraucht (denn bevor auf globale 
   Arrays umgestellt wurde, wurden die Arrays ja sogar physikalisch geloescht).
   Man kann sie dann also bedenkenlos wieder benutzen. */ 

void konstruiere_patch(KANTENARRAY m,POSTYP *start,KNOTENTYP *ergcode,
                       ELEM *e,KANTE **erggrundkante,
                       KNOTENTYP *nr2,KNOTENTYP *connfl,POSTYP *arraypos) {
  static KNOTENTYP code5[2*N_MAX_P], code6[2*N_MAX_P], anf4, len4, len5, len6, 
                   dummy;   
                   /* Speicher fuer RANDcodes, die zweimal
                      hintereinander in den Arrays stehen muessen bzw. dort
                      hineingeschrieben werden. */
  static KNOTENTYP offset6;    /* Falls Fall 1 vorliegt, so werden die Elemente
                                  code6 und len6 benutzt. Code6 ist maximal,
                                  wenn er ab dem Element &code6[offset6]
                                  gelesen wird. */ 
  static BOOL dummybool;
  KNOTENTYP anf3,len3;   /* nicht static, weil nach der Festlegung
                            der Werte noch eine Rekursion aufgerufen wird */
  /* die folgenden Variablen sind natuerlich NICHT static wegen Rekursion */
  KANTE **grundkante1,**grundkante2;  /* Grundkanten in den kanonischen 
                   Vorgaengern (Anzahl steht in code1[0] bzw. code2[0]) */
  KNOTENTYP *code1,*code2;           /* Bordercodes der Vorgaenger */
  KANTE *k1,*k2;       /* Zeiger auf die Grundkanten in den Raendern, die
                          miteinander verklebt werden sollen. */

  if (e->prev1==nil) {      /* Einzelflaeche */
    (*connfl)++;
    konstruiere_n_eck((FLAECHENTYP)((e->i).nr),m,*start,ergcode,*connfl);
    erggrundkante[0] = &m[(*start)+1];      /* Grundkante im n-Eck */
    *start += ((e->i).nr)<<1;
  }
  else {
    /* kanonische Vorgaenger konstruieren: */
    code1 = code1_kon[*arraypos];
    code2 = code2_kon[*arraypos];
    grundkante1 = gk1_kon[*arraypos];
    grundkante2 = gk2_kon[*arraypos];
    (*arraypos)++;   /* hoehere Elemente sind unbelegt */
    konstruiere_patch(m,start,code1,e->prev1,grundkante1,nil,connfl,arraypos);
    k1 = grundkante1[(e->i).nr];
    anf3 = code1[(e->i).nr+1];           /* Anfang des relevanten Randcodes */
    len3 = code1[(e->i).nr+2]-anf3;      /* Laenge des Randcodes */
    if (e->prev2) {
      konstruiere_patch(m,start,code2,e->prev2,grundkante2,nil,connfl,
                        arraypos);
      k2 = grundkante2[(e->j).nr];
      anf4 = code2[(e->j).nr+1];         /* Anfang des relevanten Randcodes */
      len4 = code2[(e->j).nr+2]-anf4;    /* Laenge des Randcodes */
    }
    else if (e->art!=VERBINDUNG) {
      k2 = grundkante1[(e->j).nr];
      anf4 = code1[(e->j).nr+1];         /* Anfang des relevanten Randcodes */
      len4 = code1[(e->j).nr+2]-anf4;    /* Laenge des Randcodes */
    }
    else {                               /* Fall 1 */
      k2 = k1;  anf4 = anf3;  len4 = len3;
    }
    /* kanonische Vorgaenger verkleben: */
    mache_verknuepfung(k1,&code1[anf3],(e->i).pos,len3,k2,
                       e->prev2 ? &code2[anf4] : &code1[anf4],(e->j).pos,len4,
                       &k1,&k2,e->art,e->nahtlen,e->ziellen);
    erggrundkante[0] = k1;                 /* neue Grundkante */
    if (e->art==VERBINDUNG) {k2 = suche_kante((e->j).nr,k2);}   
       /* Fall 1 --- Grundkante suchen */  
    /* neuen Randcode ausrechnen: */
    offset6 = 0;
    dummy = verknuepfe_randcodes(&code1[anf3],e->prev2 ? &code2[anf4] :
            (e->art!=VERBINDUNG ? &code1[anf4] : nil),
            len3,len4,(POSTYP)((e->i).pos),
            (POSTYP)((e->j).pos),e->art,code5,&len5,code6,&len6,&offset6,
            False,&dummy,e->nahtlen,e->ziellen);
    /* neuen Bordercode und neue Grundkanten berechnen: */
    dummybool = sortiere_randcodes((e->i).nr,(e->j).nr,e->art==VERBINDUNG,
                       code1,e->prev2 ? code2 : nil,
                       code5,len5,&code6[offset6],len6,ergcode,False,
                       grundkante1,grundkante2,erggrundkante,k2,&dummy);
    sortiere_randcodes2(ergcode,erggrundkante,nr2);
  }
}           
     
/*********************MUSS_PATCH_KONSTRUIERT_WERDEN**************************/
/*  Diese Funktion prueft, ob der generierte Patch konstruiert werden muss,
    und konstruiert ihn gegebenenfalls. 
    Es gibt folgende Anlaesse:
    - Pruefung auf Doppelkante (falls nicht erlaubt)
    - spezielle Strukturen ueberpruefen  (z.B. bei "delaney", "patchconn")
    - mehrere gleiche beste Randcodes (Planarcode muss entscheiden)
    - Fall 1:  Ist die Markierung des zweiten Randes korrekt oder ist sie
      isomorph zu einer Markierung, die naeher zur Naht ist (d.h. bei der
      (e->j).nr kleiner ist)?
    Der Rueckgabewert gibt an, ob der Patch die durchgefuehrten Pruefungen
    bestanden hat (dann "True").    
    Der Patch ist in "e" und hat die Umrandung "bordercode". Falls 
    einschl==True, so ist er durch einen Einschluss entstanden oder besitzt
    nur einen direkten Vorgaenger (das ist insbesondere bei Fall 1 der Fall).
    "e.next" muss nicht mit einem korrekten Wert gefuellt sein.
    Falls "fall1==True", so enthaelt "zielrand" die VORLAEUFIGE Nummer von 
    Rand 2 (vor der Sortierung durch "sortiere_randcodes2" -- wird bei der 
    Konstruktion des Patches angepasst) und
    "akzeptiert" die Indices der akzeptierten Markierungen.                 */
/*  Reihenfolge der einzelnen Abfragen nicht vertauschen, sonst muss die
    Ueberpruefung des Flags "numeriert" neugestaltet werden.                */ 
/*  Wenn diese Funktion aus der Rekursion aufgerufen wird, dann ist der
    Patch bereits konstruiert (aber niemals numeriert). In dem Fall enthaelt 
    "konstruiert" den Wert "True" und "gk" enthaelt die Liste der Grundkanten.
    Andernfalls muss "gk" auf ein ausreichend grosses Array zeigen. 
    Falls "loesche_num==True", so wird eine eventuelle Numerierung des
    Patches am Ende wieder geloescht. Dies ist nur innerhalb der Rekursion
    (und nur bei akzeptierten Patches) erforderlich, da bei der normalen 
    Patcherzeugung der konstruierte Patch nicht weiterverarbeitet wird.    */
/*  "is_test2" gibt an, ob Test 2 gewuenscht wird (nicht in der Rekursion,
    denn er ist zeitaufwendig und spart keinen Speicherplatz).             */
/*  "is_test1" gibt an, ob Test 1 gewuenscht wird (in der Rekursion erst
    einen Level ueber dem niedrigsten Testlevel, wenn dort nur ein j.nr-Wert
    veraendert wurde, denn die Aenderung beeintraechtigt nicht das 
    Kantengeruest).                                                        */
/*  Wichtig: Wenn der Patch nicht schon beim Aufruf dieser Funktion 
    konstruiert ist, so wird er nach Beendigung dieser Funktion auch nicht
    mehr gebraucht, so dass die Konstruktion im lokalen Array "map" erfolgen
    darf.                                                                  */
/*  "arraypos" wird an die Funktion "konstruiere_patch" weitergegeben.     */

BOOL muss_patch_konstruiert_werden(ELEM *e,BOOL einschl,KNOTENTYP *bordercode,
     BOOL fall1,KNOTENTYP zielrand,unsigned char *akzeptiert,BOOL konstruiert,
     KANTE **gk,BOOL loesche_num,BOOL is_test1,BOOL is_test2,POSTYP arraypos) {
  static KANTENARRAY map;
  static KNOTENTYP planarcode1[CODESIZE_MAX_P],planarcode2[CODESIZE_MAX_P]; 
  static KNOTENTYP testc[CODESIZE_MAX_P]; 
  static POSTYP start;
  static KANTE *k;
  static PLANMAP m,m2;
  static KNOTENTYP i,j,len,n;         /* len = Randlaenge 0, n = Knotenzahl */ 
  static EULERTYP h;
  static size_t size;       /* bei allen zu vergleichenden Codes gleich */
  static unsigned char con;
  static signed char erg;
  static BOOL test1,test2,test3,test4,test5,test6;
  static BOOL gk0_numeriert;  /* True => Patch ist von "gk[0]" aus numeriert */
  static BOOL numeriert;      /* True => Patch ist numeriert */
  static BORDERPOS gknum1[G_MAX],gknum2[G_MAX];     /* Zur Speicherung der 
         Numerierung der Grundkanten:  "nr" enthaelt die Nummer des Ursprungs,
         "pos" die des Ziels. G_MAX reicht, da eine Grundkante nicht
         beruecksichtigt wird. */
  static KNOTENTYP bb2,len2,wh2,rl2,ziellen; 
         /* fuer Fall 1 (bb2: Rand 2 ist BB) */
  static KNOTENTYP connfl;
  static POSTYP arraypos2; /* "arraypos2" ist veraenderbar, "arraypos" nicht */
  static KNOTENTYP dummyarray[N_MAX_P+3],dummy;

  /* Werte festlegen (nicht direkt in der "if (test1...)"-Bedingung wegen 
     lazy-evaluation): */
  len = bordercode[2]-bordercode[1];
  if (fall1) {
    len2 = bordercode[zielrand+2] - bordercode[zielrand+1];
    bb2 = (len2==2 && bordercode[bordercode[zielrand+1]]==BB_KENNUNG);
    if (bb2) {rl2 = 2;}       /* Laenge einer Randperiode (in Kanten) */
    else {
      wh2 = ermittle_wh(&bordercode[bordercode[zielrand+1]],len2);
      rl2 = randlaenge(bordercode,bordercode[zielrand+1],
                       bordercode[zielrand+1]+wh2-1);
    }
  }
  test1 = (!doppelkanten && is_test1 && einschl && big_face>=7);
          /* Doppelkante ueberpruefen */
  test2 = ((is_test2 && (patchconn && conn1==False)) || facecon1==False); 
          /* Patchzusammenhang pruefen (facecon2==False => facecon1==False):
             immer, falls facecon1==False, denn dann lohnt es sich oft */
  test3 = (bordercode[0]>1 && vergleiche_codes(&bordercode[bordercode[1]],
           (POSTYP)len,&bordercode[bordercode[2]],
           (POSTYP)(bordercode[3]-bordercode[2]))==0);  /* beste Randcodes */
  test4 = (fall1 && (bb2 || wh2<len2) && (e->j).nr>rl2);
          /* Fall 1: (e->j).nr koennte kleiner sein */
  test5 = delaney;      /* Flaechenmengen ueberpruefen */
  test6 = mdeza1_used;  /* Anfrage von Michel Deza im Mai 2000 */   
  numeriert = False;    /* wichtig fuer die Zeilen am Ende der Funktion */

  /* Muss konstruiert werden? */
  if (test1 || test2 || test3 || test4 || test5 || test6) {
    if (!konstruiert) {
      start = 0;   connfl = 0;   arraypos2 = arraypos;
      konstruiere_patch(map,&start,bordercode,e,gk,fall1 ? &zielrand : nil,
                        &connfl,&arraypos2);
        /* "bordercode" erhaelt den sowieso schon aktuellen Inhalt zurueck.
           Bei Fall 1 "zielrand" die nach der Sortierung durch 
           "sortiere_randcodes2" gueltige Nummer des 2.Randes 
           (wichtig fuer die weiteren Vergleiche) */
      konstruiert = True;
    }
    gk0_numeriert = False;    /* numeriert wird nur bei Bedarf */

    /* 1. Muss auf Doppelkanten getestet werden? */
    if (test1) {
      /* Test entfaellt, falls keine groessere Flaeche als 6-eck im Patch: 
         nur feststellbar, wenn die Flaechenzahlen gespeichert sind, aber 
         dann ist Berechnungsaufwand zu gross im Vergleich zur 
         Wahrscheinlichkeit, dass Test entfallen kann. */
      n = numeriere_graph(m,gk[0]);  
      numeriert = gk0_numeriert = True;
      for (i=0; i<n; i++) {                   /* Kanten durchgehen */
        if (m[i][0] && m[i][1] && m[i][2] &&  /* falls nicht alle 3 Kanten
            existieren => 2-valenter Randknoten => Doppelkante nur moeglich
            als (BB,1), und das wird an anderer Stelle ueberprueft */
            (m[i][0]->name == m[i][1]->name  ||
             m[i][0]->name == m[i][2]->name  ||
             m[i][1]->name == m[i][2]->name)) {return(False);
        }
      }
    }

    /* 2. Muss auf Patchzusammenhang oder zusammenhaengende Flaechen getestet 
          werden? */
    /* conn1==True => minimaler Zusammenhang erlaubt => keine Einschraenkung */
    if (test2) {
      if (!numeriert)  {
        n = numeriere_graph(m,gk[0]);
        numeriert = gk0_numeriert = True;
      }      
      con = getconn(m,n,gk,bordercode[0]);
      if (con==0 || (con==1 && conn1==False) || 
         (con==2 && conn2==False)) 
         {return(False);}
    }       

    /* 3. Sind die besten Randcodes gleich? */
    /* Hier wird insbesondere der Fall beruecksichtigt, dass bei Fall 1 die
       beiden neuen Raender gleich gut sind. */
    /* Da alle Raender bis auf Rand 0 bei der Konstruktion bereits sortiert
       werden, muss Rand 0 nur mit Rand 1 verglichen werden, auch wenn Rand 2
       etc. denselben Randcode haben wie Rand 0. */ 
    if (test3) {
      if (!gk0_numeriert) {
        if (numeriert) {loesche_patchnumerierung(m,n);}
        n = numeriere_graph(m,gk[0]);
        numeriert = gk0_numeriert = True;
      }
      speichere_gk_numerierung(gk,bordercode[0],gknum1,0);
      size = doppelkanten ? patchmap_2_embedcode(m,planarcode1,n) :
             patchmap_2_planarcode(m,planarcode1,n);   /* Rand 0 codieren */

      /* nun mit Rand 1 vergleichen */
      loesche_patchnumerierung(m,n);
      n = numeriere_graph(m,gk[1]);  
      gk0_numeriert = False;
      size = doppelkanten ? patchmap_2_embedcode(m,planarcode2,n) :
             patchmap_2_planarcode(m,planarcode2,n);   /* Rand 1 codieren */
      if ((erg = vergleiche_codes(planarcode1,size,planarcode2,size))==-1) {
        if (loesche_num) {loesche_patchnumerierung(m,n);}
        return(False);       /* zweite Grundkante ist besser */
      } 
      else if (erg==0) {     /* Grundkantennumerierung muss entscheiden */
        speichere_gk_numerierung(gk,bordercode[0],gknum2,1);
        if (bo_memcmp(gknum1,gknum2,bordercode[0]-1)<0) {          
          /* zweite Grundkante ist besser */  
          if (loesche_num) {loesche_patchnumerierung(m,n);}
             /* Numerierung loeschen, obwohl der Patch unbrauchbar ist. Das
                ist erforderlich, weil der Patch bei einer Erhoehung des j.nr-
                Wertes nicht neu konstruiert wird. */
          return(False);
        }  
      }
    }            

    /* 4. Fall 1: Markierung von Rand 2 mit "kleineren" AKZEPTIERTEN 
          Markierungen vergleichen */ 
    if (test4) {
      if (numeriert) {loesche_patchnumerierung(m,n);}
      k = gk[zielrand];     /* Grundkante von Rand 2 */
      n = numeriere_graph(m,k);
      numeriert = True;     gk0_numeriert = False;
      speichere_gk_numerierung(gk,bordercode[0],gknum1,zielrand);
      size = doppelkanten ? patchmap_2_embedcode(m,planarcode1,n) :
             patchmap_2_planarcode(m,planarcode1,n);   /* Referenz */
      ziellen = (e->j).nr;       /* Verweis auf Grundkante */
      while (ziellen > rl2) {    /* es kann noch eine Periode uebersprungen
                                    werden */
        ziellen -= rl2;          /* naechste Periode */
        i = ziellen/rl2;      /* Index der Markierung im Array "akzeptiert" */
        k = suche_kante2(rl2,k);    /* Periode ueberspringen */
        if (IS_ACCEPTED(akzeptiert,i)) {   /* sonst nicht pruefen */
          loesche_patchnumerierung(m,n);
          n = numeriere_graph(m,k);        /* Vergleichsnumerierung */
          size = doppelkanten ? patchmap_2_embedcode(m,planarcode2,n) :
                 patchmap_2_planarcode(m,planarcode2,n);   /* Vergleich */
          if (vergleiche_codes(planarcode1,size,planarcode2,size)==0) {
            /* Die gesamten Codes sind gleich, also liegt ein Automorphismus
               vor. Nun wird untersucht, ob der Automorphismus auch die 
               Grundkanten aufeinander abbildet. */ 
            speichere_gk_numerierung(gk,bordercode[0],gknum2,zielrand);
            if (bo_memcmp(gknum1,gknum2,bordercode[0]-1)==0) {
              /* Grundkanten werden aufeinander abgebildet => isomorph */  
              if (loesche_num) {loesche_patchnumerierung(m,n);}
              return(False);
            }
          }
        }
      }          
    }

    /* 5. Muessen an einem Knoten anliegende Flaechen ueberprueft werden? */
    if (test5) {
      if (!numeriert)  {
        n = numeriere_graph(m,gk[0]);
        numeriert = gk0_numeriert = True;
      }      
      if (!delaneytest(m,n,gk,bordercode[0])) {return(False);}
    }       

    /* 6. Muessen 7-Eck-Nachbarschaften ueberprueft werden? */
    if (test6) {
      if (!numeriert)  {
        n = numeriere_graph(m,gk[0]);
        numeriert = gk0_numeriert = True;
      }      
      for (i=0; i<n; i++) {                   /* Kanten durchgehen */
        for (j=0; j<=2; j++) {
	  if (m[i][j] && m[i][j]->fl_rechts==7) {     /* Siebeneck umlaufen */
            KNOTENTYP frei,siebeneck;
            frei = 0;                    /* Anzahl freier Nachbarschaften */
            siebeneck = 0;               /* Anzahl benachbarter Siebenecke */
            k = m[i][j];
            do {
              if (k->invers->fl_rechts==0)      {frei++;}
              else if (k->invers->fl_rechts==7) {siebeneck++;}
              k = k->next->invers;
            } while (k != m[i][j]);
            if (siebeneck>2) {return(False);}       /* zu viele Siebenecke */
            if (siebeneck+frei<2) {return(False);}  /* erforderliche Anzahl
			             Siebenecke kann nicht erreicht werden */  
          }
        }
      }
    }

    if (fall1 && (bb2 || wh2<len2)) {SET_ACCEPT(akzeptiert,(e->j).nr/rl2);}
       /* Entweder musste Test 4 nicht durchlaufen werden, weil (e->j).nr<rl2,
          oder Test 4 hat ergeben, dass die Markierung nicht isomorph zu einer
          kleineren akzeptierten Markierung ist. */
       /* Diese Abfrage muss ganz am Ende der Funktion stehen, damit klar ist,
          dass der Patch ueberhaupt akzeptiert wird. */ 
  }

  /* Alle Tests ueberstanden:  Der Patch wird akzeptiert werden, so dass sich
     die Berechnung der non-iso-Raender schon an dieser Stelle lohnt. */
  /* Markiere non-iso-Raender: */
  /* Raender, die isomorph zu einem ihrer uebergeordneten Raender sind, 
     duerfen nicht verklebt werden, da sonst Dopplungen auftreten. Diese
     Raender werden im Folgenden markiert.
     2 Raender sind isomorph, wenn es einen Automorphismus gibt, der die
     Grundkanten der beiden Raender aufeinander abbildet und auch die 
     restlichen Grundkanten aufeinander abbildet. */
  /*  "gk" zeigt auf die Grundkanten der Raender des Patches, sofern der Patch
     bereits konstruiert wurde. In dem Fall ist konstruiert==True. Wenn der
     Patch auch schon numeriert wurde, so enthaelt "numeriert" den Wert "True".
     In dem Fall enthalten "m" und "n" sinnvolle Werte.
     "gk" muss immer auf ein ausreichend grosses Array zeigen.             */

  j = ((bordercode[0]-1)>>3)+1; 
      /* Anzahl wichtiger Elemente im iso_rand-array */
  for (i=0; i<j; i++) {(e->iso_rand)[i] = 255;}  /* Default: nicht isomorph */
  for (i=1; i<bordercode[0]; i++) {
    h = i-1;     /* h = Vergleichsrand */
    if ((len = bordercode[i+2]-bordercode[i+1]) ==
        bordercode[h+2]-bordercode[h+1] &&  /* beachte lazy-Evaluation */
        kn_memcmp(&bordercode[bordercode[i+1]],&bordercode[bordercode[h+1]],
        (POSTYP)len)==0) {   /* gleiche Randcodes */
      if (!konstruiert) {
        start = 0;   connfl = 0;   arraypos2 = arraypos;
        konstruiere_patch(map,&start,dummyarray,e,gk,nil,&connfl,&arraypos2);
        konstruiert = True;
      }
      else if (numeriert) {loesche_patchnumerierung(m,n);}
      /* Vorsicht: Wenn innerhalb dieser Funktion konstruiert wird, dann
         darf die Numerierung nicht ausserhalb geloescht werden. */
      n = numeriere_graph(m,gk[i]);
      speichere_gk_numerierung(gk,bordercode[0],gknum1,i);
      size = doppelkanten ? patchmap_2_embedcode(m,planarcode1,n) :
                            patchmap_2_planarcode(m,planarcode1,n);
      loesche_patchnumerierung(m,n);
      n = numeriere_graph(m,gk[h]);
      size = doppelkanten ? patchmap_2_embedcode(m,planarcode2,n) :
                            patchmap_2_planarcode(m,planarcode2,n);
      numeriert = True;  
      if (kn_memcmp(planarcode1,planarcode2,(POSTYP)size)==0) {
        speichere_gk_numerierung(gk,bordercode[0],gknum2,h);
        if (bo_memcmp(gknum1,gknum2,bordercode[0]-1)==0) {SET_ISO_RAND(e,i);}  
           /* Grundkanten werden aufeinander abgebildet */
      }
    }  /* if */
  }    /* for */
  if (numeriert && loesche_num) {loesche_patchnumerierung(m,n);}
  return(True);    /* alle Tests ueberstanden */
}

/*********************KONSTRUIERE_PATCH_IN_REKURSION************************/
/* Konstruiert den Patch e rekursiv. Der Patch wird an m uebergeben,
   der zugehoerige Bordercode an "ergcode".
   Diese Funktion arbeitet aehnlich wie die Funktion "konstruiere_patch".
   Jedoch muessen, da die Funktion innerhalb des Vollstaendigkeitskriteriums
   arbeitet, alle Tests nachgeholt werden, die in der Rekursion nicht 
   durchgefuehrt werden. Die Tests auf Doppelkanten und Patchzusammenhang
   brauchen nur am Ende durchgefuehrt zu werden, da sich die Eigenschaften
   vererben. Die Tests auf NON_ISO-Raender und maximale Raender muessen 
   jedoch nach jedem Zwischenschritt durchgefuehrt werden.
   Weitere Kommentare siehe "konstruiere_patch".                           */
/* "l" ist der Level, der in der Funktion "setze_history_weiter" ermittelt 
   wurde.                                                                  */
/* Die Funktion gibt die Position in der history zurueck, bis zu der die
   Konstruktion anstandslos geklappt hat. Falls dies der Wert "his_anz" ist,
   so wurde der gesamte Patch erfolgreich konstruiert. Andernfalls kann die
   aufrufende Funktion den uebergebenen Wert dazu benutzen, in der history
   soweit weiterzugehen, bis der Patch in der betreffenden Position auch
   tatsaechlich geaendert wird.                                            */

POSTYP konstruiere_patch_in_rekursion(KANTENARRAY m,POSTYP *start,
     KNOTENTYP *ergcode,ELEM *e,KANTE **erggrundkante,
     POSTYP l,POSTYP his_anz,POSTYP his_pos,KNOTENTYP *connfl) {
  static KNOTENTYP code5[2*N_MAX_P], code6[2*N_MAX_P], anf4, len4, len5, len6, 
                   dummy, nr2;   
                   /* Speicher fuer RANDcodes, die zweimal
                      hintereinander in den Arrays stehen muessen bzw. dort
                      hineingeschrieben werden. */
  static KNOTENTYP offset6;    /* Falls Fall 1 vorliegt, so werden die Elemente
                                  code6 und len6 benutzt. Code6 ist maximal,
                                  wenn er ab dem Element &code6[offset6]
                                  gelesen wird. */ 
  static BOOL dummybool;
  static FLAECHENTYP f;
  static POSTYP arraypos;   /* fuer die Funktion "konstruiere_patch" */
  POSTYP erg;
  KNOTENTYP anf3,len3;   /* nicht static, weil nach der Festlegung
                            der Werte noch eine Rekursion aufgerufen wird */
  /* die folgenden Variablen sind natuerlich NICHT static wegen Rekursion */
  KANTE **grundkante1,**grundkante2;    /* Grundkanten in den kanonischen 
                     Vorgaengern (Anzahl steht in code1[0] bzw. code2[0]) */
  KNOTENTYP *code1,*code2;  /* Bordercodes der Vorgaenger */
  KANTE *k1,*k2;       /* Zeiger auf die Grundkanten in den Raendern, die
                          miteinander verklebt werden sollen. */

  /* e->prev1==nil ist unmoeglich in Rekursion */
  code1 = code1_kon[his_pos];
  code2 = code2_kon[his_pos];
  grundkante1 = gk1_kon[his_pos];
  grundkante2 = gk2_kon[his_pos];
  if (e->prev1->stamm) {           /* e->prev1 normal konstruieren */
    arraypos = his_anz; 
    konstruiere_patch(m,start,code1,e->prev1,grundkante1,nil,connfl,&arraypos);
  }
  else if ((erg = konstruiere_patch_in_rekursion(m,start,code1,e->prev1,
            grundkante1,l,his_anz,his_pos-1,connfl))<his_pos) 
          {return(erg);}
       /* Wenn e->prev1 nicht zum Stamm gehoert, dann ist e->prev1 der
          naechstunterste Eintrag von "e" in der history (also "his_pos-1"). */
  k1 = grundkante1[(e->i).nr];
  anf3 = code1[(e->i).nr+1];           /* Anfang des relevanten Randcodes */
  len3 = code1[(e->i).nr+2]-anf3;      /* Laenge des Randcodes */
  if (e->prev2) {
    if (e->prev2->stamm) {        /* e->prev2 normal konstruieren */    
      arraypos = his_anz;
      konstruiere_patch(m,start,code2,e->prev2,grundkante2,nil,connfl,
                        &arraypos);
    }
    else if ((erg = konstruiere_patch_in_rekursion(m,start,code2,e->prev2,
              grundkante2,l,his_anz,his_pos-1,connfl))<his_pos) 
            {return(erg);}
    k2 = grundkante2[(e->j).nr];
    anf4 = code2[(e->j).nr+1];         /* Anfang des relevanten Randcodes */
    len4 = code2[(e->j).nr+2]-anf4;    /* Laenge des Randcodes */
  }
  else if (e->art!=VERBINDUNG) {
    k2 = grundkante1[(e->j).nr];
    anf4 = code1[(e->j).nr+1];         /* Anfang des relevanten Randcodes */
    len4 = code1[(e->j).nr+2]-anf4;    /* Laenge des Randcodes */
  }
  else {                               /* Fall 1 */
    k2 = k1;  anf4 = anf3;  len4 = len3;
  }
  /* kanonische Vorgaenger verkleben: Vortests */
  if (his_pos>=l) {    /* Flaechenzahlen pruefen */
    if (facerestrict && !flaechenzahlen2_ok(e->prev1,e->prev2)) 
       {return(his_pos);}  
    if (!NON_ISO_RAND(e->prev1,(e->i).nr) ||
        (e->prev2 && !NON_ISO_RAND(e->prev2,(e->j).nr))) {return(his_pos);}
        /* Raender duerfen nicht verklebt werden */
  } 
  mache_verknuepfung(k1,&code1[anf3],(e->i).pos,len3,k2,
                     e->prev2 ? &code2[anf4] : &code1[anf4],(e->j).pos,len4,
                     &k1,&k2,e->art,e->nahtlen,e->ziellen);
  erggrundkante[0] = k1;                 /* neue Grundkante */
  if (e->art==VERBINDUNG) {k2 = suche_kante((e->j).nr,k2);}   
     /* Fall 1 --- Grundkante suchen */  
  /* neuen Randcode ausrechnen: */
  offset6 = 0;
  dummy = verknuepfe_randcodes(&code1[anf3],e->prev2 ? &code2[anf4] :
          (e->art!=VERBINDUNG ? &code1[anf4] : nil),len3,len4,
          (POSTYP)((e->i).pos),
          (POSTYP)((e->j).pos),e->art,code5,&len5,code6,&len6,&offset6,
          False,&dummy,e->nahtlen,e->ziellen);
  /* neuen Bordercode und neue Grundkanten berechnen: */
  dummybool = sortiere_randcodes((e->i).nr,(e->j).nr,e->art==VERBINDUNG,code1,
                       e->prev2 ? code2 : nil,
                       code5,len5,&code6[offset6],len6,ergcode,False,
                       grundkante1,grundkante2,erggrundkante,k2,&nr2);
  sortiere_randcodes2(ergcode,erggrundkante,&nr2);
  /* erzeugten Patch testen: */
  if (his_pos>=l) {   /* isomorphe Raender markieren und Tests durchfuehren */
    /* Falls his_pos<l, so bleiben isomorphe Raender erhalten und die Tests
       ergeben ebenfalls nichts Neues */
    if (!muss_patch_konstruiert_werden(e,e->prev2==nil || e->art==EINSCHLUSS,
        ergcode,e->art==VERBINDUNG,nr2,his_acc[his_pos],True,
        erggrundkante,True,True,his_pos==his_anz-1,his_anz)) 
       {return(his_pos);}
        /* Test 2 bei "muss_patch_konstruiert_werden" nur im obersten Level */
  }
  return(his_pos+1);
}           
     
/*****BESTIMME_GUTE_BASEN************/
/*  zu Testzwecken                  */

void bestimme_gute_basen(ELEM *e) {
     if (e->stamm && (e->test&4)==0) {e->test |= 4;   gute_basen++;}
     if (e->prev1) {bestimme_gute_basen(e->prev1);}
     if (e->prev2) {bestimme_gute_basen(e->prev2);}
}
  

/**********************************************************/
/* Funktionen fuer die Top-Down-Konstruktion von Patches: */
/**********************************************************/

/************************SUCHE_KANTE4***************************************/
/*  Durchlaeuft "pos" Randkanten gegen den Uhrzeigersinn. Das Innere des
    Patches muss "hohl" sein (aussen aber nicht unbedingt)!  
    Die Funktion ist ebenfalls dazu geeignet, einen frei "baumelnden" 
    Pfad entlangzugehen. */
 
KANTE *suche_kante4(KNOTENTYP pos,KANTE *k) {
  while (pos>0) {
    if (k->next) {k = k->next->invers;} else {k = k->prev->invers;}
    pos--;
  }
  return(k);
}
  
/************************SUCHE_KANTE6***************************************/
/*  Durchlaeuft "pos" Randkanten im Uhrzeigersinn. Das Innere des
    Patches muss "hohl" sein (aussen aber nicht unbedingt)!                */
 
KANTE *suche_kante6(KNOTENTYP pos,KANTE *k) {
  while (pos>0) {
    if (k->invers->prev) {k = k->invers->prev;} else {k = k->invers->next;}
    pos--;
  }
  return(k);
}
  
/************************SUCHE_KANTE3***************************************/
/*  Uebergibt die Bruchkante "kk" eines Patches, die von der Bruchkante "k" 
    aus gegen den Uhrzeigersinn "offset" Bruchkanten entfernt ist.         */
/*  Der Patch muss innen "hohl" sein (aussen aber nicht).                  */

KANTE *suche_kante3(KANTE *k,KNOTENTYP offset) {
  while (offset>0) {          /* einen Teil der Border ueberspringen */
    k = k->next->invers;
    while (!k->next)          /* "k" und "k->prev" umschliessen Kerbe */
      {k = k->prev->invers->next->invers;}
    offset--;
  }
  return(k->invers->prev);
}

/************************SUCHE_KANTE5***************************************/
/*  Uebergibt die Grundkante "kk" eines Patches, die von der Kante "k" 
    aus im Uhrzeigersinn "offset" Bruchkanten entfernt ist. "k" ist Nachfolger
    einer Bruchkante.                                                      */
/*  Der Patch muss innen "hohl" sein (aussen aber nicht).                  */

KANTE *suche_kante5(KANTE *k,KNOTENTYP offset) {
  while (offset>0) {          /* einen Teil der Border ueberspringen */
    k = k->invers;
    while (!k->prev)           /* "k" und "k->next" umschliessen Kerbe */
          {k = k->next->invers->prev->invers;}
    k = k->prev;
    offset--;
  }
  return(k);
}

/***********************MACHE_MAXIMAL2**************************************/
/*  Verschiebt einen Randcode so, dass er maximal wird. Genaugenommen wird
    nur ein Offset auf eine Stelle im Bordercode zurueckgegeben, so dass der
    Code von dort ab gelesen maximal ist. Deshalb muss der Randcode zweimal
    hintereinander im Speicher stehen. 
    Der Unterschied zu "mache_maximal" ist, dass der Offset rueckwaerts
    verschoben wird. Er bleibt im Intervall [0,len-1] und ist als NEGATIVER
    OFFSET zu interpretieren (anf -> len-anf).                             */

KNOTENTYP mache_maximal2(KNOTENTYP *code,KNOTENTYP len) {
  static KNOTENTYP j;
  static KNOTENTYP i;          /* offset */
  static EULERTYP vgl;
  static KNOTENTYP anf;
  static KNOTENTYP len2;
  anf = 0;
  i = 1;
  len2 = len<<1;      /* zweimal "len" */
  while (i+anf<len) {
    j=len;
    while (j<len2) {  
      if ((vgl = (EULERTYP)(code[j]-code[j-i]))<0) 
        {j = len2;   code -= i;   anf += i;   i = 0;}
      else if (vgl>0) {j = len2;}
      else {j++; if (j==len2) {return(anf);} }
    }
    i++;
  }
  return(anf);
} 

/*********************PRUEFE_BORDERCODE*************************************/
/*  Prueft, ob ein Rand ohne Kerbe zusammen mit anderen Raendern vorkommt
    (unmoeglich).                                                          */

BOOL pruefe_bordercode(KNOTENTYP *bordercode) {
  static POSTYP i;
  if (bordercode[0]==1) {return(True);}
  for (i=1; i<=bordercode[0]; i++) {
    if (bordercode[bordercode[i]]==0) {return(False);}
    /* denn alle anderen Eintraege muessen dann auch 0 sein -> keine Kerbe */
  }
  return(True);
}

/********************BRUCHKANTENTEST*****************************************/
/* Diese Funktion testet fuer einen Patch mit "r" Raendern und "bk" 
   Bruchkanten, der eine beliebige Flaechenzahl und ein Geschlecht zwischen
   "g_min" und "g_max" haben darf, ob es einen derartigen Patch geben kann. */

BOOL bruchkantentest(KNOTENTYP bk,KNOTENTYP r,KNOTENTYP g_min,
                     KNOTENTYP g_max) {
  static KNOTENTYP g;
  static KNOTENTYP bk2;
  for (g = g_min; g<=g_max; g++) {
    if ((bk2 = ANZ_BK_BEREINIGT(bk,g,r))<=bk_max && bk_moeglich[0][bk2]) 
       {return(True);}   /* wichtig: lazy-eval. */
  }
  return(False);
}

/**************ANZAHL_3_VAL_RANDKNOTEN***************************************/
/*  Ermittelt die Anzahl der 3-valenten Randknoten im Patch.                */

KNOTENTYP anzahl_3_val_randknoten(KNOTENTYP *bordercode) {
  static POSTYP i;
  static KNOTENTYP erg;
  erg = 0;
  for (i=bordercode[bordercode[0]+1]-1; i>=bordercode[1]; i--) {
      /* rueckwaerts geht's schneller */
    if (bordercode[i]!=BB_KENNUNG) {erg += bordercode[i];}
  }
  return(erg);
}   

/*********************BERECHNE_UMRANDUNGEN**********************************/
/*  Diese Funktion berechnet anhand der Informationen, die zu einem 
    Patch "e" gegeben sind, die Bordercodes seiner 1-2 Vorgaenger. 
    "index" ist die Position von "e" in der History.
    Falls einer der erhaltenen Bordercodes ungueltig ist, so wird "False"
    zurueckgegeben.                                                        */

BOOL berechne_umrandungen(POSTYP index) {
  static ELEM *e;
  static KNOTENTYP *bordercode,*code1,*code2;  /* Zeiger auf Bordercodes */
  static KANTE **gk,**gk1,**gk2;       /* Zeiger auf Grundkantenarrays */
  static KANTE *gk_neu1,*gk_neu2,*k;   /* Zeiger auf neue Grundkanten */
  static KNOTENTYP randcode1[2*N_MAX_P],randcode2[2*N_MAX_P];
         /* Randcodes zweimal hintereinander */
  static KNOTENTYP offset1,offset2,restentfernung;  
  static KNOTENTYP *zeiger1,*zeiger2;   /* Zeiger auf exakten Beginn der
                                           neuen Randcodes */
  static KNOTENTYP pos,pos1,pos2,len1,len2,i,anz1,anz2;
  static BOOL bb;
  static BOOL r1,r2,r_alt;   /* "True" -> Randcode ist verarbeitet */
  static KNOTENTYP wh1,wh2,bk1,bk2;
  static BOOL vertauscht;
  static POSTYP vater;
  static char vorg;

  /* Vorbereitung: */
  e = &history[index];
  vorg = vor[index];
  vater = vater_nr[index];
  bordercode = bc_td[vorg][vater];
  code1 = bc_td[0][index];
  code2 = e->vorg==2 ? bc_td[1][index] : nil;

  /* code2==nil <=> nur ein Patch ist entstanden -> als Flag benutzen */

  if (e->art==DURCHSCHNITT) {       /* Durchschnitt */
    restentfernung = e->ziellen;
    pos = bordercode[1];    /* Beginn des Randcodes von Rand 1 */
    if (bb = (bordercode[pos]==BB_KENNUNG)) {pos++;}  /*Kennung ueberspringen*/
 
    /* Rand 2: */
    len2 = 0;
    if (e->nahtlen&1) {randcode2[len2++] = 0;}
    randcode2[len2++] = e->nahtlen>>1;
    pos2 = len2;      /* erste Stelle des kommenden Teils */
    while ((i = (bordercode[pos]<<1)) < restentfernung) {
      /* Gleichheit ist unmoeglich, darum "<" dasselbe wie "<=" */
      /* klappt auch bei BB (Bedingung immer falsch) */
      randcode2[len2++] = bordercode[pos++];
      restentfernung -= i+(!bb);
    }
    randcode2[len2++] = restentfernung>>1;    /* bis zur Kerbe */
    randcode2[pos2]--;   /* Erster Eintrag des letzten Teils war zu hoch. 
      Erst an dieser Stelle ist garantiert ein erster Eintrag erfolgt. */      

    /* Rand 1: */
    len1 = 0;
    randcode1[len1++] = 0;
    if (e->nahtlen&1) {randcode1[len1++] = e->nahtlen>>1;}
    else {randcode1[len1++] = (e->nahtlen>>1)-1;  randcode1[len1++] = 0;}
    randcode1[len1++] = ((i-restentfernung)>>1);
    pos++;   /* geteilter Eintrag ist verbraten */
    memcpy(&randcode1[len1],&bordercode[pos],sizeof(KNOTENTYP)*
           (bordercode[2]-pos));     /* restlicher Randcode (unveraendert) */
    len1 += bordercode[2]-pos;       /* bei BB immer 0 */
    if (!bb) {randcode1[len1++] = 0;}
    bk1 = code2 ? len1 : len1+len2;  
          /* Anzahl Bruchkanten in Patch 1 (vorerst) */
    bk2 = code2 ? len2 : 0;   /* dasselbe fuer Patch 2 */
  }

  else if (e->art==EINSCHLUSS) {      /* Einschluss */        
    pos = bordercode[1];    /* Beginn des Randcodes von Rand 1 */
    if (bb = (bordercode[pos]==BB_KENNUNG)) {pos++;}  /*Kennung ueberspringen*/
    len1 = 0;
    randcode1[len1++] = 0; 
    if (e->nahtlen&1) {           /* Arten 4 und 5 */
      if (e->ziellen&1) {         /* Art 4 */
        randcode2[0] = e->ziellen>>1;
        len2 = 1;
        randcode1[len1++] = ((e->nahtlen + e->ziellen)>>1)-1;
        randcode1[len1++] = 0;
        randcode1[len1++] = e->nahtlen>>1;
      }
      else {                   /* Art 5 */
        randcode2[0] = (e->ziellen>>1)-1;
        randcode2[1] = 0;
        len2 = 2;
        randcode1[len1++] = (e->nahtlen + e->ziellen)>>1;
        randcode1[len1++] = e->nahtlen>>1;
      }
    }
    else {
      if (e->ziellen&1) {         /* Art 2 */
        randcode2[0] = e->ziellen>>1;
        len2 = 1;
        randcode1[len1++] = (e->nahtlen>>1)-1;
        randcode1[len1++] = 0;
        randcode1[len1++] = (e->nahtlen + e->ziellen)>>1;
      }
      else {                  /* Art 3 */
        randcode2[0] = (e->ziellen>>1)-1;
        randcode2[1] = 0;
        len2 = 2;
        randcode1[len1++] = (e->nahtlen>>1)-1;
        randcode1[len1++] = (e->nahtlen + e->ziellen)>>1;
      }
    }
    randcode1[len1++] = bordercode[pos++]-1;
    memcpy(&randcode1[len1],&bordercode[pos],sizeof(KNOTENTYP)*
           (bordercode[2]-pos));
    len1 += bordercode[2]-pos;
    if (!bb) {randcode1[len1++] = 0;}
    bk1 = code2 ? len1 : len1+len2;
    bk2 = code2 ? len2 : 0;
  }

  else {            /* Fall 1 */
    restentfernung = e->ziellen;
    pos = bordercode[e->zielrand+1];     /* Beginn des Randcodes von Rand 2 */
    if (bb = (bordercode[pos]==BB_KENNUNG)) {pos++;} /*Kennung ueberspringen*/
 
    /* Rand 2: Position suchen */
    while ((i = (bordercode[pos]<<1)+(!bb)) < restentfernung)
      /* Gleichheit ist unmoeglich, darum "<" dasselbe wie "<=" */
      /* klappt auch bei BB (Bedingung immer falsch) */
      {pos++;  restentfernung -= i;}
    
    /* Rand 2: */
    len1 = 0;
    randcode1[len1++] = 0;
    if (e->nahtlen&1) {randcode1[len1++] = e->nahtlen>>1;}
    else {randcode1[len1++] = (e->nahtlen>>1)-1;  randcode1[len1++] = 0;}
    if (bb) {randcode1[len1++] = bordercode[pos]-1;}
    else {
      randcode1[len1++] = ((i-restentfernung)>>1)-1;
      pos++;
      memcpy(&randcode1[len1],&bordercode[pos],sizeof(KNOTENTYP)*
             (bordercode[e->zielrand+2]-pos));  
             /* restlicher Randcode (unveraendert) */
      len1 += bordercode[e->zielrand+2]-pos;
      memcpy(&randcode1[len1],&bordercode[bordercode[e->zielrand+1]],
             sizeof(KNOTENTYP)*(pos-1-bordercode[e->zielrand+1]));
      len1 += pos-1-bordercode[e->zielrand+1];
      randcode1[len1++] = restentfernung>>1;   /* bis zur Kerbe */
    }
    if (e->nahtlen&1) {randcode1[len1++] = 0;}
    randcode1[len1++] = e->nahtlen>>1;

    /* Rand 1: */
    pos = bordercode[1];
    if (bb = (bordercode[pos]==BB_KENNUNG)) {pos++;}  /*Kennung ueberspringen*/
    randcode1[len1++] = bordercode[pos++]-1;
    memcpy(&randcode1[len1],&bordercode[pos],sizeof(KNOTENTYP)*
           (bordercode[2]-pos));
    len1 += bordercode[2]-pos;
    if (!bb) {randcode1[len1++] = 0;}
    bk1 = len1;   bk2 = 0;
  }

  if (bk1>bk_max || bk2>bk_max) {return(False);}
     /* einer der Patches hat mehr Bruchkanten, als bei der erlaubten
        Flaechenkombination theoretisch moeglich waere */

  /* nun Codes maximieren (fuer die Kopien ist immer Platz): */
  memcpy(&randcode1[len1],randcode1,sizeof(KNOTENTYP)*len1);
  offset1 = mache_maximal_und_ermittle_wh(randcode1,len1,&wh1);
  (e->i).pos = (len1-offset1)%wh1;
  if (e->art!=VERBINDUNG) {   /* sonst fehlt Code */
    memcpy(&randcode2[len2],randcode2,sizeof(KNOTENTYP)*len2);
    offset2 = mache_maximal_und_ermittle_wh(randcode2,len2,&wh2);
    (e->j).pos = (len2-offset2)%wh2;
  }
  else {(e->j).pos = ((e->i).pos + 3 + ((e->nahtlen&1)==0) +  
        (bordercode[bordercode[e->zielrand+1]]==BB_KENNUNG ? 0 :
         bordercode[e->zielrand+2] - bordercode[e->zielrand+1])) % len1;}
  /* und neue Bordercodes sortieren: */
  if (code2) {zeiger1 = &randcode1[offset1];  
              zeiger2 = &randcode2[offset2];}
  else if (e->art==VERBINDUNG) {zeiger1 = &randcode1[offset1];  zeiger2 = nil;
                                vertauscht = False;    (e->j).nr = e->ziellen;}
  else {   /* 2 Raender in einem Patch - vorsortieren */
    if (vergleiche_codes(&randcode1[offset1],len1,
                         &randcode2[offset2],len2)<0) { 
      zeiger1 = &randcode2[offset2];  zeiger2 = &randcode1[offset1];  
      i = len1;  len1 = len2;  len2 = i;
      i = wh1;    wh1 = wh2;    wh2 = i;
      vertauscht = True;
    }
    else {zeiger1 = &randcode1[offset1];  zeiger2 = &randcode2[offset2];
          vertauscht = False;}
  } 

  /* nun Randcodes sortieren: */
  /* Der/die durch die Zerschneidung entstehenden Randcode(s) werden an die 
     passende Stelle in den Bordercodes einsortiert. Wenn 2 Patches entstehen,
     wird "randcode1" immer dem ersten und "randcode2" immer
     dem zweiten Patch zugerechnet. Falls nur ein Patch entsteht und zwei 
     Raender einsortiert werden muessen, so sind die beiden Randcodes 
     untereinander bereits sortiert. Die Raender 0 und "zielrand" des Vaters
     gelten als zerstoert, so dass die zugehoerigen Raender nicht einsortiert
     werden. Ansonsten befindet sich die Aufteilung der bisherigen Raender 
     fuer die beiden Patches in "aufteilung", falls 2 Patches entstehen. */
  anz1 = anz2 = 0;     /* fuer die Bordercodes */
  for (i=1; i<bordercode[0]; i++) {     /* erster Rand ist zerstoert */
    if (e->art!=VERBINDUNG || i!=e->zielrand) {
      if (!code2 || IS_PATCH1(e->aufteilung,i)) 
         {anz1++;   bk1 += (bordercode[bordercode[i+1]]!=BB_KENNUNG ?
                           bordercode[i+2]-bordercode[i+1] : 0);}
         /* Anzahl Raender und Bruchkanten hochzaehlen */  
      else if (IS_PATCH2(e->aufteilung,i))
         {anz2++;   bk2 += (bordercode[bordercode[i+1]]!=BB_KENNUNG ?
                           bordercode[i+2]-bordercode[i+1] : 0);}
      else {fprintf(stderr,"Logischer Fehler in berechne_umrandungen!\n");
            exit(94);}
    }
  }
  if (code2) {anz1++;  anz2++;} 
  else {anz1++;  if (zeiger2) {anz1++;}}    /* neue Raender hinzurechnen */
    
  if (bk1+6*(anz1-1)>bk_max || (code2 && bk2+6*(anz2-1)>bk_max)) 
     {return(False);}
     /* Einer der Patches hat mehr Bruchkanten, als bei der erlaubten
        Flaechenkombination theoretisch moeglich waere. Da "bk_max" auch die
        Groesse der Arrayteile bestimmt, in denen die Bordercodes gleich
        gespeichert w(u)erden, ist die Abfrage an dieser Stelle unerlaesslich,
        um Speicherueberschreitungen zu vermeiden.
        Fuer jeden zusaetzlichen Rand koennen 6 Bruchkanten berechnet werden */

  code1[0] = anz1;   code1[1] = anz1+2; 
  if (code2) {code2[0] = anz2;  code2[1] = anz2+2;}
  pos1 = pos2 = 1;    /* letzte belegte Positionen in den neuen Bordercodes */
  r1 = False;   r2 = (zeiger2==nil);
  if (code2) {
    for (i=1; i<bordercode[0]; i++) {
      if (e->art!=VERBINDUNG || i!=e->zielrand) {
        if (IS_PATCH1(e->aufteilung,i)) {    /* Rand fuer Patch 1 */
          if (!r1 && vergleiche_codes(zeiger1,len1,
                     &bordercode[bordercode[i+1]],
                     bordercode[i+2]-bordercode[i+1])>=0) {
            /* neuer Rand muss eingesetzt werden */
            code1[pos1+1] = code1[pos1] + len1;
            (e->i).nr = pos1-1;
            per_td[0][pos1-1][index] = randlaenge(zeiger1,0,wh1-1);
            /* man beachte: "randlaenge" kann aufgerufen werden, weil "zeiger1"
               nie auf einen Bauchbindenrand zeigt */
            memcpy(&code1[code1[pos1]],zeiger1,sizeof(KNOTENTYP)*len1);
            pos1++;   r1 = True;    /* neuen Rand kopiert */
          }
          /* alten Rand kopieren: */
          code1[pos1+1] = code1[pos1] + bordercode[i+2] - bordercode[i+1];
          per_td[0][pos1-1][index] = per_td[vorg][i][vater];
          memcpy(&code1[code1[pos1]],&bordercode[bordercode[i+1]],
                 sizeof(KNOTENTYP)*(bordercode[i+2]-bordercode[i+1]));
          pos1++;    /* Rand kopiert */
        }
        else {            /* Rand fuer Patch 2 */
          if (!r2 && vergleiche_codes(zeiger2,len2,
                     &bordercode[bordercode[i+1]],
                     bordercode[i+2]-bordercode[i+1])>=0) {
            code2[pos2+1] = code2[pos2] + len2;
            (e->j).nr = pos2-1;
            per_td[1][pos2-1][index] = randlaenge(zeiger2,0,wh2-1);
            memcpy(&code2[code2[pos2]],zeiger2,sizeof(KNOTENTYP)*len2);
            pos2++;   r2 = True;    /* neuen Rand kopiert */
          }
          code2[pos2+1] = code2[pos2] + bordercode[i+2] - bordercode[i+1];
          per_td[1][pos2-1][index] = per_td[vorg][i][vater];
          memcpy(&code2[code2[pos2]],&bordercode[bordercode[i+1]],
                 sizeof(KNOTENTYP)*(bordercode[i+2]-bordercode[i+1]));
          pos2++;    /* Rand kopiert */
        }
      }
    }
    if (!r1) {     /* neuer Rand muss noch eingesetzt werden */
      code1[pos1+1] = code1[pos1] + len1;
      (e->i).nr = pos1-1;
      per_td[0][pos1-1][index] = randlaenge(zeiger1,0,wh1-1);
      memcpy(&code1[code1[pos1]],zeiger1,sizeof(KNOTENTYP)*len1);
      pos1++;   r1 = True;    /* neuen Rand kopiert */
    }
    if (!r2) {     /* neuer Rand muss noch eingesetzt werden */
      code2[pos2+1] = code2[pos2] + len2;
      (e->j).nr = pos2-1;
      per_td[1][pos2-1][index] = randlaenge(zeiger2,0,wh2-1);
      memcpy(&code2[code2[pos2]],zeiger2,sizeof(KNOTENTYP)*len2);
      pos2++;   r2 = True;    /* neuen Rand kopiert */
    }
  }
  
  else {     /* beide neuen Raender in einen Patch */
    for (i=1; i<bordercode[0]; i++) {
      if (e->art!=VERBINDUNG || i!=e->zielrand) {
        r_alt = False;       /* Randcode i noch nicht eingesetzt */
        if (!r1 /* && !r_alt */) {
          if (vergleiche_codes(zeiger1,len1,&bordercode[bordercode[i+1]],
                               bordercode[i+2]-bordercode[i+1])<0) {
            code1[pos1+1] = code1[pos1] + bordercode[i+2] - 
                               bordercode[i+1];
            per_td[0][pos1-1][index] = per_td[vorg][i][vater];
            memcpy(&code1[code1[pos1]],&bordercode[bordercode[i+1]],
                   sizeof(KNOTENTYP)*(bordercode[i+2]-bordercode[i+1]));
            pos1++;   r_alt = True;    /* Rand kopiert */
          }
          else {     /* neuer Rand 1 muss eingesetzt werden */
            code1[pos1+1] = code1[pos1] + len1;
            if (vertauscht) {(e->j).nr = pos1-1;} else {(e->i).nr = pos1-1;}
            per_td[0][pos1-1][index] = randlaenge(zeiger1,0,wh1-1);
            memcpy(&code1[code1[pos1]],zeiger1,sizeof(KNOTENTYP)*len1);
            pos1++;   r1 = True;    /* neuen Rand 1 kopiert */
          }
        }
        if (!r2 && !r_alt) {   /* es gibt noch Vergleichsmoeglichkeit */
          if (vergleiche_codes(zeiger2,len2,
              &bordercode[bordercode[i+1]],bordercode[i+2]-
              bordercode[i+1])<0) { 
            code1[pos1+1] = code1[pos1] + bordercode[i+2] - bordercode[i+1];
            per_td[0][pos1-1][index] = per_td[vorg][i][vater];
            memcpy(&code1[code1[pos1]],&bordercode[bordercode[i+1]],
                   sizeof(KNOTENTYP)*(bordercode[i+2]-bordercode[i+1]));
            pos1++;   r_alt = True;   /* Rand kopiert */
          }
          else {      /* neuer Rand 2 muss eingesetzt werden */
            code1[pos1+1] = code1[pos1] + len2;
            if (vertauscht) {(e->i).nr = pos1-1;} else {(e->j).nr = pos1-1;}
            per_td[0][pos1-1][index] = randlaenge(zeiger2,0,wh2-1);
            memcpy(&code1[code1[pos1]],zeiger2,sizeof(KNOTENTYP)*len2);
            pos1++;   r2 = True;    /* neuen Rand 2 kopiert */
          }
        }
        if (!r_alt) {     /* alter Rand muss eingesetzt werden */
          code1[pos1+1] = code1[pos1] + bordercode[i+2] - bordercode[i+1];
          per_td[0][pos1-1][index] = per_td[vorg][i][vater];
          memcpy(&code1[code1[pos1]],&bordercode[bordercode[i+1]],
                 sizeof(KNOTENTYP)*(bordercode[i+2]-bordercode[i+1]));
          pos1++;   r_alt = True;   /* Rand kopiert */
        }
      }
    }
    if (!r1) {     /* neuer Rand 1 muss noch eingesetzt werden */
      code1[pos1+1] = code1[pos1] + len1;
      if (vertauscht) {(e->j).nr = pos1-1;} else {(e->i).nr = pos1-1;}
      per_td[0][pos1-1][index] = randlaenge(zeiger1,0,wh1-1);
      memcpy(&code1[code1[pos1]],zeiger1,sizeof(KNOTENTYP)*len1);
      pos1++;   r1 = True;    /* neuen Rand kopiert */
    }
    if (!r2) {     /* neuer Rand 2 muss noch eingesetzt werden */
      code1[pos1+1] = code1[pos1] + len2;
      if (vertauscht) {(e->i).nr = pos1-1;} else {(e->j).nr = pos1-1;}
      per_td[0][pos1-1][index] = randlaenge(zeiger2,0,wh2-1);
      memcpy(&code1[code1[pos1]],zeiger2,sizeof(KNOTENTYP)*len2);
      pos1++;   r2 = True;    /* neuen Rand kopiert */
    }
  }
  
  if (!pruefe_bordercode(code1) || (code2 && !pruefe_bordercode(code2))) 
     {return(False);}

  /* hier: alle Tests ueberstanden */
  anz3_td[0][index] = anzahl_3_val_randknoten(code1);
  if (code2) {anz3_td[1][index] = anzahl_3_val_randknoten(code2);}
  return(True);
}

/*******************MARKIERE_N_ECK******************************************/
/* Rechts von der Kante "k" befindet sich ein n-Eck. Diese Funktion geht ein-
   mal herum und markiert alle benachbarten Kanten. Desweiteren setzt sie
   die "connfl"-Werte. */

void markiere_n_eck(FLAECHENTYP n,KANTE *k,KNOTENTYP connfl) {
  static FLAECHENTYP i;
  for (i=0; i<n; i++) {
    k->fl_rechts = n;
    k->connfl = connfl;
    k = k->invers->prev;
  }
} 

/****************VERKLEBE_RAENDER*******************************************/
/*  Gegeben ist ein Stammpatch mit den "anz" Grundkanten in "stammgk" sowie 
    das top-down-Geruest mit den Grundkanten "gk". Die passenden Grundkanten 
    sowie die dazugehoerigen Raender werden miteinander verklebt.          */
/*  Die Raender des Stammpatches werden aufgeloest.                        */  

void verklebe_raender(KANTE **gk,KANTE **stammgk,KNOTENTYP anz) {
  static KANTE *k,*k2;
  static KNOTENTYP i;
  for (i=0; i<anz; i++) {
    k = gk[i];   k2 = stammgk[i];
    do {
      k->fl_rechts = k2->fl_rechts; 
      if (!k->next) {
        k->next = k->prev->prev = k2->next;
        k2->next->prev = k;   k2->next->next = k->prev;
      }
      if (k2->invers->next) {k = k->invers->next;  k2 = k2->invers->next;}
      else                  {k = k->invers->prev;  k2 = k2->invers->prev;} 
    } while (k != gk[i]);
  }
}

/*********************KONSTRUIERE_PATCH_TOP_DOWN****************************/
/* Konstruiert den Patch, der in der History an Stelle "index" steht, 
   rekursiv. Der Patch wird an m uebergeben,
   der zugehoerige Bordercode an "ergcode". Die Funktion wird bei der
   Top-Down-Generierung aufgerufen, weshalb alle Tests, die bei Bottom-Up-
   Generierung durchlaufen worden waeren, nachgeholt werden muessen. 
   Weitere Kommentare siehe "konstruiere_patch_in_rekursion".              */
/* "l" ist der Level, der in der Funktion "setze_history_weiter" ermittelt 
   wurde (in dem die letzte Aenderung vorgenommen wurde).                  */
/* Die Funktion gibt die Position in der history zurueck, bis zu der die
   Konstruktion anstandslos geklappt hat. Falls dies der Wert "top_level" ist,
   so wurde der gesamte Patch erfolgreich konstruiert. Andernfalls kann die
   aufrufende Funktion den uebergebenen Wert dazu benutzen, in der history
   soweit weiterzugehen, bis der Patch in der betreffenden Position auch
   tatsaechlich geaendert wird.  Dazu muss immer erst derjenige Vorgaenger
   konstruiert werden, der weiter unten in der History steht, so dass
   die History sauber von hinten nach vorn konstruiert wird.               */

POSTYP konstruiere_patch_top_down(KANTENARRAY m,POSTYP *start,POSTYP index,
       POSTYP l,POSTYP top_level,KNOTENTYP *connfl) {
  static KNOTENTYP zielrand;      /* vor dem zweiten Sortiervorgang */
  static KNOTENTYP i,i1,i2;
  static KNOTENTYP anf3,len3,anf4,len4;
  static POSTYP erg;            /* Inhalt wird direkt verwertet */
  static POSTYP arraypos;
  /* die folgenden Variablen sind natuerlich NICHT static wegen Rekursion */
  KANTE **gk;
  KANTE *k1,*k2;       /* Zeiger auf die Grundkanten in den Raendern, die
                          miteinander verklebt werden sollen. */
  ELEM *e;
  KNOTENTYP *bordercode,*code1,*code2;
  e = &history[index];
  gk = gk_td[index];
  bordercode = bc_td[vor[index]][vater_nr[index]];

  /* e==nil ist unmoeglich in top-down-Konstruktion */
  if (e->stamm) {        /* "e" normal konstruieren */
    arraypos = 0;
    konstruiere_patch(m,start,bordercode,e,gk,nil,connfl,&arraypos);
    return(index);
  }

  /* ab hier gilt: "e" ist kein Stammpatch */
  code1 = bc_td[0][index];
  code2 = e->vorg==2 ? bc_td[1][index] : nil;
  if (code2) {    /* es gibt 2 Vorgaenger - zuerst den weiter hinten stehenden
                     Vorgaenger konstruieren */    
    if (e->prev2->his_nr > e->prev1->his_nr) {    /* zuerst Patch 2 */
      if ((erg = konstruiere_patch_top_down(m,start,e->prev2->his_nr,
                 l,top_level,connfl)) > e->prev2->his_nr) {return(erg);}
      if ((erg = konstruiere_patch_top_down(m,start,e->prev1->his_nr,
                 l,top_level,connfl)) > e->prev1->his_nr) {return(erg);}
    }
    else {                                        /* zuerst Patch 1 */
      if ((erg = konstruiere_patch_top_down(m,start,e->prev1->his_nr,
                 l,top_level,connfl)) > e->prev1->his_nr) {return(erg);}
      if ((erg = konstruiere_patch_top_down(m,start,e->prev2->his_nr,
                 l,top_level,connfl)) > e->prev2->his_nr) {return(erg);}
    }
    k1 = gk_td[e->prev1->his_nr][(e->i).nr];
    anf3 = code1[(e->i).nr+1];         /* Anfang des relevanten Randcodes */
    len3 = code1[(e->i).nr+2]-anf3;    /* Laenge des Randcodes */
    k2 = gk_td[e->prev2->his_nr][(e->j).nr];
    anf4 = code2[(e->j).nr+1];         /* Anfang des relevanten Randcodes */
    len4 = code2[(e->j).nr+2]-anf4;    /* Laenge des Randcodes */
  }
  else {     /* es gibt nur einen Vorgaenger */
    /* Vorgaenger konstruieren: */
    if ((erg = konstruiere_patch_top_down(m,start,e->prev1->his_nr,
               l,top_level,connfl)) > e->prev1->his_nr) {return(erg);}
    k1 = gk_td[e->prev1->his_nr][(e->i).nr];
    anf3 = code1[(e->i).nr+1];           /* Anfang des relevanten Randcodes */
    len3 = code1[(e->i).nr+2]-anf3;      /* Laenge des Randcodes */
    if (e->art!=VERBINDUNG) {
      k2 = gk_td[e->prev1->his_nr][(e->j).nr];
      anf4 = code1[(e->j).nr+1];         /* Anfang des relevanten Randcodes */
      len4 = code1[(e->j).nr+2]-anf4;    /* Laenge des Randcodes */
    }
    else {                               /* Fall 1 */
      k2 = gk_td[e->prev1->his_nr][(e->i).nr];  
      anf4 = code1[(e->i).nr+1];  
      len4 = code1[(e->i).nr+2]-anf4;
    }
  }

  /* kanonische Vorgaenger verkleben: Vortests */
  if (index<=l) {    /* Flaechenzahlen pruefen */
    if (facerestrict && !flaechenzahlen2_ok(e->prev1,e->prev2)) 
       {return(index+1);}  
    if (!NON_ISO_RAND(e->prev1,(e->i).nr) ||
        (e->prev2 && !NON_ISO_RAND(e->prev2,(e->j).nr))) 
        {return(index+1);}
        /* Raender duerfen nicht verklebt werden */
  } 
  mache_verknuepfung(k1,&code1[anf3],(e->i).pos,len3,k2,
                     e->prev2 ? &code2[anf4] : &code1[anf4],(e->j).pos,len4,
                     &k1,&k2,e->art,e->nahtlen,e->ziellen);
  gk[0] = k1;                 /* neue Grundkante */
  if (e->art==VERBINDUNG) {k2 = suche_kante((e->j).nr,k2);}   
     /* Fall 1 --- Grundkante suchen */  
  /* neue Grundkanten uebertragen: */
  i1 = i2 = 0;    /* Anzahl uebertragener Grundkanten aus den Vorgaengern */
  for (i=1; i<bordercode[0]; /* nix tun */) {
    if (e->vorg==1) {
      if (e->art==VERBINDUNG && i==e->zielrand) {gk[i++] = k2;}  
         /* neue Grundkante */
      if ((e->i).nr!=i1 && (e->art==VERBINDUNG || (e->j).nr!=i1))   
         {gk[i++] = gk_td[e->prev1->his_nr][i1];}   /* uebernehmen */
      i1++;
      if (e->art==VERBINDUNG && i==e->zielrand) {gk[i++] = k2;} 
         /* hier nochmal, falls neuer Rand letzter Rand ist, damit danach 
            "i==bordercode[0]" gilt und die for-Schleife sofort abgebrochen 
            wird */           
    }
    else if (IS_PATCH1(e->aufteilung,i)) {    /* erster von 2 Vorgaengern */
      if ((e->i).nr!=i1) {gk[i++] = gk_td[e->prev1->his_nr][i1];}
      i1++;
    }
    else {                                          /* zweiter Vorgaenger */
      if ((e->j).nr!=i2) {gk[i++] = gk_td[e->prev2->his_nr][i2];}
      i2++;
    }
  }
 
  /* neuen Bordercode und neue Grundkanten berechnen: */
  zielrand = e->zielrand;
  sortiere_randcodes2(bordercode,gk,&zielrand);
  /* Zielrand wurde evtl. verschoben, aber das ist beabsichtigt */

  /* erzeugten Patch testen: */
  if (index<=l) {   /* isomorphe Raender markieren und Tests durchfuehren */
    /* Falls index>l, so bleiben isomorphe Raender erhalten und die Tests
       ergeben ebenfalls nichts Neues */
    if (!muss_patch_konstruiert_werden(e,e->prev2==nil || e->art==EINSCHLUSS,
        bordercode,e->art==VERBINDUNG,zielrand,his_acc[index],True,gk,True,
        True,index==top_level,0)) {return(index+1);}
        /* Test 2 bei "muss_patch_konstruiert_werden" nur im obersten Level */
  }
  return(index);
}           
     
     
/**********************************************************/
/* Funktionen zur Konstruktion von Graphen (aus Patches): */
/**********************************************************/

/******************VERGLEICHE_PATCHES****************************************/
/*  Vergleicht die Patches "e1" und "e2".
    Sind sie gleich, so wird "True" zurueckgegeben.                         */

BOOL vergleiche_patches(ELEM *e1,ELEM *e2) {
  static POSTYP index1,index2,vater1,vater2;
  static char vor1,vor2;
  if (e1->stamm != e2->stamm) {return(False);}
  if (e1->stamm) {   /* Verklebungen und Vorgaenger miteinander vergleichen */
    return(e1->prev1==e2->prev1 && e1->prev2==e2->prev2 && e1->art==e2->art &&
           e1->i.pos==e2->i.pos && e1->j.pos==e2->j.pos && e1->i.nr==e2->i.nr 
           && e1->j.nr==e2->j.nr);    /* => (e1->nr == e2->nr) */
    /* Da "e1" und "e2" Stammpatches sind, sind "i" und "j" in jedem Fall
       mit korrekten Werten belegt. */
  }
  /* Ab hier gilt: beide Patches stehen in der History. Insbesondere wurden
     die Patches top-down erzeugt, denn in der bottom-up-Konstruktion kann
     maximal ein Patch kein Stammpatch sein. */
  index1 = e1->his_nr;        index2 = e2->his_nr;
  vater1 = vater_nr[index1];  vater2 = vater_nr[index2];
  vor1 = vor[index1];         vor2 = vor[index2];
  if (e1->vorg != e2->vorg  ||  e1->nahtlen != e2->nahtlen ||
      e1->ziellen != e2->ziellen  ||  e1->zielrand != e2->zielrand) 
     {return(False);}
  if (fl_td[0][index1] != fl_td[0][index2]  || 
      krit_td[0][index1] != krit_td[0][index2]  ||
      g_td[0][index1] != g_td[0][index2]  ||
      (e1->vorg==2 && (fl_td[1][index1] != fl_td[1][index2]  ||
                       krit_td[1][index1] != krit_td[1][index2]  || 
                       g_td[1][index1] != g_td[1][index2]  ||
      memcmp(e1->aufteilung,e2->aufteilung,sizeof(unsigned char)*R_ARRAY))) ||
      memcmp(bc_td[vor1][vater1],bc_td[vor2][vater2],sizeof(KNOTENTYP)*
             bc_td[vor1][vater1][bc_td[vor1][vater1][0]+1])  || 
      memcmp(e1->iso_rand,e2->iso_rand,sizeof(unsigned char)*
             (((bc_td[vor1][vater1][0]-1)>>3)+1))) {return(False);}
  if (e1->prev1 && e2->prev1) {
    if (!vergleiche_patches(e1->prev1,e2->prev1)) {return(False);}
  }
  else {fprintf(stderr,"Logischer Fehler in vergleiche_patches!\n");
        exit(26);}
  if (e1->vorg==2) {
    if (e1->prev2 && e2->prev2) {
      if (!vergleiche_patches(e1->prev2,e2->prev2)) {return(False);}
    }
    else {fprintf(stderr,"Logischer Fehler 2 in vergleiche_patches!\n");
          exit(27);}
  }
  return(True);
}

/*******************SORTIERE_STATISTIK_IN_BAUM****************************/
/*  "f" zeigt auf eine aufsteigend sortierte Liste mit Laenge "len" von 
    Flaechen, die zu einer Einbettung gehoert.                           */

void sortiere_statistik_in_baum(FLAECHENTYP *f,KNOTENTYP len) {
  static KNOTENTYP l;
  static STATTREENODE *t, *t2, *t3, *t4; 
  l = 0; 
  while (l<len) {         /* noch nicht am Ende des Codes */
    if (l==0) {t=facestatbaum;} else {t4=t; t=t->nextlevel;}
    t2 = nil;
    while (t && t->code<f[l]) {t2=t; t=t->next;}
    if (t==nil || t->code!=f[l]) {  /* neuen Baumknoten einrichten */
      t3 = (STATTREENODE *)hole_speicher(sizeof(STATTREENODE),False,True);
      if (t2==nil)
        {if (l==0) {facestatbaum = t3;} else {t4->nextlevel = t3;} }
      else {t2->next = t3;}
      t3->next = t;      t3->zaehler = 0;
      t3->code = f[l];   t3->nextlevel = nil;
      t = t3;        /* t ist Liste, in die eingeordnet wird */
    }      /* if */
    l++;
  }        /* while */

  /* Zaehler am Blatt heraufsetzen: */
  t->zaehler++;
}   

/************************GUTER_GRAPH*****************************************/
/*  Diese Funktion verarbeitet einen guten Graphen m mit n Knoten und 
    Geschlecht g: 
    Sie gibt ihn aus und sie erstellt eventuell die Flaechenstatistik (dann
    sind e1-e3 die Zeiger auf den/die Patches, evtl. e2/e3==nil             */
/*  Falls "is_code==True", so enthaelt "graph" bereits den auszugebenden
    Planarcode, andernfalls wird er innerhalb der Funktion berechnet.       */
/*  "connerg" ist nur wichtig, wenn "do_conn==True".                        */
/*  "faceconnerg" enthaelt u.a. einen gueltigen Wert, wenn "dual==True"     */
/*  "hislen" ist nur im topdown-Modus wichtig.                              */

void guter_graph(KNOTENTYP g,KNOTENTYP n,PLANMAP m,ELEM *e1,ELEM *e2,ELEM *e3,
                 KNOTENTYP *graph,BOOL is_code,unsigned char connerg,
                 unsigned char faceconnerg,POSTYP hislen) {
  static KNOTENTYP i,j;
  static size_t size;
  static FLAECHENTYP faces[MAXFTYPEN];

  if (recover) {fprintf(stderr,"Luecke bei Recover-Abschirmung!\n"); exit(28);}
     /* bis hierhin kann das Programm nicht kommen, wenn "recover==True" */

  /* Karte schreiben */
  if (output) {
    if (dual) {
      if (faceconnerg==3) {
        size = dualplanarcode(graph,m,n,g);   /* "graph" ist gross genug */
        schreibe_planarcode(graph,ARRAYPOS_N(g,n),size);
      }
      else {      /* Loops und Doppelkanten */
        size = dualembedcode(graph,m,n,g);   /* "graph" ist gross genug */
        schreibe_embedcode(graph,ARRAYPOS_N(g,n),size);
      }
    } 
    else {
      size = CODESIZE(n);
      if (doppelkanten) {
        if (!is_code) {map_2_embedcode(m,graph,n);}
        schreibe_embedcode(graph,ARRAYPOS_N(g,n),size);
      }
      else {
        if (!is_code) {map_2_planarcode(m,graph,n);}
        schreibe_planarcode(graph,ARRAYPOS_N(g,n),size);
      }
    }
  }

  /* Zusammenhangsstatistik */
  if (do_conn) {connzahl[ARRAYPOS_LN(g,n,connerg)]++;}

  /* Flaechenstatistik */
  if (facestat) {
    j = 0;         /* Index auf passendes Arrayelement */
    for (i=0; i<anz_face; i++) {
      if ((e1 && (e1->flaechenzahl)[i]) || (e2 && (e2->flaechenzahl)[i]) || 
          (e3 && (e3->flaechenzahl)[i]))
         {faces[j++] = face[i];}  /* i-te Flaeche ist in der Karte enthalten */
    }
    sortiere_statistik_in_baum(faces,j);
  }
}
          
/*********************GIBT_ES_DOPPELKANTE_IN_GRAPH***************************/
/*  Diese Funktion prueft, ob der S3Z-Graph "g" eine Doppelkante oder einen
    Loop enthaelt. "g" liegt im planar_code vor.                            */

BOOL gibt_es_doppelkante_in_graph(KNOTENTYP *g) {
  static KNOTENTYP n;
  static POSTYP i,end; 

  end = (POSTYP)g[0]<<2;    /* Knotenzahl*4 */
  for (i=0L; i<(POSTYP)end; i+=4) {
    if (g[i+1]==g[i+2] || g[i+1]==g[i+3] || g[i+2]==g[i+3]) {return(True);}
  }
  return(False);
}    
   
/********************ISO_RAENDER********************************************/
/*  Diese Funktion prueft, ob die Raender mit den Grundkanten Nummer "gk1"
    und "gk2" im Patch "e" isomorph sind. "gk1" ist immer 0 oder 1 und "gk2"
    ist immer 1 oder 2. "gk1" ist immer ungleich "gk2".                    */

BOOL iso_raender(ELEM *e,KNOTENTYP gk1,KNOTENTYP gk2) {
  if (gk2-gk1==1) {return(!NON_ISO_RAND(e,gk2));}  /* "gk2" folgt auf "gk1" */
  else {return(!(NON_ISO_RAND(e,gk2) || NON_ISO_RAND(e,gk2-1)));}
       /* Ist gk2 isomorph zu gk2-1 und gk2-1 isomorph zu gk2-2(==gk1)? */
}

/****************STARTE_HISTORY**********************************************/
/* Falls Patchcheck vorgenommen wurde:  Diese Funktion stellt die history
   auf den ersten akzeptierten Patch.                                       */

void starte_history(POSTYP his_anz) {
  static POSTYP i,checkpos;
  static FLAECHENTYP f;
  static unsigned long anz,pos;
  static char vor;     /* gibt an, was vorgesetzt werden soll:
                          0 = j.nr (nur bei Fall 1), 1 = prev1, 2 = prev2 */
  static BOOL tiefer;  /* tiefer==True  =>  Level nach unten */
  static KNOTENTYP ii;
  checkpos = 0;
  for (i=his_anz-1; i>=0; i--) {       /* Rekursionslevel durchgehen */
    his_check_count[i] = pos = his_check[checkpos][i];    /* erste Position */
    checkpos = 0;   /* schon fuer naechsttieferen Level */
    anz = 0L;       /* Anzahl der Variationsmoeglichkeiten in einem Level */
    vor = 0;    
    while (pos>0) {               /* weitersetzen */
      pos--;  anz++;   /* bei jedem Schleifendurchlauf wird weitergesetzt */
      if (vor==0) {
        if (history[i].art==VERBINDUNG) {      /* Fall 1 */
          history[i].j.nr += his_rl2[i];
          if (history[i].j.nr >= his_rlg2[i]) 
             {history[i].j.nr = hiscopy[i].j.nr;  vor = 1;}  
        }
        else {vor = 1;}
      }
      if (vor==1) {  
        if ((history[i].prev1)->stamm) {       /* vorsetzen erlaubt */
          if ((history[i].prev1)->next)        /* vorsetzen moeglich */
             {history[i].prev1 = (history[i].prev1)->next;  vor = 0;}
          else {history[i].prev1 = hiscopy[i].prev1;  vor = 2;} 
        }
        else {vor = 2;}
      }   
      if (vor==2) {
        vor = 0;
        if (history[i].prev2 && (history[i].prev2)->stamm) {  
          if ((history[i].prev2)->next)
             {history[i].prev2 = (history[i].prev2)->next;  tiefer = False;}
          else {history[i].prev2 = hiscopy[i].prev2;  tiefer = True;}
        }
        else {tiefer = True;}
        if (tiefer) {                       /* naechsttieferen Level */ 
          if (i==0) {fprintf(stderr,"Dicker Fehler in starte_history %d!\n",
                     his_anz);  exit(29);}
          checkpos = pos/anz+1;   /* so viele AKZEPTIERTE Eintraege im 
                                  naechsttieferen Level werden uebersprungen */
          pos = pos%anz;    /* denn alle "anz" Durchlaeufe passiert dasselbe */
          tiefer = False;   /* nochmal wird diese Zeile nicht erreicht */
        }
      }
    }
  }

  if (facenumbers) {
    for (i=0; i<his_anz; i++) {  /* Flaechenzahlen aktualisieren */
      if (history[i].prev2) {
        for (f=0; f<anz_face; f++) 
          {(history[i].flaechenzahl)[f] = 
           ((history[i].prev1)->flaechenzahl)[f] + 
           ((history[i].prev2)->flaechenzahl)[f];}
      }
      else {memcpy(history[i].flaechenzahl,(history[i].prev1)->flaechenzahl,
            sizeof(KNOTENTYP)*(size_t)anz_face);}
    } 
  }

  /* Iso-Raender im obersten Level korrekt bestimmen (das ist in Wirklichkeit
     je nach Aufruf der oberste oder zweitoberste Level) */
  for (ii=0; ii<=G_MAX>>3; ii++) 
      {(history[his_anz-1].iso_rand)[ii] = 
        his_check_iso_rand[his_check_pos[his_anz-1]][ii][his_anz-1];}
}

/****************SETZE_HISTORY_WEITER****************************************/
/* Diese Funktion setzt die in der History gegebene implizite Liste der 
   Patches um einen gueltigen Patch weiter. Der niedrigste Level + 1, in dem
   eine Veraenderung stattgefunden hat, wird zurueckgegeben. Falls das 
   virtuelle Listenende erreicht ist, wird 0 zurueckgegeben.
   "his_anz" ist die Anzahl der Eintraege in der History.
   "history" enthaelt die Originalhistory, in der die Zeiger manipuliert 
   werden, und "hiscopy" die Kopie der urspruenglichen Originalhistory, 
   so dass einzelne Eintraege wiederhergestellt werden koennen.             */
/* In "hiscopy" darf nicht manipuliert werden bzw. es nuetzt nichts, 
   da "e2" in den aufrufenden
   Funktionen auf ein Element von "history" zeigt und nicht auf "hiscopy".  */
/* Die Reihenfolge, in der die Eintraege weitergesetzt werden, geht von oben
   nach unten, so dass in den unteren Ebenen die "Zwischenpatches" nicht
   veraendert werden und dort somit keine Ueberpruefungen durchgefuehrt
   werden muessen. Es gilt: Falls als letztes eine Erhoehung eines j.nr-Wertes
   stattgefunden hat, so muessten in demselben Level die Ueberpruefungen 
   auf Flaechenzahlen und Struktur nicht durchgefuehrt werden, denn das 
   Kantengeruest bleibt unveraendert, ebenso die Flaechenzahlen (allerdings
   wird die Ueberpruefung immer durchgefuehrt). Desweiteren
   DUERFEN NICHT die "his_acc"-Werte geloescht werden, sondern sie bleiben 
   fuer alle moeglichen j.nr-Werte gueltig. Deshalb ist es wichtig, dass 
   zuerst immer die j.nr-Werte veraendert werden und dann erst die 
   prev-Zeiger, denn sonst waere diese Argumentation ungueltig.              */
/* "setze_history_weiter_rek" wird nur von "setze_history_weiter" aufgerufen.*/
/* "anfang" gibt den Level an, bei dem weitergesetzt werden soll. Alle 
   Eintraege in den darueberliegenden Levels werden zurueckgesetzt.         */
/* "use" gibt an, ob fuer den aktuellen Level das Array "his_check" benutzt
   werden soll. Beim "patchcheck" wird es nur fuer den obersten Level nicht
   benutzt, wenn kein patchcheck stattfindet, wird natuerlich auch "his_check"
   nicht benutzt.                                                           */

POSTYP setze_history_weiter_rek(POSTYP i,BOOL use) {
  static KNOTENTYP ii,jj;
  char vor;     /* gibt an, was vorgesetzt werden soll:
                   0 = j.nr (nur bei Fall 1), 1 = prev1, 2 = prev2 */
  BOOL erg,tiefer;  /* tiefer==True  =>  Level nach unten */
                    /* erg==True     =>  erfolgreich weitergesetzt */
  POSTYP l = HISTORYLEN+2; 
  erg = False;
  vor = 0;    /* "vor0" gibt es nicht mehr, weil das zu Widerspruechen in 
                 der Numerierung der Verzweigungen fuehren wuerde. */
  if (use) {his_check_pos[i]++;}  /* naechsten brauchbaren Zweig ansteuern */
  do {  /* pro Schleifendurchlauf wird vorgesetzt oder Rekursion eingeleitet */
    if (use) {his_check_count[i]++;}    /* Eintrag wird vorgesetzt werden */
    if (vor==0) {
      if (history[i].art==VERBINDUNG) {      /* Fall 1 */
        history[i].j.nr += his_rl2[i];
        if (history[i].j.nr >= his_rlg2[i]) {       /* einmal herum */ 
          history[i].j.nr = hiscopy[i].j.nr;  vor = 1;
          jj = ((his_rlg2[i]/his_rl2[i]-1)>>3)+1; 
               /* Anzahl wichtiger Elemente im akzeptiert-array */
          for (ii=0; ii<jj; ii++) {his_acc[i][ii] = 0;}   /* loeschen */
        }
        else {
          if (l>i+1) {l = i+1;}  
          erg = True;  
        }
      }
      else {vor = 1;}
    }
    if (vor==1) {    /* prev1 vorsetzen: KEIN "else" (wie frueher), denn pro
        Schleifendurchlauf muss einmal vorgesetzt werden, wenn moeglich (sonst
        Rekursion einleiten -> zusammen mit Ruecksetzen wirkt das wie
        vorsetzen */
      if ((history[i].prev1)->stamm) {       /* vorsetzen erlaubt */
        if ((history[i].prev1)->next) {      /* vorsetzen moeglich */
          history[i].prev1 = (history[i].prev1)->next;  erg = True;  vor = 0;
          if (l>i+1) {l = i+1;}  
        }
        else {history[i].prev1 = hiscopy[i].prev1;  vor = 2;} 
             /* zuruecksetzen */
      }
      else {vor = 2;}
    }  
    if (vor==2) {                        /* prev2 vorsetzen */
      vor = 0;
      if (history[i].prev2 && (history[i].prev2)->stamm) {  
         /* vorsetzen moeglich und erlaubt */
        if ((history[i].prev2)->next) {      /* vorsetzen moeglich */
          history[i].prev2 = (history[i].prev2)->next;  erg = True;
          tiefer = False;
          if (l>i+1) {l = i+1;}  
        }
        else {history[i].prev2 = hiscopy[i].prev2;  tiefer = True;}
      }
      else {tiefer = True;}
      if (tiefer) {                       /* naechsttieferen Level */
        if (i==0) {return(0);}            /* geht nicht mehr */
        else {
          l = setze_history_weiter_rek(i-1,pco);
          /* "his_check" in niedrigen Leveln bei "patchcheck" immer nutzen */
          if (l>0) {erg = True;}   /* etwas in niedrigeren Leveln gefunden */
          else {return(0);}
        }
      }
    }
    if (erg==True && use) { 
      /* ist der Patch in der gueltigen Liste? */
      if (his_check_count[i]<his_check[his_check_pos[i]][i]) 
         {erg = False;  vor = 0;}
         /* laufende Nummer noch zu klein => weitermachen */
    }
  } while (erg==False);   /* fuer jeden Level getrennt wichtig */  
  return(l);
}

POSTYP setze_history_weiter(POSTYP his_anz,POSTYP anfang,BOOL use) {
  static POSTYP i,l;
  static FLAECHENTYP f;
  static KNOTENTYP ii,jj;

  l = setze_history_weiter_rek(anfang,use);   

  /* Iso-Raender im zweitobersten Level korrekt bestimmen 
     (!use && pco => "patch_check" laeuft) */
  if (!use && pco && l>0 && his_anz>1) {
    for (ii=0; ii<=G_MAX>>3; ii++) 
        {(history[his_anz-2].iso_rand)[ii] = 
          his_check_iso_rand[his_check_pos[his_anz-2]][ii][his_anz-2];}
  }

  /* Iso-Raender im obersten Level korrekt bestimmen 
     (use => "patch_check" laeuft nicht, sondern Kartengenerierung) */
  if (use && l>0) {
    for (ii=0; ii<=G_MAX>>3; ii++) 
        {(history[his_anz-1].iso_rand)[ii] = 
          his_check_iso_rand[his_check_pos[his_anz-1]][ii][his_anz-1];}
  }

  /* Folgende Schleifen auch dann durchlaufen, wenn l==0, damit alles 
     fuer den naechsten Durchlauf zurueckgesetzt wird: */
  if (facenumbers) {
    for (i = l==0 ? 0 : l-1; i<his_anz; i++) { 
      /* Flaechenzahlen aktualisieren */
      if (history[i].prev2) {
        for (f=0; f<anz_face; f++) 
          {(history[i].flaechenzahl)[f] = 
           ((history[i].prev1)->flaechenzahl)[f] + 
           ((history[i].prev2)->flaechenzahl)[f];}
      }
      else {memcpy(history[i].flaechenzahl,(history[i].prev1)->flaechenzahl,
            sizeof(KNOTENTYP)*(size_t)anz_face);}
    } 
  }

  for (i=anfang+1; i<his_anz; i++) {   /* obere Level zuruecksetzen */
    if (history[i].art==VERBINDUNG) {    /* Fall 1 */
      jj = ((his_rlg2[i]/his_rl2[i]-1)>>3)+1;  /* Anzahl wichtiger Elemente im 
                                                  akzeptiert-array */
      for (ii=0; ii<jj; ii++) {his_acc[i][ii] = 0;}   /* loeschen */
    }
    history[i] = hiscopy[i];
    /* Wenn anfang+1 < his_anz, dann ist entweder gar kein Patchcheck 
       eingeschaltet oder es ist ein Ueberlauf aufgetreten. Sonst kommen
       keine niedrigeren Anfangslevel als his_anz-1 vor. */
  }       
  return(l);
}

/*********************PATCH_CHECK*******************************************/
/*  Diese Funktion konstruiert aus der History heraus JEDEN implizit
    gespeicherten Patch. Wenn KEINER dieser Patches akzeptiert werden kann,
    so wird "False" zurueckgegeben, andernfalls "True".                    */
/*  Die laufenden Nummern der brauchbaren Patches in der Historyliste
    werden - getrennt fuer jeden Level - in "his_check" gespeichert. Dieses
    Array ist in seiner Groesse begrenzt. Wenn ein Ueberlauf auftritt, so
    wird der Patchcheck gestoppt.                                          */
   
BOOL patch_check(POSTYP his_anz) {
  static KANTE *gk[G_MAX+1];    /* fuer Grundkanten */
  static KNOTENTYP dummyarray[N_MAX_P+3];   /* nimmt einen Bordercode auf */
  static FLAECHENTYP f;
  static KANTENARRAY patchmap;
  static POSTYP start,erg,l,i;
  static KNOTENTYP ii,jj;
  static KNOTENTYP connfl;
  static unsigned short anz;
  static unsigned long nr;     /* laufende Nummer der Verzweigung */

  if (his_anz>1 && overflow[his_anz-2]) 
     {overflow[his_anz-1] = True;  return(True);}

  memcpy(hiscopy,history,sizeof(ELEM)*(size_t)his_anz);
  for (i=0; i<his_anz; i++) {his_check_pos[i] = 0;}

  /* Patches konstruieren: */
  l = his_anz;  anz = 0;  nr = 0L;  overflow[his_anz-1] = False;  pco = True;
  his_check_count[his_anz-1] = 0L;
  if (his_anz>1) {starte_history(his_anz-1);}

  /* gueltige Flaechenzahlen errechnen:  Muss vor der ersten Konstruktion
     eines Patches geschehen, da die Flaechenzahlen benutzt werden, um zu
     pruefen, ob ein Patch ueberhaupt konstruiert werden muss. Fuer den
     ersten Durchlauf werden die Flaechenzahlen hier ermittelt, fuer alle
     weiteren Durchlaeufe in der Funktion "setze_history_weiter". In "starte_
     history" werden alle Zahlen bis auf den obersten Level bestimmt. */
  if (facenumbers) {       /* oberste Flaechenzahlen aktualisieren */
    if (history[his_anz-1].prev2) {
      for (f=0; f<anz_face; f++) 
        {(history[his_anz-1].flaechenzahl)[f] = 
         ((history[his_anz-1].prev1)->flaechenzahl)[f] + 
         ((history[his_anz-1].prev2)->flaechenzahl)[f];}
    }
    else {memcpy(history[his_anz-1].flaechenzahl,(history[his_anz-1].prev1)->
                 flaechenzahl,sizeof(KNOTENTYP)*(size_t)anz_face);}
  }

  do {
    start = 0;  connfl = 0;  
    erg = konstruiere_patch_in_rekursion(patchmap,&start,dummyarray,
          &history[his_anz-1],gk,his_anz-1,his_anz,his_anz-1,&connfl);
          /* Test nur in oberstem Level, weil unterhalb nur akzeptierte 
             Patches konstruiert werden */
    if (erg==his_anz) {
      for (ii=0; ii<=G_MAX>>3; ii++) 
          {his_check_iso_rand[anz][ii][his_anz-1] = 
           (history[his_anz-1].iso_rand)[ii];}
      his_check[anz][his_anz-1] = nr;   anz++;
    }
    l = setze_history_weiter(his_anz,his_anz-1,False);
        /* Weitersetzen immer im obersten Level */
    nr++;
  } while (l>0 && anz<CHECKLISTLEN && nr<ULONG_MAX);
  if (anz>0 && anz<CHECKLISTLEN && nr<ULONG_MAX)
     {his_check[anz++][his_anz-1] = nr+1L;}
     /* Endemarke setzen, die nicht erreicht wird, so dass immer alle
        Moeglichkeiten durchlaufen werden, auch wenn die letzten nicht mehr
        brauchbar sind. Denn sonst wuerde das Erreichen des Listenendes
        zu Fehlern fuehren. */
  else if (anz==CHECKLISTLEN || nr==ULONG_MAX) 
          {overflow[his_anz-1] = True;  
           fprintf(stderr,"\noverflow %d",his_anz);}
                                        
  /* Arrays zuruecksetzen: (wird bei Overflow von "anz" gebraucht) */
  if (l>0) {                /* sonst bereits automatisch geschehen */
    memcpy(history,hiscopy,sizeof(ELEM)*(size_t)his_anz);
    for (i=0; i<his_anz; i++) {       
      if (history[i].art==VERBINDUNG) {    /* Fall 1 */
        jj = ((his_rlg2[i]/his_rl2[i]-1)>>3)+1; 
             /* Anzahl wichtiger Elemente im akzeptiert-array */
        for (ii=0; ii<jj; ii++) {his_acc[i][ii] = 0;}  /* loeschen */
      }
      if (facenumbers) {
        if (history[i].prev2) {
          for (f=0; f<anz_face; f++) 
            {(history[i].flaechenzahl)[f] = 
             ((history[i].prev1)->flaechenzahl)[f] + 
             ((history[i].prev2)->flaechenzahl)[f];}
        }
        else {memcpy(history[i].flaechenzahl,(history[i].prev1)->flaechenzahl,
              sizeof(KNOTENTYP)*(size_t)anz_face);}
      }
    }
  }
  return((his_check_anz[his_anz-1] = anz) > 0  ||  nr==ULONG_MAX);
  /* Lazy-eval. -- nr==ULONG_MAX => overflow => keine negative Aussage mgl. */
} 

/****************VERKNUEPFE_BAUCHBINDENPATCHES*******************************/
/* Verknuepft 1-2 Patches entlang zweier BB-Raender, die 2*len Kanten lang
   sind.  k1 wird mit k2->invers identifiziert.                             */
/* Die Grenze von k2 wird aufgeloest.                                       */

void verknuepfe_bauchbindenpatches(KANTE *k1,KANTE *k2,KNOTENTYP len) {
  static KNOTENTYP i;
  k2 = k2->invers;
  for (i=len<<1; i>0; i--) {  
    k1->invers->fl_rechts = k2->invers->fl_rechts;
    k1->invers->connfl = k2->invers->connfl;
    if (k1->prev) {
      k1 = k1->prev->invers;
      k2 = k2->prev->invers;
    }  
    else {
      k1->prev = k1->next->next = k2->prev;    /* Verknuepfung */
      k2->prev->next = k1;
      k2->prev->prev = k1->next;
      k1 = k1->next->invers;                   /* weiter gehen */
      k2 = k2->next->invers;                   /* weiter gehen */
    }
  }
}

/*************BAUCHBINDEN_MINIMALITAETSTEST*********************************/
/* Diese Funktion nimmt den Minimalitaetstest mit allen Folgen fuer Graphen 
   vor, die entlang eines Bauchbindenpfades verklebt wurden. Variablen siehe
   "bilde_graphen_aus_bauchbindenpatches".   
    festlegen==True => Laufrichtung des Pfades darf anhand des Ergebnisses
                       festgelegt werden                                   */
/* "td" gibt an, ob die Karte top-down konstruiert wurde. In dem Fall muss
   die entstandene Karte immer auf Doppelkanten getestet werden, weil die
   Patches nicht auf Doppelkanten getestet wurden.                         */
/* "hislen" ist nur im top-down-Modus wichtig.                             */
/* Falls die Karte im rekursiven bottom-up-Teil generiert wurde, so gibt
   "vergleiche_patches" immer den Wert "False" zurueck, weil der eine Patch
   in der History steht und der andere ein Stammpatch ist.                 */

void bauchbinden_minimalitaetstest(KANTE *k,BOOL festlegen,
     KNOTENTYP n,KNOTENTYP g,ELEM *e1,ELEM *e2,char kennung,BOOL td,
     POSTYP hislen) {
  static KNOTENTYP dummy;
  static KNOTENTYP graph[CODESIZE(N_MAX)];  /* Originalcodierung */
  static KNOTENTYP pfadcode[2];           /* fuer die Codierung des Pfades */
  static PLANMAP m;
  static BOOL erlaubt;            /* True => Pfad hat richtige Richtung */
  static BOOL is_num;
  static unsigned char connerg,faceconnerg;

  dummy = numeriere_graph_sp(m,k);   /* um "m" auch dann zu bekommen, wenn die
                        Richtung wegen e1==e2 nicht ueberprueft werden muss */
  if (e2==nil || td) {      /* Karte entstand aus einem Patch mit 2 Raendern
                               oder wurde top-down konstruiert */
    if (doppelkanten) {map_2_embedcode(m,graph,n);}
    else {
      map_2_planarcode(m,graph,n);
      if (gibt_es_doppelkante_in_graph(graph)) {return;}
    }
  }

  /* Minimalitaetstest: */
  dummy = markiere_petriepfad(k,True,1,pfadcode,&dummy,nil,nil);
  is_num = False;   /* Denn die oben ermittelte Belegung von "graph" ist noch
                       nicht unbedingt kanonisch. Erst muss noch geprueft
                       werden, ob die Richtung umgedreht werden muss. */
  /* Richtung festlegen bzw. ueberpruefen (falls e1==e2 <=> symmetrisch): */
  erlaubt = True;  
  if ((!e2 || !vergleiche_patches(e1,e2)) && 
      vergleiche_petriepfade(k,k->invers,nil,True,True,True,
          graph,m,n,False,pfadcode[1],&is_num)==False) {
    if (festlegen) {   /* Richtung umdrehen und besseren Code uebernehmen */
      k = k->invers;
      if (!is_num) {dummy = numeriere_graph2_sp(m,k);  is_num = True;}
                   /* noch kein Code vorhanden */
      if (doppelkanten) {map_2_embedcode2(m,graph,n);}
      else              {map_2_planarcode2(m,graph,n);}
    }
    else {erlaubt = False;}        /* falsche Richtung */
  }
  if (e2==nil || td) {is_num = True;}  
               /* weil entweder der zuerst ermittelte Inhalt von "graph" 
                  bleiben kann oder "graph" beim Umdrehen der Richtung 
                  ein neuer Inhalt zugeordnet wurde. */
  if (erlaubt) {   /* richtige Richtung */
    /* Delaneytest: */
    if (delaney && !delaneytest(m,n,nil,0)) {return;}
    /* Zusammenhang pruefen:  (facecon2==False => facecon1==False) */
    if (do_conn || !facecon1 || dual) {
      getconn_map(m,n,&connerg,&faceconnerg);
      if ((do_conn && !((connerg==1 && conn1) || (connerg==2 && conn2) || 
         (connerg==3 && conn3))) ||
         (faceconnerg==1 && !facecon1) || (faceconnerg==2 && !facecon2))
         {return;}  /* Karte aussortieren */
    }
    /* 7-Eck-Nachbarschaften pruefen: */
    if (mdeza1_used) {
      KNOTENTYP i,j;
      for (i=0; i<n; i++) {                   /* Kanten durchgehen */
        for (j=0; j<=2; j++) {
	  if (m[i][j]->fl_rechts==7) {        /* Siebeneck umlaufen */
            KNOTENTYP siebeneck;
            siebeneck = 0;               /* Anzahl benachbarter Siebenecke */
            k = m[i][j];
            do {
              if (k->invers->fl_rechts==7) {siebeneck++;}
              k = k->next->invers;
            } while (k != m[i][j]);
            if (siebeneck!=2) {return;}  /* falsche Anzahl Siebenecke */
          }
        }
      }
    }
    /* ab hier gilt: Struktur der Karte passt */
    if (vergleiche_bauchbindenmenge(k,k->invers->next,graph,m,n,
                                    pfadcode[1],&is_num)) {
      /* Vergleich hat noch keinen besseren Pfad ergeben */
      if (bester_petriepfad(pfadcode,2,k,True,m,n,graph,&is_num)) {
        non_iso_graphenzahl[ARRAYPOS_LN(g,n,1)]++;
        if (non_iso_graphenzahl[ARRAYPOS_LN(g,n,1)]==ULONG_MAX)
	   {logfile_entry((char *)"Warning:  type-1 map number exceeds "
            "maximum!\n",True,True,False);}  
        guter_graph(g,n,m,e1,e2,nil,graph,is_num,connerg,faceconnerg,hislen);
      } 
    }
  }
}

/***********BILDE_GRAPHEN_AUS_BAUCHBINDENPATCHES*****************************/
/*  Bildet Graphen aus 1-2 Bauchbindenpatches. Die resultierenden Graphen
    haben Geschlecht "g", besitzen "n" Knoten und "fl" Flaechen, wobei "fl" 
    nicht "f_max" sein muss.                                                */

void bilde_graphen_aus_bauchbindenpatches(KNOTENTYP g,KNOTENTYP n) {
  static KNOTENTYP fl1,fl2;    /* Flaechenzahlen der beteiligten Patches */
  static KNOTENTYP fl;         /* Anzahl Flaechen im erzeugten Graphen */
  static TREENODE *t1,*t2,*t3,*t4,*t5,*t6;
  static ELEM *e1,*e2;         /* Zeiger auf die beteiligten Patches */  
  static KANTE *gk1[2], *gk2[2], *dummykante;
         /* Arrays koennen so klein sein, da maximal 2 Raender im Patch */
  static KANTENARRAY patchmap1,patchmap2;
  static KNOTENTYP graph[CODESIZE(N_MAX)];   /* fuer Originalnumerierung 
                                      (gleichzeitig Vergleichs-planarcode) */
  static KNOTENTYP dummyarray[8];   /* fuer einen Bordercode */
         /* groesstmoegliche Laenge:  1 + 3 + 4 fuer Anzahl Raender +
            Randanfangsindices (2 Stueck + Endekennung) + Randcodes (2*2) */ 
  static KNOTENTYP dummy,connfl;
  static POSTYP start;
  static KNOTENTYP pfadcode[2];
  static KANTE *startkanten[N_MAX*3];     /* fuer Petriepfad-Startkanten */
  static POSTYP anz;                         /* Anzahl dieser Startkanten */
  static POSTYP arraypos;    /* fuer Arrays innerhalb der Funktion
                                "konstruiere_patch" */
  static BOOL is_num;  /* True => Patches vom Originalpfad wurden numeriert */
  static BOOL iso;     /* wie bei "bilde_graphen_aus_sandwichpatches" */

  fl = (n>>1)+2-(g<<1);

  /* Moeglichkeit 1: 2 Patches mit je einem Bauchbindenrand */
  if (!recover || mgl_rec==1) {
    for (fl1 = recover ? fln1_rec : 1; fl1<=(fl>>1); fl1++) {    /* fl1<=fl2 */
      fl2 = fl-fl1;
      t1 = tree[fl1];
      while (t1) {
        t2 = tree[fl2];
        while (t2) {
          if (t1->code + t2->code == g  &&      /* Geschlecht passt */
             (!recover || t1->code==g1_rec)) {
            t3 = t1->weiter.nextlevel; /* t3 und t4 zeigen auf zweiten Level */
            while (t3) {
              t4 = t2->weiter.nextlevel;
              while (t4) {
                if (t3->code+t4->code>=krit_min && t3->code+t4->code<=krit_max
                    && (!recover || (t3->code==krit1_rec && 
                                     t4->code==krit2_rec))) {
                  /* kritische Punkte passen zusammen */
                  t5 = t3->weiter.nextlevel; 
                  /* t5 und t6 zeigen auf dritten Level */
                  t6 = t4->weiter.nextlevel;    /* Anzahl der Raender */
                  if (t5 && t6 && t5->code==1 && t6->code==1) {
                    /* beide Patches haben je einen Rand */
                    /* 1 ist Mindestwert, deshalb keine Schleife notwendig, die
                         alle kleineren Eintraege durchlaeuft */
                    t5 = t5->weiter.nextlevel->weiter.nextlevel;   
                    /* nun fuenfter Level */
                    t6 = t6->weiter.nextlevel->weiter.nextlevel;  
                    /* Code 4 ist immer = 3 */
                    while (t5 && t5->code<5) {t5 = t5->next;}
                    while (t6 && t6->code<5) {t6 = t6->next;}
                    if (t5 && t6 && t5->code==5 && t6->code==5) {
                      /* beide Randcodes haben Laenge 2 */
                      t5 = t5->weiter.nextlevel;    
                      /* nun sechster Level: Randcode */
                      t6 = t6->weiter.nextlevel;
                      while (t5 && t5->code<BB_KENNUNG) {t5 = t5->next;}
                      while (t6 && t6->code<BB_KENNUNG) {t6 = t6->next;}
                      if (t5 && t6 && t5->code==BB_KENNUNG && 
                          t6->code==BB_KENNUNG) {   /* BB */
                        t5 = t5->weiter.nextlevel; /*siebter Level: Randcode*/
                        t6 = t6->weiter.nextlevel; /*zweite Eintraege gleich?*/
                        while (t5 && t6) {
                          while (t5 && t6 && t5->code!=t6->code) {  
                            /* ausgleichen */
                            if (t5->code < t6->code) {t5 = t5->next;}
                            else                     {t6 = t6->next;}
                          }
                          if (t5 && t6 &&    /* => t5->code==t6->code */ 
                             (!recover || t5->code==l1_rec)) {

              /* den folgenden Text um 14 Stellen einruecken: */ 
              /* Wichtig: der "count"-Zaehler muss unmittelbar hinter einer
                 Schranke fuer das Recovern hochgesetzt werden, damit man beim
                 Recovern den Zaehler nicht zu beachten braucht (wenn das
                 Recovern die Schranke passiert, so waere der Zaehler automa-
                 tisch richtig, wenn konsequent mitgezaehlt worden waere) */
              count++;  count = count%mod;
              if (!mod_used || recover || class==count) {
                nebenzweig[0] = 0L;
                e1 = t5->weiter.firstpatch;
                while (e1) {
                  e2 = t6->weiter.firstpatch;
                  while (e2) {
                    if (!recover && 
                       (!facerestrict || flaechenzahlen3_ok(e1,e2,nil))) {
                      start = 0;  connfl = 0;  arraypos = 0;
                      konstruiere_patch(patchmap1,&start,dummyarray,e1,
                                        gk1,nil,&connfl,&arraypos);
                      start = 0;  arraypos = 0;
                      konstruiere_patch(patchmap2,&start,dummyarray,e2,
                                        gk2,nil,&connfl,&arraypos);
                      bestimme_gute_basen(e1);
                      bestimme_gute_basen(e2);
                      graphenzahl[ARRAYPOS_LN(g,n,1)]++;
                      verknuepfe_bauchbindenpatches(gk1[0],gk2[0],t5->code);
                      bauchbinden_minimalitaetstest(gk1[0],True,n,g,e1,e2,
                          1,False,0);
                    }
                    if (!recover && (save_flag || save_flag2)) 
                      {speichere_graphen_aus_outputliste_in_files(0,1,1,0,
                       t5->code,0,0,fl1,0,n,t1->code,0,g,t3->code,t4->code,0);}
                    if (recover && nebenzweig[0]==recovernebenzweig[0]) 
                       {recover = False;   count = recovercount;}
                    nebenzweig[0]++;
                    if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
                    if (e1==e2) {e2 = nil;} else {e2 = e2->next;}
                    /* Patches aus gleicher Liste nicht zweimal verknuepfen */
                  }
                  e1 = e1->next;
                }    /* while e1 */
              }
              /* Ende des Einrueckens */     
           
  	                  }   /* if (t5 && t6) */
                          if (t5) {t5 = t5->next;}
                          if (t6) {t6 = t6->next;}    /* naechstes Paar */
                        }     /* while (t5 && t6) */
                      }       /* if BB-Rand */
                    }         /* if Rand mit Codelaenge 2 */
                  }           /* if je ein Rand */
                }             /* if kritische Punkte passen */
                if (t4==t3) {t4 = nil;} else {t4 = t4->next;}
              }               /* while t4 */
              t3 = t3->next;
            }                 /* while t3 */
          }      /* if (Geschlecht passt) */
          if (t1==t2) {t2 = nil;} else {t2 = t2->next;}
          /* Patches aus gleichem Baum nicht zweimal verknuepfen */
        }        /* while t2 */
        t1 = t1->next;
      }          /* while t1 */
    }            /* for */
  }              /* if */

  /* Moeglichkeit 2: 1 Patch mit zwei Bauchbindenraendern */
  if (!recover || mgl_rec==2) {
    t1 = tree[fl];      /* Flaechenzahl wird nicht aufgeteilt */
    while (t1 && t1->code+1<g) {t1 = t1->next;}  /* zum richtigen Geschlecht */
    if (t1 && t1->code+1 == g) {                 /* Geschlecht passt */
      t3 = t1->weiter.nextlevel;               /* t3 zeigt auf zweiten Level */
      while (t3 && t3->code<krit_min) {t3 = t3->next;} /* zum richtigen krit */
      while (t3 && t3->code>=krit_min && t3->code<=krit_max) {
        /* kritische Punkte passen */
        t5 = t3->weiter.nextlevel;  
        /* t5 zeigt auf dritten Level: Anzahl Raender */
        while (t5 && t5->code<2) {t5 = t5->next;}  /* zur richtigen Randzahl */
        if (t5 && t5->code==2 &&         /* Anzahl Raender passt */
           (!recover || t3->code==krit1_rec)) {
          t5 = t5->weiter.nextlevel->weiter.nextlevel; 
          /* nun fuenfter Level (Code 4 == 4) */
          while (t5 && t5->code<6) {t5 = t5->next;}
          if (t5 && t5->code==6) {    /* erster Randcode hat Laenge 2 */
            t5 = t5->weiter.nextlevel; 
            /* sechster Level: zweite Randcodelaenge */
            while (t5 && t5->code<8) {t5 = t5->next;}
            if (t5 && t5->code==8) {  /* zweiter Randcode hat Laenge 2 */
              t5 = t5->weiter.nextlevel;
              while (t5 && t5->code<BB_KENNUNG) {t5 = t5->next;}
              if (t5 && t5->code==BB_KENNUNG) {     /* erster Rand BB */
                t5 = t5->weiter.nextlevel;
                while (t5) {           /* t5->code unwichtig, da ==t6->code */
                  t6 = t5->weiter.nextlevel;
                  while (t6 && t6->code<BB_KENNUNG) {t6 = t6->next;}
                  if (t6 && t6->code==BB_KENNUNG) {   /* zweiter Rand BB */
                    t6 = t6->weiter.nextlevel;
                    /* hier ist keine Schleife erforderlich, denn da nur 
                       Patches
                       mit zwei GLEICH LANGEN Bauchbindenraendern gespeichert
                       werden, kann es nur einen Zweig geben, bei dem 
                       t6->code==t5->code gilt. */
                    if (!recover || t5->code==l1_rec) {
  
                      count++;  count = count % mod;
                      if (!mod_used || recover || class==count) {
                        nebenzweig[0] = 0L;
                        e1 = t6->weiter.firstpatch;          
                        while (e1) { 
                          if (!recover &&
                             (!facerestrict || flaechenzahlen_ok(e1))) {
                            start = 0;  connfl = 0;  arraypos = 0;
                            konstruiere_patch(patchmap1,&start,dummyarray,e1,
                                              gk1,nil,&connfl,&arraypos);
                            bestimme_gute_basen(e1);
                            graphenzahl[ARRAYPOS_LN(g,n,1)]++;
                            iso = iso_raender(e1,0,1);
                            verknuepfe_bauchbindenpatches(gk1[0],gk1[1],
                                                          t6->code);
                            bauchbinden_minimalitaetstest(gk1[0],True,n,g,e1,
                                                          nil,2,False,0);
                          }
                          if (!recover && (save_flag || save_flag2)) 
                             {speichere_graphen_aus_outputliste_in_files(0,1,2,
                              0,t5->code,0,0,0,0,n,0,0,g,t3->code,0,0);}
                          if (recover && nebenzweig[0]==recovernebenzweig[0]) 
                             {recover = False;   count = recovercount;}
                          nebenzweig[0]++;
                          if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
                          e1 = e1->next;
                        }    /* while e1 */
                      }

                    }
                  }      /* if (zweiter Rand BB) */ 
                  t5 = t5->next;
                }        /* while t5 */
              }          /* if (erster Rand BB) */
            }            /* if */
          }              /* if */
        }                /* if */
        t3 = t3->next;
      }                  /* while t3 */
    }                    /* if */
  }                      /* if */
}
         
/******BILDE_GRAPHEN_AUS_BAUCHBINDENPATCHES1_IN_REKURSION********************/
/* Diese Funktion sucht zum Patch "e2", der einen Bauchbindenrand besitzt,
   passende Gegenstuecke und bildet Graphen. Der Patch besitzt Geschlecht "g2",
   "krit2" kritische Punkte und "fl2" Flaechen sowie den Bordercode "code". 
   Ziel sind Karten mit Geschlecht "g" und "n" Knoten.                      */
/* "his_anz" enthaelt die Anzahl der Eintraege in der history.              */

void bilde_graphen_aus_bauchbindenpatches1_in_rekursion(KNOTENTYP g,
  KNOTENTYP n,KNOTENTYP g2,KNOTENTYP krit2,KNOTENTYP fl2,ELEM *e2,
  KNOTENTYP *code,POSTYP his_anz) {
  static KNOTENTYP fl1;    /* Flaechenzahl des anderen beteiligten Patches */
  static KNOTENTYP fl;     /* Anzahl Flaechen im erzeugten Graphen */
  static TREENODE *t1,*t3,*t5;
  static ELEM *e1;         /* Zeiger auf den anderen beteiligten Patch */  
  static KANTE *gk1[1], *gk2[1], *dummykante;
         /* Arrays koennen so klein sein, da je 1 Rand pro Patch */
  static KANTENARRAY patchmap1,patchmap2;
  static KNOTENTYP graph[CODESIZE(N_MAX)];   /* fuer Originalnumerierung 
                                      (gleichzeitig Vergleichs-planarcode) */
  static KNOTENTYP dummyarray[8];   /* fuer einen Bordercode */
         /* groesstmoegliche Laenge:  1 + 3 + 4 fuer Anzahl Raender +
            Randanfangsindices (2 Stueck + Endekennung) + Randcodes (2*2) */ 
  static KNOTENTYP dummy,connfl;
  static POSTYP start;
  static KNOTENTYP pfadcode[2];
  static KANTE *startkanten[N_MAX*3];     /* fuer Petriepfad-Startkanten */
  static POSTYP anz;                         /* Anzahl dieser Startkanten */
  static POSTYP arraypos;
  static BOOL is_num;  /* True => Patches vom Originalpfad wurden numeriert */
  static POSTYP i,erg,l;     /* "l" siehe "setze_history_weiter" */ 
  static BOOL wh;          /* True => Schleife wird mehrfach durchlaufen */

  fl = (n>>1)+2-(g<<1);
  if (g2>g || fl2+1>fl || krit2>krit_max) {return;}  
      /* erforderliche Daten passen nicht -- kann u.a. vorkommen, wenn mehrere
         Zielknotenzahlen verlangt sind */

  erg = his_anz;    /* aendert sich nicht, falls "pco==True" */
  pco = patchcheck && !overflow[his_anz-1];
  t1 = tree[fl1 = fl-fl2];
  while (t1) {
    if (t1->code + g2 == g) {    /* Geschlecht passt */
      t3 = t1->weiter.nextlevel;        /* t3 zeigt auf zweiten Level */
      while (t3) {
        if (t3->code+krit2>=krit_min && t3->code+krit2<=krit_max &&
            (!recover || t3->code==krit1_rec)) {
          /* kritische Punkte passen zusammen */
          t5 = t3->weiter.nextlevel;         /* t5 zeigt auf dritten Level */
          if (t5 && t5->code==1) {    /* Patch 1 hat einen Rand */
            /* 1 ist Mindestwert, deshalb keine Schleife notwendig, die
               alle kleineren Eintraege durchlaeuft */
            t5 = t5->weiter.nextlevel->weiter.nextlevel;
            /* nun fuenfter Level */
            while (t5 && t5->code<5) {t5 = t5->next;}
            if (t5 && t5->code==5) {       /* Randcode hat Laenge 2 */
              t5 = t5->weiter.nextlevel;    /* nun sechster Level: Randcode */
              while (t5 && t5->code<BB_KENNUNG) {t5 = t5->next;}
              if (t5 && t5->code==BB_KENNUNG) {                /* BB */
                t5 = t5->weiter.nextlevel;    /* siebter Level: Randcode */
                while (t5 && t5->code<code[4]) {t5 = t5->next;}
                if (t5 && t5->code==code[4]) {    /* gleiche Randlaenge */

              /* den folgenden Text um 4 Stellen einruecken: */ 
              l = 1;
              if (pco) {
                for (i=0; i<his_anz; i++) {his_check_pos[i] = 0;}
                starte_history(his_anz);
              }
              nebenzweig[0] = 0L;
              do {
                e1 = t5->weiter.firstpatch;  wh = False;
                while (e1) {
                  start = 0;  connfl = 0;  arraypos = 0;
                  if (wh || pco) 
                     /* direkt konstruieren, da kein Fehler moeglich */
                     {konstruiere_patch(patchmap2,&start,dummyarray,e2,
                                        gk2,nil,&connfl,&arraypos);}
                  else {
                    erg = konstruiere_patch_in_rekursion(patchmap2,&start,
                          dummyarray,e2,gk2,l-1,his_anz,his_anz-1,&connfl);
                  }
                  if (erg==his_anz) {
                    wh = True;    /* Patch 2 wurde erfolgreich konstruiert.
                      Wenn jetzt die Schleife um "e1" noch einmal durchlaufen
                      wird, dann kann Patch 2 direkt konstruiert werden. */
                    if (!recover &&
                        (!facerestrict || flaechenzahlen3_ok(e1,e2,nil))) {
                        /* erst rekursiven Patch konstruieren, dann Flaechen-
                           zahlen und Zweig abfragen, weil nur bei der 
                           Konstruktion "erg" korrekt bestimmt wird. */
                      start = 0;  arraypos = 0;
                      konstruiere_patch(patchmap1,&start,dummyarray,e1,
                                        gk1,nil,&connfl,&arraypos);
                      bestimme_gute_basen(e1);
                      bestimme_gute_basen(e2);   
                      graphenzahl[ARRAYPOS_LN(g,n,1)]++;
                      verknuepfe_bauchbindenpatches(gk1[0],gk2[0],t5->code);
                      bauchbinden_minimalitaetstest(gk1[0],True,n,g,e1,
                                                    e2,1,False,0);
                    }
                  }                  
                  else {e1 = nil;}  /* Schleife beenden, da "e2" schlecht */
                  if (e1) {e1 = e1->next;}
                  if (!recover && (save_flag || save_flag2)) 
                     {speichere_graphen_aus_outputliste_in_files(his_anz,0,0,
                      0,0,0,0,0,0,n,0,0,g,t3->code,0,0);}
                   /* "!recover" ist wichtig, falls der Recovervorgang laenger 
                      dauert als das Sicherungsintervall. */  
                  if (recover && nebenzweig[0]==recovernebenzweig[0]) 
                     {recover = False;   count = recovercount;}
                     /* An dieser Stelle ist klar:  das Recovering ist 
                        abgeschlossen, denn wir befinden uns im untersten 
                        Level, und da kommt man nicht hin, wenn nicht alle 
                        Recover-Zweige exakt getroffen werden. Deshalb Flag 
                        loeschen und "count"-Wert wiederherstellen, falls noch 
                        recover-Modus vorliegt. */
                  nebenzweig[0]++;
                  if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
                }    /* while e1 */
              } while (l = setze_history_weiter(his_anz,MIN(erg,his_anz-1),
                           pco));
              /* Ende des Einrueckens */     
         
	        }   /* if (t5) */
              }     /* if (t5) */
            }         /* if Rand mit Codelaenge 2 */
          }           /* if je ein Rand */
        }             /* if kritische Punkte passen */
        t3 = t3->next;
      }                 /* while t3 */
    }      /* if (Geschlecht passt) */
    t1 = t1->next;
  }          /* while t1 */
}     
         
/***********BILDE_GRAPHEN_AUS_BAUCHBINDENPATCHES2_IN_REKURSION***************/
/* Diese Funktion bildet Graphen aus dem Patch "e", der zwei gleich lange
   Bauchbindenraender besitzt. Der Patch besitzt Geschlecht "g1",
   "krit1" kritische Punkte und "fl1" Flaechen sowie den Bordercode "code". 
   Ziel sind Karten mit Geschlecht "g" und "n" Knoten.                      */

void bilde_graphen_aus_bauchbindenpatches2_in_rekursion(KNOTENTYP g,
  KNOTENTYP n,KNOTENTYP g1,KNOTENTYP krit1,KNOTENTYP fl1,ELEM *e,
  KNOTENTYP *code,KNOTENTYP his_anz) {
  static KNOTENTYP fl;         /* Anzahl Flaechen im erzeugten Graphen */
  static TREENODE *t1,*t2,*t3,*t4,*t5,*t6;
  static KANTE *gk1[2], *dummykante;
         /* Array kann so klein sein, da 2 Raender im Patch */
  static KANTENARRAY patchmap1;
  static KNOTENTYP graph[CODESIZE(N_MAX)];   /* fuer Originalnumerierung 
                                      (gleichzeitig Vergleichs-planarcode) */
  static KNOTENTYP dummyarray[8];   /* fuer einen Bordercode */
         /* groesstmoegliche Laenge:  1 + 3 + 4 fuer Anzahl Raender +
            Randanfangsindices (2 Stueck + Endekennung) + Randcodes (2*2) */ 
  static KNOTENTYP dummy,connfl;
  static POSTYP start;
  static KNOTENTYP pfadcode[2];
  static KANTE *startkanten[N_MAX*3];     /* fuer Petriepfad-Startkanten */
  static POSTYP anz;                         /* Anzahl dieser Startkanten */
  static BOOL is_num;  /* True => Patches vom Originalpfad wurden numeriert */
  static POSTYP i,arraypos,erg,l;     /* "l" siehe "setze_history_weiter" */

  pco = patchcheck && !overflow[his_anz-1];
  fl = (n>>1)+2-(g<<1);
  erg = his_anz;    /* aendert sich nicht, falls "pco==True" */

  if (g==g1+1 && fl==fl1 && krit1>=krit_min && krit1<=krit_max) {
     /* erforderliche Daten passen */ 
    l = 1;
    if (pco) {
      for (i=0; i<his_anz; i++) {his_check_pos[i] = 0;}
      starte_history(his_anz);
    }
    nebenzweig[0] = 0L;
    do {
      start = 0;  connfl = 0;  arraypos = 0;
      if (pco)   /* direkt konstruieren, da kein Fehler moeglich */
         {konstruiere_patch(patchmap1,&start,dummyarray,e,
                            gk1,nil,&connfl,&arraypos);}
      else {                    
        erg = konstruiere_patch_in_rekursion(patchmap1,&start,
              dummyarray,e,gk1,l-1,his_anz,his_anz-1,&connfl);
      }
      if (erg==his_anz) {    /* Konstruktion hat geklappt */
        if (!recover && (!facerestrict || flaechenzahlen_ok(e))) {
          bestimme_gute_basen(e);
          graphenzahl[ARRAYPOS_LN(g,n,1)]++;
          verknuepfe_bauchbindenpatches(gk1[0],gk1[1],code[5]);
          bauchbinden_minimalitaetstest(gk1[0],True,n,g,e,nil,2,False,0);
        }
      }
      if (!recover && (save_flag || save_flag2)) 
         {speichere_graphen_aus_outputliste_in_files(his_anz,0,0,
          0,0,0,0,0,0,n,0,0,g,0,0,0);}
      if (recover && nebenzweig[0]==recovernebenzweig[0]) 
         {recover = False;   count = recovercount;}
      nebenzweig[0]++;
      if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
    } while (l = setze_history_weiter(his_anz,MIN(erg,his_anz-1),pco));
  }
}         

/**********************SUCHE_RANDCODE*************************************/
/*  Diese Funktion (ehemals "suche_bordercode" in CPF) ist zugeschnitten 
    auf die Suche nach einem vorgegebenen
    Randcode mit mindestens 2 und maximal 4 Elementen. "len" ist die 
    Laenge des Randcodes, "code" enthaelt den Code selbst.
    Der Code kann in einzelnen Positionen
    veraendert werden. In "aend" ist Bit i gesetzt, wenn die i-te Position
    des Bordercodes veraendert werden darf. Die einzige erlaubte Aenderung
    ist jedoch folgende: Alle Positionen, in denen eine Aenderung vorgenommen
    werden darf, duerfen um den gleichen Wert erhoeht werden.
    Beispiel:  Code (4,0,2,0) ist vorgegeben und die Bits 0 und 2 sind
    gesetzt. Dann wird nach allen Codes der Form (4+k,0,2+k,0) mit k>=0
    gesucht. Wenn ueberhaupt ein code-Eintrag veraendert werden darf, so muss
    es unter anderem der erste sein, denn sonst ist der erste Eintrag und
    damit der gesuchte Code irgendwann nicht mehr maximal. 
    Die Funktion sucht also nach mehreren Codes. Damit sie nicht immer von
    vorn suchen muss, ist es sinnvoll, ihr die Position des letzten Fundes
    zu uebergeben. Dies geschieht durch das Array "t3". Die Werte t3[0] bis
    t3[3] sind die aktuellen Zeiger im Baum, und zwar fuer die Baumtiefen 0
    bis 3. Insbesondere muss t3[0] immer auf einen Knoten zeigen, an dem ein
    Randcode beginnt. Gleichzeitig enthaelt "code" den aktuellen Code. 
    Dieser wird waehrend der Suche veraendert, genauso wie die Werte in "t3".
    "code" und "t3" erhalten also immer den aktuellen Zwischenstand der Suche,
    so dass beim naechsten Aufruf der Funktion an der betreffenden Stelle
    fortgesetzt werden kann.
    Das Suchen von einem Fundort zum naechsten ist moeglich, weil die Fundorte
    geordnet sind.
    Vor dem ersten Aufruf der Funktion fuer einen bestimmten Code muss t3[0]
    auf den ersten Knoten des (Teil-)Baums zeigen und t3[1] muss den Wert 
    "nil" haben. An t3[1]==nil erkennt die Funktion, dass sie zum ersten Mal
    aufgerufen wurde. Deshalb muss der Randcode mindestens eine Laenge von 
    2 haben (siehe oben).
    Die Funktion liefert den Zeiger auf einen Knoten, der einen passenden
    Randcode repraesentiert, oder "nil", falls es keinen (mehr) gibt.
    Zusaetzlich wird an "k" der Wert uebergeben, um den die variablen Eintraege
    insgesamt erhoeht wurden. Auch hier gilt: Falls die Funktion nicht zum
    ersten Mal aufgerufen wird, muss der alte Wert an die Funktion uebergeben
    werden.
    Es wird vorausgesetzt, dass nur in den Unterbaeumen nach den passenden 
    Randcodes gesucht wird, in denen von der Laenge her gesehen auch ein
    derartiger Randcode vorkommen kann. Das ist wichtig, damit der BAUMZEIGER-
    Eintrag des Baumknotens an genau der richtigen Stelle als "firstpatch"
    und nicht als "nextlevel" interpretiert wird. Beispiel: Wird nach einem
    Randcode der Laenge 3 gesucht, dann muessen nach genau 3 Eintraegen die
    Blaetter folgen. Das ist aber sichergestellt, weil der Baum ja bereits bis
    zum passenden Ausgangspunkt durchforstet wurde, wenn die vorliegende 
    Funktion aufgerufen wird.                                                */
 
TREENODE *suche_randcode(KNOTENTYP *code,KNOTENTYP len,unsigned char aend,
  TREENODE **t3,KNOTENTYP *k) {
  static KNOTENTYP pos;     /* pos = Tiefe im Patchbaum */
  static EULERTYP i;   
  static BOOL erhoehen;     /* True => variable Werte erhoehen */ 
  if (t3[1]) {erhoehen = True;}  /* nicht erster Aufruf mit aktuellen Werten */
  else {pos = 0;  erhoehen = False;}
  /* Nun ist "pos" die Tiefe im Patchbaum, in der der Code verglichen werden
     muss. */
  while (t3[0]) {           /* Baum nicht komplett durchsucht */
    if (erhoehen) {
      for (i=(EULERTYP)len-1; i>=0; i--) /* code-Eintraege simultan erhoehen */
        {if (aend&(1<<i)) {pos = (KNOTENTYP)i;   code[i]++;} }
      (*k)++;   erhoehen = False;
    }
    while (t3[pos] && t3[pos]->code<code[pos]) {t3[pos] = t3[pos]->next;}
    if (t3[pos] && t3[pos]->code==code[pos]) {       /* Codeeintrag passt */
      if (pos+1==len) {                              /* Code vollstaendig */
        if (t3[pos]->weiter.firstpatch) {return(t3[pos]);}  /* Es gibt Patch */
        else {erhoehen = True;}   /* kein Patch => naechsten Code probieren */
      }
      else {            /* Code noch nicht vollstaendig */
        if (t3[pos]->weiter.nextlevel) 
           {t3[pos+1] = t3[pos]->weiter.nextlevel;  pos++;}
        else {erhoehen = True;}   /* Code kann nicht vervollstaendigt werden */
      }
    }
    else {erhoehen = True;}     /* "pos"-ten Codeeintrag nicht gefunden */
  }
  return(nil);
}

/*************VERKNUEPFE_SANDWICHPATCHES************************************/
/* Diese Funktion verknuepft die Patches, die durch k1, k2 und k3 gegeben
   sind (nicht unbedingt verschieden), 
   wobei k1 und k2 die "Fleischeinlagen" und k3 die Umrandung vertritt.
   len1, len2 und len3 sind die Laengen der drei Nahtteile (siehe
   Diplomarbeit), code3 ist der Randcode von Patch 3, "i" gibt an, wo der 
   Randcode von Patch 3 fuer die Verknuepfung beginnt 
   (wie bei der Erzeugung von Patches). "fall" gibt den Fall 1-4 an.       */
/* Da die Kante "k3" bei der Verknuepfung verschwindet, waere es ein
   Fehler, sie spaeter zum Ansprechen des Graphen zu verwenden. Deshalb gibt
   die Funktion einen Zeiger auf eine Kante zurueck, die wirklich im Graphen
   bleibt, und zwar die Kante "k4". */ 

KANTE *verknuepfe_sandwichpatches(KANTE *k1, KANTE *k2, KANTE *k3, KNOTENTYP
     len1, KNOTENTYP len2, KNOTENTYP len3, KNOTENTYP *code3, KNOTENTYP i,
     unsigned char fall) {
  static KANTE *k4;           /* Beginn der Umrandungsnaht */
  static KANTE *returnkante;
  k3 = (returnkante = k4 = suche_naht(code3,i,k3))->next->invers;
  if (fall<3) {k1 = k1->next;} else {k1 = k1->invers;}
  /* nun zeigen k1 und k3 parallel zum ersten 3er-Verknuepfungspunkt aus 
     Richtung Naht zwischen Patch 1 und 3 */

  /* Patches 1 und 3 vernetzen (Border von Patch 3 wird aufgeloest): */
  while (len1>1) {
    k1->fl_rechts = k3->fl_rechts; 
    k1->connfl = k3->connfl;
    if (k1->next) {k1 = k1->next->invers;  k3 = k3->next->invers;}
    else {
      k1->next = k1->prev->prev = k3->next;
      k3->next->prev = k1;
      k3->next->next = k1->prev;
      k1 = k1->prev->invers;   k3 = k3->prev->invers;
    }
    len1--;
  }

  /* zweiten 3er-Verknuepfungspunkt vernetzen: */
  k1->fl_rechts = k3->fl_rechts;
  k1->connfl = k3->connfl;
  k1->next = k1->prev->prev = k3->next;   k3->next->prev = k1;
  k3->next->next = k1->prev;

  /* Patches 1 und 2 vernetzen (Border von Patch 2 wird aufgeloest): */
  k1 = k1->prev->invers;
  if (fall==1 || fall==3) {k2 = k2->next->invers;}
  else      {k2 = k2->next->invers->next->invers;}
  while (len2>1) {
    k1->fl_rechts = k2->fl_rechts;
    k1->connfl = k2->connfl; 
    if (k1->next) {k1 = k1->next->invers;   k2 = k2->next->invers;}
    else {
      k1->next = k1->prev->prev = k2->next;
      k2->next->prev = k1;
      k2->next->next = k1->prev;
      k1 = k1->prev->invers;   k2 = k2->prev->invers;
    }
    len2--;
  }

  /* ersten 3er-Verknuepfungspunkt vernetzen: */
  k1->fl_rechts = k2->fl_rechts;
  k1->connfl = k2->connfl;
  k4->prev = k1;   k4->next = k1->prev;   k1->prev->prev = k1->next = k4;

  /* Patches 2 und 3 vernetzen (Border von Patch 2 wird aufgeloest): */
  k2 = k2->next->invers;    k4 = k4->invers;
  while (len3>1) {
    k4->fl_rechts = k2->fl_rechts;
    k4->connfl = k2->connfl;
    if (k4->next) {k4 = k4->next->invers;   k2 = k2->next->invers;}
    else {
      k4->next = k4->prev->prev = k2->next;
      k2->next->prev = k4;
      k2->next->next = k4->prev;
      k4 = k4->prev->invers;   k2 = k2->prev->invers;
    }
    len3--;
  }
  k4->fl_rechts = k2->fl_rechts;
  k4->connfl = k2->connfl;
  return(returnkante);
}

/*************VERKNUEPFE_SANDWICHPATCH2*************************************/
/* Diese Funktion verknuepft den Patch, der durch k gegeben ist, entlang eines
   Sandwichpfades mit sich selbst. "code" ist der Randcode des Patches, 
   "fall" gibt den Fall 1-4 an.                                            */

void verknuepfe_sandwichpatch2(KANTE *k, KNOTENTYP *code, unsigned char fall) {
  static KANTE *k2, *k3,*k4;
  static KNOTENTYP len;
  k3 = suche_naht(code,4-(fall==2)+(fall==3),k)->invers;
     /* wird erst spaeter gebraucht, aber muss hier schon gesucht werden,
        bevor ein Rand aufgeloest wird. */
  k4 = suche_naht(code,3-(fall==2)+(fall==3),k)->next;
     /* nun zeigt "k4" vom ersten 3er-Verknuepfungspunkt weg */
  if (fall==2 || fall==4) {k = k->next->invers;}
     /* nun zeigt auch "k" vom ersten 3er-Verknuepfungspunkt weg */
  /* nun zeigen k und k4 parallel vom ersten 3er-Verknuepfungspunkt aus 
     Richtung Nahtteil 3, entlang von k4 wird aufgeloest */
  k2 = k;    /* fuer spaeter */
  k->invers->fl_rechts = k4->invers->fl_rechts;
  k->invers->connfl = k4->invers->connfl;

  /* Nahtteil 3 vernetzen: */
  len = (code[1+(fall>2)]<<1) + 1 + (fall==1) + (fall==3);  /* Nahtlaenge */
  while (len>1) {
    if (k->invers->next) {k = k->invers->next;  k4 = k4->invers->next;}
    else {
      k = k->invers->prev;  k4 = k4->invers->prev;
      k->prev = k->next->next = k4->prev;
      k4->prev->next = k;  k4->prev->prev = k->next;
    }
    k->invers->fl_rechts = k4->invers->fl_rechts;
    k->invers->connfl = k4->invers->connfl;
    len--;
  }

  /* zweiten 3er-Verknuepfungspunkt vernetzen (geht schon hier, da k4->next
     erhalten bleiben wird): */
  k = k->invers;    k4 = k4->invers;
  k->next = k->prev->prev = k4->next;
  k4->next->next = k->prev;   k4->next->prev = k;

  /* Nahtteil 2 vernetzen: */
  k = k->prev;   k->invers->fl_rechts = k3->invers->fl_rechts;
  k->invers->connfl = k3->invers->connfl;
  /* nun zeigen k und k3 parallel vom zweiten 3er-Punkt aus Richtung
     Nahtteil 2, entlang von k3 wird aufgeloest */
  len = (code[3-(fall==2)+(fall==3)]<<1) + 2;
  while (len>1) {
    if (k->invers->next) {k = k->invers->next;  k3 = k3->invers->next;}
    else {
      k = k->invers->prev;  k3 = k3->invers->prev;
      k->prev = k->next->next = k3->prev;
      k3->prev->next = k;  k3->prev->prev = k->next;
    }
    k->invers->fl_rechts = k3->invers->fl_rechts;
    k->invers->connfl = k3->invers->connfl;
    len--;
  }

  /* ersten 3er-Punkt vernetzen: */
  k = k->invers;  k2->prev = k;    k->next = k2;
  k2 = k2->next; 
  k = k->prev;    k2->prev->next = k;    k->prev = k2->prev;

  /* Nahtteil 1 vernetzen: */
  k->invers->fl_rechts = k2->invers->fl_rechts;
  k->invers->connfl = k2->invers->connfl;
  /* nun zeigen k und k2 parallel vom ersten 3er-Punkt aus Richtung
     Nahtteil 1, entlang von k2 wird aufgeloest. */
  len = (code[4+(fall==1)+(fall==3)]<<1) + 1 + (fall<3); 
  while (len>1) {
    if (k->invers->next) {k = k->invers->next;  k2 = k2->invers->next;}
    else {
      k = k->invers->prev;  k2 = k2->invers->prev;
      k->prev = k->next->next = k2->prev;
      k2->prev->next = k;  k2->prev->prev = k->next;
    }
    k->invers->fl_rechts = k2->invers->fl_rechts;
    k->invers->connfl = k2->invers->connfl;
    len--;
  }
}

/*******BEREITE_SANDWICHCODES_VOR*******************************************/
/*  Diese Funktion ermittelt fuer die Sandwichverklebung den Startcode
    von Rand 3. Variablen siehe "bilde_graphen_aus_sandwichpatches".       */
/*  Wenn die Funktion nicht aus der Top-Down-Konstruktion aufgerufen wird,
    so sind "len1" und "len3" die kleinstmoeglichen Werte, so dass 
    zunaechst der lexikographisch kleinstmoegliche Code3 erstellt wird.    */

void bereite_sandwichcodes_vor(unsigned char fall,KNOTENTYP len1,
     KNOTENTYP len3,KNOTENTYP *code3,unsigned char *aend,KNOTENTYP *i) {
  switch (fall) {  
    /* Faelle 1-4:  Codes vorbereiten */
    case 1: {
      code3[0] = code3[3] = (len3-1)>>1;  
      code3[1] = code3[4] = 0;
      code3[2] = code3[5] = (len1-1)>>1;
      *i = (code3[0] /*|| code3[2]*/) ? mache_maximal(code3,3) : 2;
      /* falls Startcode == (0,0,0), dann beginnt der Code bei
         Eintrag 2, da (k,0,k) nicht mehr maximal waere */
      /* falls code3[0]==0 && code3[2]>0  =>  *i=2, deshalb kein Aufruf der
         Funktion "mache_maximal" erforderlich. */  
      *aend = *i ? 3 : 5;
      break;
    }
    case 2: {
      code3[0] = code3[2] = (len3-1)>>1;
      code3[1] = code3[3] = (len1-1)>>1;
      *i = mache_maximal(code3,2);  *aend = 3;
      break;
    }
    case 3: {
      code3[0] = code3[4] = (len3-1)>>1;
      code3[2] = code3[6] = (len1-1)>>1;
      code3[1] = code3[3] = code3[5] = code3[7] = 0;
      *i = mache_maximal(code3,4);  *aend = 5;
      break;
    }
    case 4: {
      code3[0] = code3[3] = (len3-1)>>1;
      code3[1] = code3[4] = (len1-1)>>1;
      code3[2] = code3[5] = 0;
      *i = mache_maximal(code3,3); *aend = *i ? 5 : 3;
      break;
    }  
  }
}

/***************PASSEN_SANDWICHCODES****************************************/
/*  Diese Funktion uebergibt den Fall, fuer den die drei uebergebenen Sandwich-
    randcodes, die zusammen die Laenge 6 besitzen, zueinander passen, 
    so dass die zugehoerigen Patches miteinander
    verklebt werden koennen, oder 0, wenn die Codes nicht zusammenpassen. 
    Im Erfolgsfalle wird desweiteren ein Offset i auf die Position in Code 3
    zurueckgegeben, von der aus der Code gelesen werden muss, damit er mit
    den anderen Codes zusammengeklebt werden kann, sowie ein Subtrahend k, der
    dem Wert c aus der Diplomarbeit (Seite 36) entspricht.                 */
/*  "code3" zeigt auf ein Array, in dem der Code zweimal hintereinander
    Platz hat. "code3" ist der Hauptrandcode.                              */
/*  Falls "code3" periodisch ist, so findet die Funktion entweder keine
    Loesung fuer i (dann alles ok) oder zwei, von der nur die erste
    beruecksicht werden darf. Da die Funktion schon nach der ersten
    Loesung zur aufrufenden Funktion zurueckkehrt, laeuft alles korrekt.   */

unsigned char passen_sandwichcodes(KNOTENTYP *code1,KNOTENTYP codelen1,
     KNOTENTYP *code2,KNOTENTYP codelen2,KNOTENTYP *code3,KNOTENTYP codelen3,
     KNOTENTYP *i,KNOTENTYP *k) {
  static unsigned char fall;
  static EULERTYP c;
  fall = 4 + codelen2 - (codelen1<<1);       /* Faelle 1-4 */ 
  memcpy(&code3[codelen3],code3,sizeof(KNOTENTYP)*(size_t)codelen3);
  switch (fall) {
    case 1: {
      for (*i=0; *i<codelen3; (*i)++) {
        c = (EULERTYP)code2[0]-1-(EULERTYP)code3[*i];
        if (c>=0 && code3[*i+1]==0 && code1[0]==code3[*i+2]+c) 
           {*k = (KNOTENTYP)c;  return(fall);}
      }
      break;
    }       
    case 2: {
      for (*i=0; *i<codelen3; (*i)++) {
        c = (EULERTYP)code2[0]-(EULERTYP)code3[*i];
        if (c>=0 && code1[0]==code3[*i+1]+c) 
           {*k = (KNOTENTYP)c;  return(fall);}
      }
      break;
    }       
    case 3: {
      for (*i=0; *i<codelen3; (*i)++) {
        c = (EULERTYP)code2[0]-1-(EULERTYP)code3[*i];
        if (c>=0 && code3[*i+1]==0 && code3[*i+3]==0 && 
            code1[0]==code3[*i+2]+c+1) {*k = (KNOTENTYP)c;  return(fall);}
      }
      break;
    }       
    case 4: {
      for (*i=0; *i<codelen3; (*i)++) {
        c = (EULERTYP)code2[0]-(EULERTYP)code3[*i];
        if (c>=0 && code3[*i+2]==0 && code1[0]==code3[*i+1]+c+1) 
           {*k = (KNOTENTYP)c;  return(fall);}
      }
      break;
    }       
  }
  return(0);
}

/*************VERKNUEPFE_BRILLENPATCHES*************************************/
/* Diese Funktion verknuepft die Patches, die durch k1, k2 und k3 gegeben 
   sind, wobei k1 und k2 die Brillenglaeser und k3 den Mittelteil vertritt.
   len1, len2 und len3 sind die Laengen der drei Nahtteile, code3 ist der
   Bordercode von Patch 3, "i" gibt an, wo der Bordercode von Patch 3
   fuer die Verknuepfung beginnt (wie bei der Erzeugung von Patches).   
   "fall" gibt den Fall 1-8 an.                                            */
/* Da die Kante "k3" bei der Verknuepfung verschwinden kann, waere es ein
   Fehler, sie spaeter zum Ansprechen des Graphen zu verwenden. Deshalb gibt
   die Funktion einen Zeiger auf eine Kante zurueck, die wirklich im Graphen
   bleibt, und zwar die Kante "k4". Es handelt sich um die Kante, die vom
   ersten Brillenglas wegfuehrt (Bruchkante, nach der die Codierung beginnt,
   wie sie in der Diplomarbeit auf Seite 38 aufgefuehrt ist). */ 

KANTE *verknuepfe_brillenpatches(KANTE *k1, KANTE *k2, KANTE *k3, KNOTENTYP
     len1, KNOTENTYP len2, KNOTENTYP len3, KNOTENTYP *code3, KNOTENTYP i,
     unsigned char fall) {
  static KANTE *k4;            /* Beginn der mittleren Naht */
  static KANTE *returnkante; 
  k3 = (returnkante = k4 = suche_naht(code3,i,k3))->next->invers;
  if (fall==1 || fall==2 || fall==5 || fall==6) {k1 = k1->next;}
  else                                          {k1 = k1->invers;}
  /* nun zeigen k1 und k3 parallel zum 3er-Verknuepfungspunkt aus Richtung
     Uhrzeigersinn */
  /* Patch 1 vernetzen (Border von Patch 1 wird aufgeloest): */
  while (len1>1) {
    k3->invers->fl_rechts = k1->invers->fl_rechts;
    k3->invers->connfl = k1->invers->connfl;
    if (k3->prev) {k1 = k1->prev->invers;   k3 = k3->prev->invers;}
    else {
      k3->prev = k3->next->next = k1->prev;
      k1->prev->next = k3;
      k1->prev->prev = k3->next;
      k1 = k1->next->invers;     k3 = k3->next->invers;
    }
    len1--;
  }  
  
  /* 3er-Treffpunkt von Patch 1 und 3 vernetzen: */
  k3->invers->fl_rechts = k1->invers->fl_rechts;
  k3->invers->connfl = k1->invers->connfl;
  k3->prev = k4->next;  k4->next->next = k4->prev = k3;
  k3 = k3->next;      /* wichtig, da altes k3 anschliessend veraendert wird */
  k3->prev->next = k4;  /* naemlich hier */
  
  /* Patch 3 mit sich selbst vernetzen (die Kanten k3 verschwinden): */
  k3 = k3->invers;   k4 = k4->invers;
  while (len3>1) {
    k4->fl_rechts = k3->fl_rechts;  
    k4->connfl = k3->connfl;
    if (k4->next) {k3 = k3->next->invers;   k4 = k4->next->invers;}
    else {
      k4->next = k4->prev->prev = k3->next;
      k3->next->prev = k4;
      k3->next->next = k4->prev;
      k3 = k3->prev->invers;   k4 = k4->prev->invers;
    }
    len3--;
  }
  
  /* 3er-Treffpunkt von Patch 2 und 3 vernetzen: */
  k4->fl_rechts = k3->fl_rechts;
  k4->connfl = k3->connfl;
  k3 = k3->next;
  k4->next = k4->prev->prev = k3;
  k3->prev = k4;   k3->next = k4->prev;
  
  /* Patch 2 vernetzen (Border von Patch 2 wird aufgeloest): */
  if (fall==2 || fall==4) {k2 = k2->invers;}
  else                    {k2 = k2->next;}
  k3 = k3->invers; 
  while (len2>1) {
    k3->invers->fl_rechts = k2->invers->fl_rechts;
    k3->invers->connfl = k2->invers->connfl;
    if (k3->prev) {k2 = k2->prev->invers;   k3 = k3->prev->invers;}
    else {
      k3->prev = k3->next->next = k2->prev;
      k2->prev->next = k3;
      k2->prev->prev = k3->next;
      k2 = k2->next->invers;     k3 = k3->next->invers;
    }
    len2--;
  }
  k3->invers->fl_rechts = k2->invers->fl_rechts;  
  k3->invers->connfl = k2->invers->connfl;
  return(returnkante);
}

/********BEREITE_BRILLENCODES_VOR***************************************/
/*  Diese Funktion ermittelt fuer die Brillenverklebung den Startcode
    von Rand 3. Variablen siehe "bilde_graphen_aus_brillenpatches".    */
/*  Die Codelaengen werden in der uebergeordneten Funktion ermittelt.  */
/*  "l2" enthaelt die Laenge des mittleren Pfadteils. Wenn die 
    Funktion nicht aus der Top-Down-Konstruktion aufgerufen wird, so
    ist "l2" kleinstmoeglich, so dass zunaechst der lexikographisch
    kleinstmoegliche Code3 ermittelt wird.                             */

void bereite_brillencodes_vor(unsigned char fall,KNOTENTYP *code1,
     KNOTENTYP *code2,KNOTENTYP *code3,unsigned char *aend,KNOTENTYP *i,
     KNOTENTYP l2) {
  switch (fall) {  
    /* Faelle 1-8:  Codes vorbereiten */
    case 1: {
      code3[0] = code3[2] = code2[0] + 1 + (l2>>1);  
      code3[1] = code3[3] = code1[0] + 1 + (l2>>1);
      *i = mache_maximal(code3,2);   *aend = 3;   
      break;
    }
    case 2: {
      code3[0] = code3[3] = code2[0] + (l2>>1);
      code3[1] = code3[4] = 0;
      code3[2] = code3[5] = code1[0] + 1 + (l2>>1);
      *i = mache_maximal(code3,3);  *aend = *i ? 3 : 5;
      break;
    }
    case 3: {
      code3[0] = code3[3] = code2[0] + 1 + (l2>>1);
      code3[1] = code3[4] = code1[0] + (l2>>1);
      code3[2] = code3[5] = 0;
      *i = mache_maximal(code3,3);  *aend = *i ? 5 : 3;
      break;
    }
    case 4: {
      code3[0] = code3[4] = code2[0] + (l2>>1);
      code3[2] = code3[6] = code1[0] + (l2>>1);
      code3[1] = code3[3] = code3[5] = code3[7] = 0;
      *i = mache_maximal(code3,4);  *aend = 5;
      break;
    }  
    case 5: {
      code3[0] = code3[2] = (l2>>1) - 1;
      code3[1] = code3[3] = code1[0] + code2[0] + 2 + (l2>>1); 
      *i = 1;   *aend = 3;
      break;
    }
    case 6: {
      code3[0] = code3[3] = (l2>>1) - 1;
      code3[1] = code3[4] = 0;
      code3[2] = code3[5] = code1[0] + code2[0] + 1 + (l2>>1);
      *i = 2;   *aend = 3;
      break;
    }
    case 7: {
      code3[0] = code3[3] = (l2>>1) - 1;
      code3[2] = code3[5] = 0; 
      code3[1] = code3[4] = code1[0] + code2[0] + 1 + (l2>>1);
      *i = 1;   *aend = 5;
      break;
    }
    case 8: {
      code3[0] = code3[4] = (l2>>1) - 1;
      code3[1] = code3[5] = code3[3] = code3[7] = 0;
      code3[2] = code3[6] = code1[0] + code2[0] + (l2>>1);
      *i = 2;   *aend = 5;
      break;
    }     
  }
}               

/****************PASSEN_BRILLENCODES****************************************/
/*  Diese Funktion uebergibt den Fall, fuer den die drei uebergebenen Brillen-
    randcodes, die zusammen die Laenge 6 besitzen, zueinander passen, 
    so dass die zugehoerigen Patches miteinander verklebt werden koennen, oder
    0, wenn die Codes nicht zusammenpassen. Maximal ein Fall passt.
    Im Erfolgsfalle wird desweiteren ein Offset i auf die Position in Code 2
    zurueckgegeben, von der aus der Code gelesen werden muss, damit er mit
    den anderen Codes zusammengeklebt werden kann, sowie ein Subtrahend k, der
    dem Wert c aus der Diplomarbeit (Seite 36) entspricht.                 */
/*  "code3" zeigt auf ein Array, in dem der Code zweimal hintereinander
    Platz hat. "code3" ist der Hauptrand.                                  */
/*  Falls "code3" periodisch ist, so findet die Funktion entweder keine
    Loesung fuer i (dann alles ok) oder zwei. Da sie schon nach der ersten
    Loesung zur aufrufenden Funktion zurueckkehrt, laeuft alles korrekt.   */

unsigned char passen_brillencodes(KNOTENTYP *code1,KNOTENTYP codelen1,
     KNOTENTYP *code2,KNOTENTYP codelen2,KNOTENTYP *code3,KNOTENTYP codelen3,
     KNOTENTYP *i,KNOTENTYP *k) {
  static unsigned char fall;
  static EULERTYP c;
  memcpy(&code3[codelen3],code3,sizeof(KNOTENTYP)*(size_t)codelen3);
  fall = 7 - (codelen1<<1) - codelen2;   /* zunaechst Faelle 1-4 */
  switch (fall) {
    case 1: {
      for (*i=0; *i<codelen3; (*i)++) {
        c = (EULERTYP)code3[*i]-1-(EULERTYP)code2[0];
        if (c>=0 && code1[0]+c+1==code3[*i+1]) 
           {*k = (KNOTENTYP)c;  return(fall);}
      }
      break;
    }       
    case 2: {
      for (*i=0; *i<codelen3; (*i)++) {
        c = (EULERTYP)code3[*i]-(EULERTYP)code2[0];
        if (c>=0 && code3[*i+1]==0 && code1[0]+c+1==code3[*i+2]) 
           {*k = (KNOTENTYP)c;  return(fall);}
      }
      break;
    }       
    case 3: {
      for (*i=0; *i<codelen3; (*i)++) {
        c = (EULERTYP)code3[*i]-1-(EULERTYP)code2[0];
        if (c>=0 && code3[*i+2]==0 && code1[0]+c==code3[*i+1]) 
           {*k = (KNOTENTYP)c;  return(fall);}
      }
      break;
    }       
    case 4: {
      for (*i=0; *i<codelen3; (*i)++) {
        c = (EULERTYP)code3[*i]-(EULERTYP)code2[0];
        if (c>=0 && code3[*i+1]==0 && code3[*i+3]==0 &&
            code1[0]+c==code3[*i+2]) {*k = (KNOTENTYP)c;  return(fall);}
      }
      break;
    }       
  }
  fall += 4;            /* nun Faelle 5-8 */
  switch (fall) {
    case 5: {
      for (*i=0; *i<codelen3; (*i)++) {
        c = code3[*i]+1;
        if (code1[0]+code2[0]+c+2==code3[*i+1]) 
           {*k = (KNOTENTYP)c;  return(fall);}
      }
      break;
    }       
    case 6: {
      for (*i=0; *i<codelen3; (*i)++) {
        c = code3[*i]+1;
        if (code3[*i+1]==0 && code1[0]+code2[0]+c+1==code3[*i+2]) 
           {*k = (KNOTENTYP)c;  return(fall);}
      }
      break;
    }       
    case 7: {
      for (*i=0; *i<codelen3; (*i)++) {
        c = code3[*i]+1;
        if (code3[*i+2]==0 && code1[0]+code2[0]+c+1==code3[*i+1]) 
           {*k = (KNOTENTYP)c;  return(fall);}
      }
      break;
    }       
    case 8: {
      for (*i=0; *i<codelen3; (*i)++) {
        c = code3[*i]+1;
        if (code3[*i+1]==0 && code3[*i+3]==0 &&
            code1[0]+code2[0]+c==code3[*i+2]) 
           {*k = (KNOTENTYP)c;  return(fall);}
      }
      break;
    }       
  }
  return(0);
}

/*************SANDWICH_MINIMALITAETSTEST************************************/
/*  Diese Funktion nimmt den Minimalitaetstest mit allen Folgen fuer Graphen 
    vor, die entlang eines Sandwichpfades verklebt wurden. Variablen siehe
    "bilde_graphen_aus_sandwichpatches".   
    festlegen==True => Laufrichtung des Pfades darf anhand des Ergebnisses
                       festgelegt werden                                   */
/* Richtung festlegen (hier erlaeutert am Beispiel von 3 Patches): 
   nicht erlaubt, wenn Patch 1 und Patch 2 aus derselben
   Liste kommen, also t2[2+codelen2]==t1[2+codelen1]. Dann muss verglichen
   werden, da derselbe Graph auch spiegelbildlich mit Spiegelbildern 
   von e1, e2 und e3 konstruiert wird, die dieselbe Flaechenzahl, dasselbe
   Genus, dieselbe kritische Punktzahl und denselben Bordercode haben, also
   in derselben Liste stehen. Die spiegelbildliche Konstruktion kann 
   insbesondere nicht dadurch verhindert werden, dass Paare (A,B) aus ein 
   und derselben Liste nur einmal gebildet werden, weil A in der Liste vor B
   stehen kann, aber B' vor A', so dass trotzdem beide Paare gebildet werden
   wuerden. Deshalb muss jedes Paar zweimal gebildet werden, wobei nur eine 
   Kombination akzeptiert wird. Dagegen ist es kein Problem, wenn A und B 
   nicht aus einer Liste kommen, da sie sich dann in irgendeiner Weise 
   unterscheiden und somit nicht in einer Schleife die Paare (A,B) und 
   (B',A') gebildet werden koennen.
   Bei CPF waren noch mehr Richtungsvergleiche notwendig, da die kritischen
   Punkte nicht zur Bestimmung der Reihenfolge von Patches mit gleicher
   Flaechenzahl herangezogen wurden. */
/* "links" gibt an, ob beim Petriepfad zuerst nach links fortgesetzt wird. */

void sandwich_minimalitaetstest(KANTE *k,BOOL festlegen,
     KNOTENTYP n,KNOTENTYP g,ELEM *e1,ELEM *e2,ELEM *e3,BOOL links,
     int kennung,BOOL td,POSTYP hislen) {
  static KNOTENTYP dummy;
  static KANTE *first,*last,*h;        /* Anfang und Ende des Petriepfades */
  static BOOL sp;   /* sp-Wert, nachdem evtl. die Laufrichtung des
                                Pfades umgedreht wurde */
  static KNOTENTYP graph[CODESIZE(N_MAX)];  /* Originalcodierung */
  static KNOTENTYP pfadcode[4];           /* fuer die Codierung des Pfades */
  static PLANMAP m;
  static BOOL erlaubt;            /* True => Pfad hat richtige Richtung */
  static BOOL is_num;
  static unsigned char connerg,faceconnerg;
  static BOOL beide_richtungen;   /* Muss ein Pfad in beiden Richtungen
                                     bewertet werden? */

  if (e2==nil || e3==nil || td) {  /* ein Patch hat mindestens 2 Raender oder 
                                      SW2 oder top-down */
    dummy = numeriere_graph(m,k);
    if (doppelkanten) {map_2_embedcode(m,graph,n);}
    else {
      map_2_planarcode(m,graph,n);
      /* Test: */
      /* if (kennung==31 || kennung==32)
            {schreibe_planarcode(graph,stdout,CODESIZE(n));} */
      if (gibt_es_doppelkante_in_graph(graph)) {return;}
    }
    loesche_numerierung(m,n);  /* die Numerierung hat eventuell die 
                                  falsche Spiegelung */
  }
  /* Minimalitaetstest: */
  beide_richtungen = markiere_petriepfad(k,links,1,pfadcode,
                     &dummy,&first,&last);
                     /* WICHTIG: "k" ist die 1. Kante des Pfades
                        (sonst wuerde u.U. ein anderer Pfad markiert) */ 
  sp = (first->nr&1) != links;
  if (sp) {dummy = numeriere_graph_sp(m,first);}
  else    {dummy = numeriere_graph(m,first);}

  is_num = False;   erlaubt = True;
  if (beide_richtungen) {   /* Richtung festlegen */ 
    if (vergleiche_petriepfade(first,last,nil,sp,(last->nr&1)!=links,True,
        graph,m,n,False,pfadcode[1]+pfadcode[2]+pfadcode[3],
        &is_num)==False) {
      if (festlegen) {  /* Richtung umdrehen und besseren Code uebernehmen */
        h = first;  first = last;  last = h;
        sp = (first->nr&1) != links;      /* "first" hat neuen Wert */
        /* pfadcode[1] und pfadcode[2] nicht vertauschen: sie sind gleich */
        if (!is_num) {      /* Code noch nicht vorhanden */
          if (sp) {dummy = numeriere_graph2_sp(m,first);}
          else    {dummy = numeriere_graph2(m,first);}
          is_num = True;
        }
        if (doppelkanten) {map_2_embedcode2(m,graph,n);}
        else              {map_2_planarcode2(m,graph,n);}
      }
      else {erlaubt = False;}        /* falsche Richtung */
    }
  }
  if (erlaubt) {   /* richtige Richtung */
    /* Delaneytest: */
    if (delaney && !delaneytest(m,n,nil,0)) {return;}
    /* Zusammenhang pruefen:  (facecon2==False => facecon1==False) */
    if (do_conn || !facecon1 || dual) {
      getconn_map(m,n,&connerg,&faceconnerg);
      if ((do_conn && !((connerg==1 && conn1) || (connerg==2 && conn2) || 
         (connerg==3 && conn3))) ||
         (faceconnerg==1 && !facecon1) || (faceconnerg==2 && !facecon2))
         {return;}  /* Karte aussortieren */
    }
    /* 7-Eck-Nachbarschaften pruefen: */
    if (mdeza1_used) {
      KNOTENTYP i,j;
      for (i=0; i<n; i++) {                   /* Kanten durchgehen */
        for (j=0; j<=2; j++) {
	  if (m[i][j]->fl_rechts==7) {        /* Siebeneck umlaufen */
            KNOTENTYP siebeneck;
            siebeneck = 0;               /* Anzahl benachbarter Siebenecke */
            k = m[i][j];
            do {
              if (k->invers->fl_rechts==7) {siebeneck++;}
              k = k->next->invers;
            } while (k != m[i][j]);
            if (siebeneck!=2) {return;}       /* falsche Anzahl Siebenecke */
          }
        }
      }
    }
    /* ab hier gilt: Struktur der Karte passt */
    if (bester_petriepfad(pfadcode,4,first,sp,m,n,graph,&is_num)) {
      non_iso_graphenzahl[ARRAYPOS_LN(g,n,2)]++;
      if (non_iso_graphenzahl[ARRAYPOS_LN(g,n,2)]==ULONG_MAX)
	 {logfile_entry((char *)"Warning:  type-2 map number exceeds"
          " maximum!\n",True,True,False);}  
      guter_graph(g,n,m,e1,e2,e3,graph,is_num,connerg,faceconnerg,hislen);
    } 
  }
}

/****************BRILLEN_MINIMALITAETSTEST************************************/
/*  Diese Funktion nimmt den Minimalitaetstest mit allen Folgen fuer Graphen 
    vor, die entlang eines Brillenpfades verklebt wurden. Variablen siehe
    "bilde_graphen_aus_brillenpatches". Desweiteren wird der Graph auf
    Doppelkanten ueberprueft.  
    festlegen==True => Laufrichtung des Pfades darf anhand des Ergebnisses
                       festgelegt werden (vgl. "sandwich_minimalitaetstest") */

void brillen_minimalitaetstest(KANTE *k,BOOL festlegen,KNOTENTYP n,KNOTENTYP g,
     ELEM *e1,ELEM *e2,ELEM *e3,int kennung,POSTYP hislen) {
  static KNOTENTYP dummy;
  static KANTE *first,*last,*h;        /* Anfang und Ende des Petriepfades */
  static KNOTENTYP graph[CODESIZE(N_MAX)];  /* Originalcodierung */
  static KNOTENTYP pfadcode[4];           /* fuer die Codierung des Pfades */
  static PLANMAP m;
  static BOOL erlaubt;            /* True => Pfad hat richtige Richtung */
  static BOOL is_num;
  static unsigned char connerg,faceconnerg;
  static BOOL beide_richtungen;   /* Muss ein Pfad in beiden Richtungen
                                     bewertet werden? */

  dummy = numeriere_graph(m,k);
  if (doppelkanten) {map_2_embedcode(m,graph,n);}
  else {
    map_2_planarcode(m,graph,n);
    /* Test: */
    /* if (kennung==21 || kennung==22)
       {schreibe_planarcode(graph,stdout,CODESIZE(n));} */
    if (gibt_es_doppelkante_in_graph(graph)) {return;}
  }
  loesche_numerierung(m,n);  /* die Numerierung ging nicht von der
                                Kante "first" (s. spaeter) aus */

  /* Minimalitaetstest: */
  beide_richtungen = markiere_petriepfad(k,False,1,pfadcode,&dummy,
                                         &first,&last);
  /* WICHTIG: "k" fuehrt zum Originalpfad, obwohl es nicht die
              Anfangskante des Pfades ist ("k" ist die Kante, die vom ersten
              "Brillenglas" wegfuehrt). */
  if (first->nr&1) {dummy = numeriere_graph_sp(m,first);}
  else             {dummy = numeriere_graph(m,first);}
  is_num = False;   erlaubt = True;
  if (beide_richtungen) {           /* Richtung festlegen */ 
    if (vergleiche_petriepfade(first,last,nil,first->nr&1,last->nr&1,True,
        graph,m,n,False,pfadcode[1]+pfadcode[2]+pfadcode[3],&is_num)
        ==False) {
      if (festlegen) {  /* Richtung umdrehen und besseren Code uebernehmen */
        h = first;  first = last;  last = h;
        /* pfadcode[1] und pfadcode[2] nicht vertauschen: sie sind gleich */
        if (!is_num) {      /* Code noch nicht vorhanden */
          if (first->nr&1) {dummy = numeriere_graph2_sp(m,first);}
          else             {dummy = numeriere_graph2(m,first);}
          is_num = True;
        }
        if (doppelkanten) {map_2_embedcode2(m,graph,n);}
        else              {map_2_planarcode2(m,graph,n);}
      }
      else {erlaubt = False;}        /* falsche Richtung */
    }
  }
  if (erlaubt) {   /* richtige Richtung */
    /* Delaneytest: */
    if (delaney && !delaneytest(m,n,nil,0)) {return;}
    /* Zusammenhang pruefen:  (facecon2==False => facecon1==False) */
    if (do_conn || !facecon1 || dual) {
      getconn_map(m,n,&connerg,&faceconnerg);
      if ((do_conn && !((connerg==1 && conn1) || (connerg==2 && conn2) || 
         (connerg==3 && conn3))) ||
         (faceconnerg==1 && !facecon1) || (faceconnerg==2 && !facecon2))
         {return;}  /* Karte aussortieren */
    }
    /* 7-Eck-Nachbarschaften pruefen: */
    if (mdeza1_used) {
      KNOTENTYP i,j;
      for (i=0; i<n; i++) {                   /* Kanten durchgehen */
        for (j=0; j<=2; j++) {
	  if (m[i][j]->fl_rechts==7) {        /* Siebeneck umlaufen */
            KNOTENTYP siebeneck;
            siebeneck = 0;               /* Anzahl benachbarter Siebenecke */
            k = m[i][j];
            do {
              if (k->invers->fl_rechts==7) {siebeneck++;}
              k = k->next->invers;
            } while (k != m[i][j]);
            if (siebeneck!=2) {return;}  /* falsche Anzahl Siebenecke */
          }
        }
      }
    }
    /* ab hier gilt: Struktur der Karte passt */
    if (bester_petriepfad(pfadcode,4,first,first->nr&1,m,n,graph,&is_num)) {
      non_iso_graphenzahl[ARRAYPOS_LN(g,n,3)]++;
      if (non_iso_graphenzahl[ARRAYPOS_LN(g,n,3)]==ULONG_MAX)
	 {logfile_entry((char *)"Warning:  type-3 map number exceeds"
          " maximum!\n",True,True,False);}  
      guter_graph(g,n,m,e1,e2,e3,graph,is_num,connerg,faceconnerg,hislen);
    } 
  }
}

/***********BRUCHKANTEN_MOEGLICHKEIT4****************************************/
/* Diese Funktion untersucht eine der 3 Permutationen, die es bei Moeglichkeit
   4 bei der Sandwich- und Brillenverklebung gibt. "perm1", "perm2" und 
   "perm3" enthalten
   die Bilder von 1,2 und 3 bei der gewaehlten Permutation (d.h. der Rand perm1
   spielt die Rolle von Rand 1 usw.). "code3" und 
   "codelen3" enthalten die Daten desjenigen Randes, der als Hauptrand
   genommen werden soll. Entsprechend "code1" usw. fuer die Nebenraender.
   "e" zeigt auf den ersten Patch der Liste, die untersucht wird.
   Weitere Variablen siehe "bilde_graphen_aus_sandwichpatches".             */
/* Wenn die beiden Nebenraender den gleichen Randcode haben, aber nicht
   isomorph sind, so muessen sie auch vertauscht werden und die Richtung
   des Petriepfades ueberprueft werden.                                     */

void bruchkanten_moeglichkeit4(char perm1,char perm2,char perm3,KNOTENTYP n,
     KNOTENTYP g,KNOTENTYP *code1,KNOTENTYP codelen1,KNOTENTYP *code2,
     KNOTENTYP codelen2,KNOTENTYP *code3,KNOTENTYP codelen3,ELEM *e,
     KNOTENTYP krit,unsigned char mgl) {
  static KANTE *gk[3];  /* Array kann so klein sein, da Patch mit 3 Raendern */
  static KNOTENTYP i;      /* Offset in code2, so dass auf den Beginn der
                              Verklebung gezeigt wird */
  static KNOTENTYP dummyarray[11];   /* nimmt einen Bordercode auf */
         /* Laenge:  1 + 4 + 6 fuer Anzahl Raender +
            Randanfangsindices (3 Stueck + Endekennung) + Randcodes */ 
  static KNOTENTYP len;    /* Laenge der mittleren Naht (Brille) */
  static KNOTENTYP len2;   /* Laenge von Nahtteil 2 (Verknuepfung von Rand 1
                              und Rand 2) (Sandwich) */
  static unsigned char fall;  /* "fall" gibt an, welcher der Faelle 1-4 bzw. 
                                 1-8 beim Verknuepfen angewendet werden muss */
  static KNOTENTYP k;      /* Anzahl der Winkel in Nahtteil 2 (aus
                              dieser errechnet sich der Wert von "len") */
  static KNOTENTYP len12, len23;   /* Laengen der Nahtteile 1 und 2 bzw.
                                      2 und 3 zusammen (Sandwich) */
  static KANTENARRAY patchmap;
  static POSTYP start,arraypos;
  static BOOL gleiche_randcodes;
  static KNOTENTYP connfl;
   
  if (!((codelen1<2 || (codelen1==2 && code1[1]==0)) && 
        (codelen2<2 || (codelen2==2 && code2[1]==0)))) {return;}
        /* Permutation ungueltig */

  if (do_sandwich && !l1_sandwich && (!recover || pfadtyp_rec==2) &&
      (fall = passen_sandwichcodes(code1,codelen1,code2,
       codelen2,code3,codelen3,&i,&k))) {    /* Codes passen zusammen */
    len12 = (code1[0]<<1)+codelen1;
    len23 = (code2[0]<<1)+codelen2;
    len2 = (k<<1)+1;
    if (!recover || (len12==l1_rec && len2==l2_rec && len23==l3_rec)) {
      count++;  count = count % mod;
      if (!mod_used || recover || class==count) {
        gleiche_randcodes = (len12==len23);    /* fuer Nebenraender */
        nebenzweig[0] = 0L;
        while (e) {            /* Flaechenzahlen sind immer ok */
          if (!recover && (!facerestrict || flaechenzahlen_ok(e))) {
            start = 0;  connfl = 0;  arraypos = 0;
            konstruiere_patch(patchmap,&start,dummyarray,e,gk,nil,&connfl,
                              &arraypos);
            bestimme_gute_basen(e);
            graphenzahl[ARRAYPOS_LN(g,n,2)]++;
            gk[0] = verknuepfe_sandwichpatches(gk[perm1-1],gk[perm2-1],
                    gk[perm3-1],len12-len2,len2,len23-len2,&code3[0],i,fall);
            /* laeuft, da "code3" in der Funktion "passen_sandwichcodes"
               zweimal hintereinandergeschrieben wurde */
            sandwich_minimalitaetstest(gk[0]->next,!gleiche_randcodes,
                                       n,g,e,nil,nil,fall>2,41,False,0);
            if (gleiche_randcodes) {  /* Nebenraender vertauschen */
              /* (fall,len23,len12 bleiben erhalten) */
              start = 0;  connfl = 0;  arraypos = 0;
              konstruiere_patch(patchmap,&start,dummyarray,e,gk,nil,&connfl,
                                &arraypos);
              graphenzahl[ARRAYPOS_LN(g,n,2)]++;
              gk[0] = verknuepfe_sandwichpatches(gk[perm2-1],gk[perm1-1],
                      gk[perm3-1],len23-len2,len2,len12-len2,&code3[0],i,fall);
              sandwich_minimalitaetstest(gk[0]->next,False,
                                         n,g,e,nil,nil,fall>2,42,False,0);
            }          
          }
          if (!recover && (save_flag || save_flag2)) 
             {speichere_graphen_aus_outputliste_in_files(0,2,mgl,0,
              len12,len2,len23,0,0,n,0,0,g,krit,0,0);}
          if (recover && nebenzweig[0]==recovernebenzweig[0]) 
             {recover = False;   count = recovercount;}
          nebenzweig[0]++;
          if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
          e = e->next; 
        }    /* while e */
      }     /* if */
    }      /* if */
  }     /* if passen Sandwichcodes */

  if (do_brille && !loop_brille && !digon_brille &&
     (!recover || pfadtyp_rec==3) && 
     (fall = passen_brillencodes(code1,codelen1,code2,codelen2,
      code3,codelen3,&i,&k))) {    /* Codes passen zusammen */
    len = (k<<1)+(fall<5);       /* mittlere Naht */
    if (!recover || ((code1[0]<<1)+codelen1==l1_rec && len==l2_rec &&
                     (code2[0]<<1)+codelen2==l3_rec)) {
      count++;  count = count % mod;
      if (!mod_used || recover || class==count) {
        gleiche_randcodes = (codelen1==codelen2 && code1[0]==code2[0]);
        nebenzweig[0] = 0L;
        while (e) {            /* Flaechenzahlen sind immer ok */
          if (!recover && (!facerestrict || flaechenzahlen_ok(e))) {
            start = 0;  connfl = 0;  arraypos = 0;
            konstruiere_patch(patchmap,&start,dummyarray,e,gk,nil,&connfl,
                              &arraypos);
            bestimme_gute_basen(e);
            graphenzahl[ARRAYPOS_LN(g,n,3)]++;
            gk[0] = verknuepfe_brillenpatches(gk[perm1-1],gk[perm2-1],
                    gk[perm3-1],(code1[0]<<1)+codelen1,(code2[0]<<1)+codelen2,
                    len,&code3[0],i,fall);
            /* laeuft, da "code3" in der Funktion "passen_brillencodes"
               zweimal hintereinandergeschrieben wurde */
            brillen_minimalitaetstest(gk[0],!gleiche_randcodes,n,g,e,nil,
                                      nil,41,0);
            if (gleiche_randcodes) {    /* Nebenraender vertauschen */
              start = 0;  connfl = 0;  arraypos = 0;
              konstruiere_patch(patchmap,&start,dummyarray,e,gk,nil,&connfl,
                                &arraypos);
              graphenzahl[ARRAYPOS_LN(g,n,3)]++;
              gk[0] = verknuepfe_brillenpatches(gk[perm2-1],gk[perm1-1],
                    gk[perm3-1],(code2[0]<<1)+codelen2,(code1[0]<<1)+codelen1,
                    len,&code3[0],i,fall);
              brillen_minimalitaetstest(gk[0],False,n,g,e,nil,nil,42,0);
            }
          }
          if (!recover && (save_flag || save_flag2)) 
             {speichere_graphen_aus_outputliste_in_files(0,3,mgl,0,
              (code1[0]<<1)+codelen1,len,(code3[0]<<1)+codelen3,0,0,n,0,0,g,
              krit,0,0);}
          if (recover && nebenzweig[0]==recovernebenzweig[0]) 
             {recover = False;   count = recovercount;}
          nebenzweig[0]++; 
          if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
          e = e->next; 
        }    /* while e */
      }     /* if */
    }      /* if */
  }       /* if */
}

/***********BRUCHKANTEN_MOEGLICHKEIT4_IN_REKURSION***************************/
/* Diese Funktion funktioniert wie "bruchkanten_moeglichkeit4", aber wird aus
   der Rekursion aufgerufen.                                                */

void bruchkanten_moeglichkeit4_in_rekursion(char perm1,char perm2,char perm3,
     KNOTENTYP n,
     KNOTENTYP g,KNOTENTYP *code1,KNOTENTYP codelen1,KNOTENTYP *code2,
     KNOTENTYP codelen2,KNOTENTYP *code3,KNOTENTYP codelen3,ELEM *e,
     POSTYP his_anz,KNOTENTYP krit,unsigned char mgl) {
  static KANTE *gk[3];  /* Array kann so klein sein, da Patch mit 3 Raendern */
  static KNOTENTYP i;      /* Offset in code2, so dass auf den Beginn der
                              Verklebung gezeigt wird */
  static KNOTENTYP dummyarray[11];   /* nimmt einen Bordercode auf */
         /* Laenge:  1 + 4 + 6 fuer Anzahl Raender +
            Randanfangsindices (3 Stueck + Endekennung) + Randcodes */ 
  static KNOTENTYP len;    /* Laenge der mittleren Naht (Brille) */
  static KNOTENTYP len2;   /* Laenge von Nahtteil 2 (Verknuepfung von Rand 1
                              und Rand 2) (Sandwich) */
  static unsigned char fall;  /* "fall" gibt an, welcher der Faelle 1-4 bzw. 
                                 1-8 beim Verknuepfen angewendet werden muss */
  static KNOTENTYP k;      /* Anzahl der Winkel in Nahtteil 2 (aus
                              dieser errechnet sich der Wert von "len") */
  static KNOTENTYP len12, len23;   /* Laengen der Nahtteile 1 und 2 bzw.
                                      2 und 3 zusammen (Sandwich) */
  static KANTENARRAY patchmap;
  static POSTYP start,arraypos;
  static BOOL gleiche_randcodes;
  static KNOTENTYP connfl;
  static POSTYP ii,erg,l;     /* "l" siehe "setze_history_weiter" */
 
  if (!((codelen1<2 || (codelen1==2 && code1[1]==0)) && 
        (codelen2<2 || (codelen2==2 && code2[1]==0)))) {return;}
        /* Permutation ungueltig */
  
  pco = patchcheck && !overflow[his_anz-1];
  erg = his_anz;
    
  if (do_sandwich && !l1_sandwich && (!recover || submgl_rec==1) &&
     (fall = passen_sandwichcodes(code1,codelen1,code2,
             codelen2,code3,codelen3,&i,&k))) { 
    /* Codes passen zusammen */
    len12 = (code1[0]<<1)+codelen1;
    len23 = (code2[0]<<1)+codelen2;
    len2 = (k<<1)+1;
    gleiche_randcodes = (len12==len23);    /* fuer Nebenraender */
    l = 1;
    if (pco) {
      for (ii=0; ii<his_anz; ii++) {his_check_pos[ii] = 0;}
      starte_history(his_anz);
    }
    nebenzweig[0] = 0L;
    do {
      start = 0;   connfl = 0;  arraypos = 0;
      if (pco) {konstruiere_patch(patchmap,&start,dummyarray,e,
                                  gk,nil,&connfl,&arraypos);}
      else {
        erg = konstruiere_patch_in_rekursion(patchmap,&start,
              dummyarray,e,gk,l-1,his_anz,his_anz-1,&connfl);
      }
      if (erg==his_anz) {    /* Konstruktion hat geklappt */
        if (!recover && (!facerestrict || flaechenzahlen_ok(e))) {
          bestimme_gute_basen(e);
          graphenzahl[ARRAYPOS_LN(g,n,2)]++;
          gk[0] = verknuepfe_sandwichpatches(gk[perm1-1],gk[perm2-1],
                  gk[perm3-1],len12-len2,len2,len23-len2,&code3[0],i,fall);
          /* laeuft, da "code3" in der Funktion "passen_sandwichcodes"
             zweimal hintereinandergeschrieben wurde */
          sandwich_minimalitaetstest(gk[0]->next,!gleiche_randcodes,
                                     n,g,e,nil,nil,fall>2,41,False,0);
          if (gleiche_randcodes) {  /* Nebenraender vertauschen */
            /* (fall,len23,len12 bleiben erhalten) */
            start = 0;  connfl = 0;  arraypos = 0;
            konstruiere_patch(patchmap,&start,dummyarray,e,gk,nil,&connfl,
                              &arraypos);
              /* Konstruktionsergebnis wie oben, daher einfache Konstruktion
                 ohne Tests */
            graphenzahl[ARRAYPOS_LN(g,n,2)]++;
            gk[0] = verknuepfe_sandwichpatches(gk[perm2-1],gk[perm1-1],
                    gk[perm3-1],len23-len2,len2,len12-len2,&code3[0],i,fall);
            sandwich_minimalitaetstest(gk[0]->next,False,
                                       n,g,e,nil,nil,fall>2,42,False,0);
          }          
        }
      }
      if (!recover && (save_flag || save_flag2)) 
         {speichere_graphen_aus_outputliste_in_files(his_anz,0,mgl,
          1,0,0,0,0,0,n,0,0,g,krit,0,0);}
      if (recover && nebenzweig[0]==recovernebenzweig[0]) 
         {recover = False;   count = recovercount;}
      nebenzweig[0]++;
      if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
    } while (l = setze_history_weiter(his_anz,MIN(erg,his_anz-1),pco));
  }     /* if passen Sandwichcodes */
 
  if (do_brille && !loop_brille && !digon_brille &&
     (!recover || submgl_rec==2) && 
     (fall = passen_brillencodes(code1,codelen1,code2,codelen2,
      code3,codelen3,&i,&k))) { 
    /* Codes passen zusammen */
    len = (k<<1)+(fall<5);       /* mittlere Naht */
    gleiche_randcodes = (codelen1==codelen2 && code1[0]==code2[0]);
    l = 1;
    if (pco) {
      for (ii=0; ii<his_anz; ii++) {his_check_pos[ii] = 0;}
      starte_history(his_anz);
    }
    nebenzweig[0] = 0L;
    do {
      start = 0;  connfl = 0;  arraypos = 0;
      if (pco) {konstruiere_patch(patchmap,&start,dummyarray,e,
                                  gk,nil,&connfl,&arraypos);}
      else {erg = konstruiere_patch_in_rekursion(patchmap,&start,
            dummyarray,e,gk,l-1,his_anz,his_anz-1,&connfl);}
      if (erg==his_anz) {    /* Konstruktion hat geklappt */
        if (!recover && (!facerestrict || flaechenzahlen_ok(e))) {
          bestimme_gute_basen(e);
          graphenzahl[ARRAYPOS_LN(g,n,3)]++;
          gk[0] = verknuepfe_brillenpatches(gk[perm1-1],gk[perm2-1],
                  gk[perm3-1],(code1[0]<<1)+codelen1,(code2[0]<<1)+codelen2,
                  len,&code3[0],i,fall);
          brillen_minimalitaetstest(gk[0],!gleiche_randcodes,
                                    n,g,e,nil,nil,41,0);
          if (gleiche_randcodes) {  /* Nebenraender vertauschen */
            start = 0;  connfl = 0;  arraypos = 0;
            konstruiere_patch(patchmap,&start,dummyarray,e,gk,nil,
                              &connfl,&arraypos);
              /* Konstruktionsergebnis wie oben, daher einfache Konstruktion
                 ohne Tests */
            graphenzahl[ARRAYPOS_LN(g,n,3)]++;
            gk[0] = verknuepfe_brillenpatches(gk[perm2-1],gk[perm1-1],
                    gk[perm3-1],(code2[0]<<1)+codelen2,
                    (code1[0]<<1)+codelen1,len,&code3[0],i,fall);
            brillen_minimalitaetstest(gk[0],False,
                                      n,g,e,nil,nil,42,0);
          }          
        }
      }
      if (!recover && (save_flag || save_flag2)) 
         {speichere_graphen_aus_outputliste_in_files(his_anz,0,mgl,
          2,0,0,0,0,0,n,0,0,g,krit,0,0);}
      if (recover && nebenzweig[0]==recovernebenzweig[0]) 
         {recover = False;   count = recovercount;}
      nebenzweig[0]++;
      if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
    } while (l = setze_history_weiter(his_anz,MIN(erg,his_anz-1),pco));
  }     /* if passen Brillencodes */
}

/***********SANDWICH_MOEGLICHKEIT5*******************************************/
/* Diese Funktion untersucht einen der 4 Faelle, die es bei Moeglichkeit
   5 bei der Sandwichverklebung gibt. "e" zeigt auf die Patchliste.
   Weitere Variablen siehe "bilde_graphen_aus_sandwichpatches".             */

void sandwich_moeglichkeit5(unsigned char fall,KNOTENTYP n,KNOTENTYP g,
     KNOTENTYP *code,ELEM *e,KNOTENTYP krit,unsigned char mgl) {
  static KANTE *gk[1];  /* Array kann so klein sein, da nur 1 Rand im Patch */
  static KNOTENTYP dummyarray[9];   /* nimmt einen Bordercode auf */
         /* Laenge:  1 + 2 + 6 fuer Anzahl Raender +
            Randanfangsindices (1 Stueck + Endekennung) + Randcodes */ 
  static KANTENARRAY patchmap;
  static POSTYP start,arraypos;
  static KNOTENTYP connfl,l1,l2,l3;

  /* Nahtteilberechnung siehe "verknuepfe_sandwichpatch2" */
  l1 = (code[1+(fall>2)]<<1) + 1 + (fall==1) + (fall==3);
  l2 = (code[3-(fall==2)+(fall==3)]<<1) + 2;
  l3 = (code[4+(fall==1)+(fall==3)]<<1) + 1 + (fall<3); 
  if (recover && (l1!=l1_rec || l2!=l2_rec || l3!=l3_rec)) {return;}
  count++;  count = count % mod;
  if (mod_used && !recover && class!=count) {return;}

  nebenzweig[0] = 0L;
  while (e) {            /* Flaechenzahlen sind immer ok */
    if (!recover && (!facerestrict || flaechenzahlen_ok(e))) {
      start = 0;  connfl = 0;  arraypos = 0;
      konstruiere_patch(patchmap,&start,dummyarray,e,gk,nil,&connfl,&arraypos);
      bestimme_gute_basen(e);
      graphenzahl[ARRAYPOS_LN(g,n,2)]++;
      verknuepfe_sandwichpatch2(gk[0],code,fall);  /* gk[0] bleibt erhalten */
      sandwich_minimalitaetstest(fall==2 || fall==4 ? gk[0]->next->invers :
        gk[0],False,n,g,e,nil,nil,fall==1 || fall==3,5,False,0);  
        /* Laufrichtung nicht festlegen, da Spiegelbild immer passt, wenn 
           Original passt. */
    }
    if (!recover && (save_flag || save_flag2)) 
       {speichere_graphen_aus_outputliste_in_files(0,2,mgl,0,l1,l2,l3,
                                                   0,0,n,0,0,g,krit,0,0);}
    if (recover && nebenzweig[0]==recovernebenzweig[0]) 
       {recover = False;   count = recovercount;}
    nebenzweig[0]++;
    if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
    e = e->next; 
  }    /* while e */
}

/***********SANDWICH_MOEGLICHKEIT5_IN_REKURSION******************************/
/*  wie "sandwich_moeglichkeit5", wird aber in der Rekursion aufgerufen     */

void sandwich_moeglichkeit5_in_rekursion(unsigned char fall,KNOTENTYP n,
     KNOTENTYP g,KNOTENTYP *code,ELEM *e,POSTYP his_anz,unsigned char mgl) {
  static KANTE *gk[1];  /* Array kann so klein sein, da nur 1 Rand im Patch */
  static KNOTENTYP dummyarray[9];   /* nimmt einen Bordercode auf */
         /* Laenge:  1 + 2 + 6 fuer Anzahl Raender +
            Randanfangsindices (1 Stueck + Endekennung) + Randcodes */ 
  static KANTENARRAY patchmap;
  static POSTYP start,arraypos;
  static POSTYP i,erg,l;     /* "l" siehe "setze_history_weiter" */
  static KNOTENTYP connfl;

  erg = his_anz;
  l = 1;
  if (pco = patchcheck && !overflow[his_anz-1]) {
    for (i=0; i<his_anz; i++) {his_check_pos[i] = 0;}
    starte_history(his_anz);
  }
  nebenzweig[0] = 0L;
  do {          /* Flaechenzahlen sind immer ok */
    start = 0;  connfl = 0;  arraypos = 0;
    if (pco) {konstruiere_patch(patchmap,&start,dummyarray,e,
                                gk,nil,&connfl,&arraypos);}
    else {erg = konstruiere_patch_in_rekursion(patchmap,&start,
                dummyarray,e,gk,l-1,his_anz,his_anz-1,&connfl);}
    if (erg==his_anz) {    /* Konstruktion hat geklappt */
      if (!recover && (!facerestrict || flaechenzahlen_ok(e))) {
        bestimme_gute_basen(e);
        graphenzahl[ARRAYPOS_LN(g,n,2)]++;
        verknuepfe_sandwichpatch2(gk[0],code,fall); /* gk[0] bleibt erhalten */
        sandwich_minimalitaetstest(fall==2 || fall==4 ? gk[0]->next->invers :
          gk[0],False,n,g,e,nil,nil,fall==1 || fall==3,5,False,0);  
          /* Laufrichtung nicht festlegen, da Spiegelbild immer passt, wenn 
             Original passt. */
      }
    }
    if (!recover && (save_flag || save_flag2)) 
       {speichere_graphen_aus_outputliste_in_files(his_anz,0,mgl,
        0,0,0,0,0,0,n,0,0,g,0,0,0);}
    if (recover && nebenzweig[0]==recovernebenzweig[0]) 
       {recover = False;   count = recovercount;}
    nebenzweig[0]++;
    if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
  } while (l = setze_history_weiter(his_anz,MIN(erg,his_anz-1),pco));
}

/***********BILDE_GRAPHEN_AUS_BRUCHKANTENPATCHES****************************/
/*  Bildet Graphen aus 1-3 Bruchkantenpatches. Die resultierenden Graphen
    besitzen "n" Knoten und "fl" Flaechen, wobei "fl" nicht "f_max" sein muss.
    Weitere Kommentare siehe "bilde_graphen_aus_bauchbindenpatches".       */
/*  Bei den Moeglichkeiten 1-3 ist Rand 2 immer der Hauptrand, bei
    Moeglichkeit 4 nicht unbedingt.                                        */
/*  Fuer die Kommentare gilt: Wenn von Patches 1,2,3 die Rede ist, so sind
    diese nicht unbedingt verschieden. Besser waere vielleicht "Rand" 
    anstelle von "Patch", denn die Raender sind wirklich immer verschieden */
/*  Die Bezeichnungen "len1", "len2", "len3", "Patch 1", "Patch 2" und 
    "Patch 3" sind an diejenigen in der Diplomarbeit angepasst (im Gegensatz
    zu CPF.c).                                                             */
  
void bilde_graphen_aus_bruchkantenpatches(KNOTENTYP g,KNOTENTYP n) {
  static KNOTENTYP fl1,fl2,fl3;  /* Flaechenzahlen der beteiligten Patches */
  static KNOTENTYP g1,g2,g3;     /* Geni der beteiligten Patches */
  static KNOTENTYP krit1,krit2,krit3;   /* kritische Punkte in den Patches */
  static KNOTENTYP fl;           /* Anzahl Flaechen im erzeugten Graphen */
  static TREENODE *t1[9],*t2[9],*t3[9];
         /* fuer jeden Patch und jede benoetigte Baumtiefe ein Zeiger, so dass
            Rueckspruenge moeglich sind (nicht immer werden die Elemente tx[y]
            nur fuer Patch x benutzt, aber immer dann, wenn y>2. Im Grunde
            hat aber x nicht viel zu sagen.) */
  static TREENODE *t3e; /* Zeiger fuer Patch 3 (je nach Laenge des Randcodes
                           ist t3e gleich t3[i] fuer ein i) */
  static ELEM *e1,*e2,*e3;       /* Zeiger auf die beteiligten Patches */  
  static KANTE *gk1[3], *gk2[3], *gk3[3];
         /* Arrays koennen so klein sein, da maximal 3 Raender im Patch */
  static KNOTENTYP code1[8], code2[8], code3[8];  
         /* Randcodes (bei Bedarf zweimal hintereinander) */
  static KNOTENTYP codelen1,codelen2,codelen3; 
         /* Randcodelaengen der einzelnen Patches */
  static KNOTENTYP i;      /* Offset in code3, so dass der Code maximal ist */
  static KNOTENTYP j;      /* Zaehlvariable */
  static KNOTENTYP dummyarray[11];   /* nimmt einen Bordercode auf */
         /* groesstmoegliche Laenge:  1 + 4 + 6 fuer Anzahl Raender +
            Randanfangsindices (3 Stueck + Endekennung) + Randcodes */ 
  static KNOTENTYP dummy,connfl;      
  static KNOTENTYP len;    /* Brille: Laenge der Naht, an der Rand 3 mit sich
                              selbst verklebt ist */
  static KNOTENTYP len2;   /* Sandwich: Laenge von Nahtteil 2 
                              (Verknuepfung von Rand 1 und Rand 2) */
  static unsigned char fall;  /* "fall" gibt an, welcher der Faelle 1-4 beim 
    Verknuepfen angewendet werden muss */
  static KNOTENTYP k;      /* Anzahl der Winkel in Nahtteil 2 (aus
                              dieser errechnet sich der Wert von "len2") */
  static unsigned char aend;  /* Erklaerung siehe "suche_randcode" */
  static KNOTENTYP len12, len23;   /* Laengen der Nahtteile 1 und 2 bzw.
                                      2 und 3 zusammen */
  static KANTENARRAY patchmap1,patchmap2,patchmap3;
  static BOOL zurueck;
  static POSTYP start,arraypos;
  static char iso;     /* gibt bei bestimmten Faellen an, ob zwei Raender
                          isomorph sind (1 = ja, 0 = nein, -1 = unbestimmt) */
  static BOOL gleiche_randcodes;    /* gibt bei bestimmten Faellen an, ob
                                       zwei Randcodes gleich sind */ 

  fl = (n>>1)+2-(g<<1);
  
  /* ---- Moeglichkeit 1: 3 Patches miteinander verkleben ---- */
  if (!recover || mgl_rec==1) {
    /* Patch 2 heraussuchen: */
    for (fl2 = recover ? fln2_rec : 1; fl2+2<=fl; fl2++) {     /* Patch 2 */
      t2[0] = tree[fl2];
      while (t2[0] && (g2 = t2[0]->code) <= g) {   /* erster Level: Genus */
        t2[1] = t2[0]->weiter.nextlevel;  
        while (t2[1] && (krit2 = t2[1]->code) <= krit_max) { 
          /* zweiter Level */
          t2[2] = t2[1]->weiter.nextlevel;
          if (t2[2] && t2[2]->code==1 &&     /* ein Rand */
             (!recover || (g2==g2_rec && krit2==krit2_rec))) {
            t2[2] = t2[2]->weiter.nextlevel->weiter.nextlevel;   
            /* vgl. Bauchbinde */
            while (t2[2] && t2[2]->code<=5) {  /* Rand hat <=2 Bruchkanten */
              codelen2 = t2[2]->code - 3; 
              t2[3] = t2[2]->weiter.nextlevel;     /* erster Randcodeeintrag */
              while (t2[3]) {                  /* Patchliste 2 steht fest */
                code2[0] = t2[3]->code; 
                if (codelen2==2) {t2[4] = t2[3]->weiter.nextlevel; 
                                  code2[1] = t2[4]->code;}
                if (codelen2==1 || (code2[0]!=BB_KENNUNG && code2[1]==0)) {
                   /* Patches gefunden */

  /* nun Patch 1 zuordnen (Text 16 Stellen einruecken): */
  for (fl1 = recover ? fln1_rec : 1; fl1<=MIN(fl2,fl-fl2-1); fl1++) { 
    /* Patch 1 aussuchen (wie bei Patch 2) */
    /* Patch 1 ist kleiner als Patch 2 in folgendem Sinne:
       weniger Flaechen oder bei gleicher Flaechenzahl kleineres Geschlecht
       oder bei gleichem Geschlecht kleinere kritische Punktzahl usw.
       Falls alt==False, so dient die Anzahl der kritischen Punkte nur
       innerhalb der Rekursion als oberstes Entscheidungskriterium, und zwar
       implizit (d.h. wenn ein Stammpatch passt, dann ist er auch erlaubt,
       denn waere er groesser, muesste der history-Patch erst recht ein
       Stammpatch sein).
       Die Gleichheit bis zu einem bestimmten Level i kann man auch 
       daran erkennen, dass t1[i]==t2[i] gilt. Sobald das erreicht ist
       (siehe Ende der Schleife), darf t1 nicht weitergesetzt werden, da es
       sonst t2 "ueberholt", so dass Patch 2 groesser wird als Patch 1. */
    fl3 = fl-fl1-fl2;
    t1[0] = tree[fl1];
    while (t1[0] && (g1 = t1[0]->code)+g2 <= g) {
      t1[1] = t1[0]->weiter.nextlevel;  
      while (t1[1] && (krit1 = t1[1]->code)+krit2 <= krit_max) {
        t1[2] = t1[1]->weiter.nextlevel;
        if (t1[2] && t1[2]->code==1 &&    /* ein Rand */
           (!recover || (g1==g1_rec && krit1==krit1_rec)) &&
           ((do_sandwich && !l1_sandwich && !digon_path) || 
            (do_brille && !loop_brille && !digon_brille && !digon_path) ||
            (g1==0 && fl1==1))) {
          t1[2] = t1[2]->weiter.nextlevel->weiter.nextlevel;  
          /* vgl. Bauchbinde */
          while (t1[2] && t1[2]->code<=5) {  /* Rand hat <=2 Bruchkanten */
            codelen1 = t1[2]->code - 3; 
            t1[3] = t1[2]->weiter.nextlevel;      /* erster Randcodeeintrag */
            while (t1[3]) {                  /* Patchliste 1 steht fest */
              code1[0] = t1[3]->code; 
              if (codelen1==2) {t1[4] = t1[3]->weiter.nextlevel; 
                                code1[1] = t1[4]->code;}
              if ((codelen1==1 || (code1[0]!=BB_KENNUNG && code1[1]==0)) &&
                  ((do_sandwich && !l1_sandwich && !digon_path) || 
                   (do_brille && !loop_brille && !digon_brille && !digon_path)
                  || (codelen1<=2-(KNOTENTYP)(loop_brille && !do_sandwich) 
                      && code1[0]==0))) {    /* Patches gefunden */

  /* nun Patch 3 zuordnen (Text 30 Stellen einruecken): */
  t3[0] = tree[fl3];
  while (t3[0] && g1+g2+(g3 = t3[0]->code)<g) {t3[0] = t3[0]->next;}
  if (t3[0] && g1+g2+g3==g) {    /* Genus passt */
    t3[1] = t3[0]->weiter.nextlevel;
    while (t3[1] && krit1+krit2+(krit3 = t3[1]->code)<krit_min) 
          {t3[1] = t3[1]->next;}
    while (t3[1] && krit1+krit2+(krit3 = t3[1]->code)<=krit_max) { 
      /* Kritische Punkte sind im Intervall. Vorsicht: die Zuweisung des
         Werts an "krit3" ist zwar beim ersten Schleifendurchlauf
         ueberfluessig, nicht aber bei allen weiteren! */        
      t3[2] = t3[1]->weiter.nextlevel;
      if (t3[2] && t3[2]->code==1 &&
         (!recover || krit3==krit3_rec)) {    /* ein Rand */
        t3[2] = t3[2]->weiter.nextlevel->weiter.nextlevel;  /*vgl. Bauchbinde*/
        while (t3[2] && t3[2]->code<9-codelen1-codelen2)
              {t3[2] = t3[2]->next;}
        if (t3[2] && codelen1+codelen2+(codelen3 = t3[2]->code-3)==6) {
          /* Randlaenge passt */ 

          if (do_sandwich && ((!l1_sandwich && !digon_path) || 
             (g1==0 && fl1==1 && codelen1==2 && code1[0]==0)) &&
              (len12 = (code1[0]<<1)+codelen1)>1 && 
              (len23 = (code2[0]<<1)+codelen2)>1 &&
              /* die obigen Abfragen von "len12" und "len23" sind NICHT 
                 redundant, denn wenn "l1_sandwich==False", so koennen 
                 trotzdem Ein- und Zweiecke erlaubt sein */  
            (!recover || (pfadtyp_rec==2 && len12==l1_rec && len23==l3_rec))) {
            /* len12<=1, len23<=1 => Eineck => kein Sandwichpfad moeglich, und
               "len2" wuerde unzulaessige Werte annehmen. */
            t3[3] = t3[2]->weiter.nextlevel;     /* erster Randcodeeintrag */
            t3[4] = nil;  k = 0;
            len2 = MIN(len23,len12);
            len2 -= (1+(len2&1));   /* groesstmoegliche Laenge fuer Naht 2 */
              /* len2 ist immer ungerade => man kann ausrechnen, ob len1 und 
                 len3 (immer) gerade oder ungerade sind: len12 ist ungerade,
                 wenn codelen1==1. len1 ist dann, da len2 ungerade ist, 
                 gerade. Entsprechend fuer len3. */
            fall = 4 + codelen2 - (codelen1<<1);       /* Faelle 1-4 */
            if (t3[3]) {        
              bereite_sandwichcodes_vor(fall,len12-len2,len23-len2,code3,
                                        &aend,&i);
              /* Patches mit passenden Randcodes suchen:  (beachte:
                 nach dem Aufruf der Funktion "suche_randcode" sind nur 
                 noch die Eintraege code3[i] bis code3[i+codelen3-1] 
                 korrekt) */
              while (t3e = suche_randcode(&code3[i],codelen3,aend,&t3[3],&k)) {
                /* Patch 3 gefunden */ 
                len2 = MIN(len23,len12);
                len2 -= (1+(len2&1));    /* groesste Laenge fuer Naht 2 */ 
                if (len2 > (k<<1) &&      /* k ist klein genug */
                   (!recover || len2-(k<<1)==l2_rec)) {

                  count++;  count = count % mod;
                  if (!mod_used || recover || class==count) {
                    len2 -= (k<<1);        /* aktuelle Laenge von Nahtteil 2 */
                    e2 = t2[2+codelen2]->weiter.firstpatch;
                    nebenzweig[0] = 0L;
                    while (e2) {
                      e1 = t1[2+codelen1]->weiter.firstpatch;
                      while (e1) {    
                        e3 = t3e->weiter.firstpatch;
                        while (e3) {
                          if (!recover &&
                             (!facerestrict || flaechenzahlen3_ok(e1,e2,e3))) {
                            start = 0;  connfl = 0;  arraypos = 0;
                            konstruiere_patch(patchmap1,&start,dummyarray,
                                              e1,gk1,nil,&connfl,&arraypos);
                            start = 0;  arraypos = 0;
                                        /* "connfl" NICHT auf 0 setzen */
                            konstruiere_patch(patchmap2,&start,dummyarray,
                                              e2,gk2,nil,&connfl,&arraypos);
                            start = 0;  arraypos = 0;
                            konstruiere_patch(patchmap3,&start,dummyarray,
                                              e3,gk3,nil,&connfl,&arraypos);
                            bestimme_gute_basen(e1);
                            bestimme_gute_basen(e2);
                            bestimme_gute_basen(e3);
                            graphenzahl[ARRAYPOS_LN(g,n,2)]++;
                            gk3[0] = verknuepfe_sandwichpatches(gk1[0],gk2[0],
                                     gk3[0],len12-len2,len2,len23-len2,
                                     &code3[i],i ? 1+(fall>2) : 0,fall);
                            sandwich_minimalitaetstest(gk3[0]->next,
                              t1[2+codelen1]!=t2[2+codelen2],n,g,e1,e2,e3,
                              fall>2,1,False,0);
                          }
                          if (!recover && (save_flag || save_flag2)) 
                             {speichere_graphen_aus_outputliste_in_files(0,2,1,
                              0,len12,len2,len23,fl1,fl2,n,g1,g2,g,krit1,krit2,
                              krit3);}
                          if (recover && nebenzweig[0]==recovernebenzweig[0]) 
                             {recover = False;   count = recovercount;}
                          nebenzweig[0]++; 
                          if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
                          e3 = e3->next;
                        }   /* while e3 */ 
                        e1 = e1->next;   /* Patches aus gleicher Liste 2mal 
                                            verknuepfen (siehe oben) */
                      }    /* while e1 */
                      e2 = e2->next;
                    }    /* while e2 */
                  }     /* if class==count */
                }     /* if len2>k*2 */
              }      /* while t3e */
            }       /* if t3[3] */
          }        /* if do_sandwich */

          if (do_brille && ((!loop_brille && !digon_brille && !digon_path) ||
             (g1==0 && fl1==1 && codelen1<=1+(KNOTENTYP)(digon_brille) && 
              code1[0]==0)) && (!recover || (pfadtyp_rec==3 && 
              (code1[0]<<1)+codelen1==l1_rec &&
              (code2[0]<<1)+codelen2==l3_rec))) {
            t3[3] = t3[2]->weiter.nextlevel;     /* erster Randcodeeintrag */
            t3[4] = nil;  k = 0;
            fall = 7 - (codelen1<<1) - codelen2;   /* zunaechst Faelle 1-4 */
            while (t3[3]) {        
              bereite_brillencodes_vor(fall,code1,code2,code3,&aend,&i,
                                       1+(fall>4));
              /* Patches mit passenden Randcodes suchen:  (beachte:
                 nach dem Aufruf der Funktion "suche_randcode" sind nur noch 
                 die Eintraege code3[i] bis code3[i+codelen3-1] korrekt) */
              while (t3e = suche_randcode(&code3[i],codelen3,aend,&t3[3],&k)) {
                /* Patch 3 gefunden */
                len = (k<<1)+(fall<5);       /* mittlere Naht */
                if (!recover || len==l2_rec) {
                  count++;  count = count % mod;
                  if (!mod_used || recover || class==count) {
                    nebenzweig[0] = 0L;
                    e2 = t2[2+codelen2]->weiter.firstpatch;
                    while (e2) {
                      e1 = t1[2+codelen1]->weiter.firstpatch;
                      while (e1) {    
                        e3 = t3e->weiter.firstpatch;
                        while (e3) {
                          if (!recover &&
                             (!facerestrict || flaechenzahlen3_ok(e1,e2,e3))) {
                            start = 0;  connfl = 0;  arraypos = 0;
                            konstruiere_patch(patchmap1,&start,dummyarray,
                                              e1,gk1,nil,&connfl,&arraypos);
                            start = 0;  arraypos = 0;
                            konstruiere_patch(patchmap2,&start,dummyarray,
                                              e2,gk2,nil,&connfl,&arraypos);
                            start = 0;  arraypos = 0;
                            konstruiere_patch(patchmap3,&start,dummyarray,
                                              e3,gk3,nil,&connfl,&arraypos);
                            bestimme_gute_basen(e1);
                            bestimme_gute_basen(e2);
                            bestimme_gute_basen(e3);
                            graphenzahl[ARRAYPOS_LN(g,n,3)]++;
                            gk3[0] = verknuepfe_brillenpatches(gk1[0],gk2[0],
                                     gk3[0],(code1[0]<<1)+codelen1,
                                     (code2[0]<<1)+codelen2,len,&code3[i],
                                     i ? 3-codelen1 : 0,fall);
                            brillen_minimalitaetstest(gk3[0],
                              t1[2+codelen1]!=t2[2+codelen2],n,g,e1,e2,e3,1,0);
                          }
                          if (!recover && (save_flag || save_flag2)) 
                             {speichere_graphen_aus_outputliste_in_files(0,3,1,
                              0,(code1[0]<<1)+codelen1,len,
                              (code2[0]<<1)+codelen2,
                              fl1,fl2,n,g1,g2,g,krit1,krit2,krit3);}
                          if (recover && nebenzweig[0]==recovernebenzweig[0]) 
                             {recover = False;   count = recovercount;}
                          nebenzweig[0]++; 
                          if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
                          e3 = e3->next;
                        }   /* while e3 */ 
                        e1 = e1->next;   /* Patches aus gleicher Liste 2mal 
                                            verknuepfen (siehe oben) */
                      }    /* while e1 */
                      e2 = e2->next;
                    }    /* while e2 */
                  }     /* if */
                }      /* if */
              }      /* while t3e */
              if (fall<5)   /* Faelle 5-8 starten (k ist mindestens 1) */  
	         {fall += 4;  t3[3] = t3[2]->weiter.nextlevel;  t3[4] = nil;  
                  k = 1;}
              else {t3[3] = nil;}    /* Schleife beenden   */
            }       /* while t3[3] */
	  }      /* if do_brille */
         
        }        /* if richtige Codelaenge */
      }         /* if ein Rand */
      t3[1] = t3[1]->next;
    }      /* while kritische Punkte */
  }       /* if Genus passt */
  /* Ende des um 30 Stellen eingerueckten Textes */

              }  /* if */
              if (t1[3]==t2[3]) {t1[3]=nil;} else {t1[3]=t1[3]->next;}
                 /* t1 darf t2 nicht "ueberholen" */
            }    /* while t1[3] */
            if (t1[2]==t2[2]) {t1[2]=nil;} else {t1[2]=t1[2]->next;}
          }      /* while t1[2] */
        }        /* if */
        if (t1[1]==t2[1]) {t1[1]=nil;} else {t1[1]=t1[1]->next;}
      }          /* while t1[1] */  
      if (t1[0]==t2[0]) {t1[0]=nil;} else {t1[0]=t1[0]->next;}
    }            /* while t1[0] */
  }              /* for fl1 */
  /* Ende des um 16 Stellen eingerueckten Textes */

                }  /* if */
                t2[3]=t2[3]->next;
              }    /* while t2[3] */
              t2[2]=t2[2]->next;
            }      /* while t2[2] */
          }        /* if */
          t2[1]=t2[1]->next;
        }          /* while t2[1] */  
        t2[0]=t2[0]->next;
      }            /* while t2[0] */
    }              /* for fl2 */
  }

  if ((!recover || mgl_rec==2) && 
      ((do_sandwich && !l1_sandwich && !digon_path) || 
       (do_brille && !loop_brille && !digon_brille && !digon_path))) {
    /* ---- Moeglichkeit 2: 2 Patches miteinander verkleben, wobei ein Patch
                      beide Nebenraender enthaelt ---- */
    /* Patch 1 heraussuchen (Nebenraender):  Die Raenderinformationen 
       werden so auf t1,t2,codelen1,codelen2 usw. verteilt, als ob es sich um
       2 getrennte Patches handelte. fl2, krit2 und g2 werden nicht belegt. */
    for (fl1 = recover ? fln1_rec : 1; fl1+1<=fl; fl1++) {     /* Patch 1 */
      fl3 = fl-fl1;
      t1[0] = tree[fl1];
      while (t1[0] && (g1 = t1[0]->code) < g) {   /* erster Level: Genus */
        /* echt kleiner "g", da Genus bei Verklebung um 1 steigt */
        t1[1] = t1[0]->weiter.nextlevel;  
        while (t1[1] && (krit1 = t1[1]->code) <= krit_max) {  /*zweiter Level*/
          t1[2] = t1[1]->weiter.nextlevel;
          while (t1[2] && t1[2]->code<2) {t1[2] = t1[2]->next;}
          if (t1[2] && t1[2]->code==2 &&           /* zwei Raender */
             (!recover || (g1==g1_rec && krit1==krit1_rec))) {
            t1[2] = t1[2]->weiter.nextlevel->weiter.nextlevel;   
            /* vgl. Bauchbinde */
            while (t1[2] && t1[2]->code<=6) { /* erster Rand <=2 Bruchkanten */
              codelen1 = t1[2]->code - 4; 
              t2[2] = t1[2]->weiter.nextlevel;  
              /* t2[2] ist willkuerlich gewaehlt */
              while (t2[2] && (codelen2=t2[2]->code-t1[2]->code)<=2) { 
                /* 2.Rand <=2 Bruchkanten */
                /* ab hier enthalten t1 und t2 dieselben Informationen wie in 
                   der oberen Schleife (Moeglichkeit 1) */
                t1[3] = t2[2]->weiter.nextlevel;
                while (t1[3]) {
                  code1[0] = t1[3]->code;
                  if (codelen1==2) {t1[4] = t1[3]->weiter.nextlevel; 
                                    code1[1] = t1[4]->code;}
                  if (codelen1==1 || (code1[0]!=BB_KENNUNG && code1[1]==0)) { 
                    /* erster Rand passt */
                    t2[3] = t1[2+codelen1]->weiter.nextlevel;
                    while (t2[3]) {
                      code2[0] = t2[3]->code;
                      if (codelen2==2) {t2[4] = t2[3]->weiter.nextlevel; 
                                        code2[1] = t2[4]->code;}
                      if (codelen2==1 || 
                         (code2[0]!=BB_KENNUNG && code2[1]==0)) {
                         /* dritter Rand passt */
                         /* kein Schleifendurchlauf fuer t2[4] erforderlich,
                            da Codeeintrag sowieso =0 sein soll (also wenn, 
                            dann immer nur erster Zweig interessant) */
                        
  /* nun Patch 3 zuordnen (Text 24 Stellen einruecken): */
  t3[0] = tree[fl3];
  while (t3[0] && g1+(g3 = t3[0]->code)+1<g) {t3[0] = t3[0]->next;}
  if (t3[0] && g1+g3+1==g) {    /* Genus passt */
    t3[1] = t3[0]->weiter.nextlevel;
    while (t3[1] && krit1+(krit3 = t3[1]->code)<krit_min) 
          {t3[1] = t3[1]->next;}
    while (t3[1] && krit1+(krit3 = t3[1]->code)<=krit_max) { 
      /* kritische Punkte im Intervall */        
      t3[2] = t3[1]->weiter.nextlevel;
      if (t3[2] && t3[2]->code==1 &&    /* ein Rand */
         (!recover || krit3==krit3_rec)) {
        t3[2] = t3[2]->weiter.nextlevel->weiter.nextlevel;  
        /* vgl. Bauchbinde */
        while (t3[2] && t3[2]->code<9-codelen1-codelen2)
              {t3[2] = t3[2]->next;}
        if (t3[2] && codelen1+codelen2+(codelen3 = t3[2]->code-3)==6) {
          /* Randlaenge passt */ 
 
          if (do_sandwich && !l1_sandwich && !digon_path && 
              (!recover || (pfadtyp_rec==2 &&
              (code1[0]<<1)+codelen1==l1_rec &&
              (code2[0]<<1)+codelen2==l3_rec))) {
            t3[3] = t3[2]->weiter.nextlevel;       /* erster Randcodeeintrag */
            t3[4] = nil;  k = 0;
            len12 = (code1[0]<<1)+codelen1;  /* >1, da Patch 2 Raender hat */
            len23 = (code2[0]<<1)+codelen2;
            len2 = MIN(len23,len12);
            len2 -= (1+(len2&1));   /* groesstmoegliche Laenge fuer Naht 2 */
            fall = 4 + codelen2 - (codelen1<<1);       /* Faelle 1-4 */
            if (fall==4) {fprintf(stderr,"Logischer Fehler in "
                    "bilde_graphen_aus_sandwichpatches: fall 4 in case 2\n");
                    exit(30);}  /* zweiter Randcode kann nicht laenger sein
                                    als erster */
            if (t3[3]) {        
              bereite_sandwichcodes_vor(fall,len12-len2,len23-len2,code3,
                                        &aend,&i);
              gleiche_randcodes = (len12==len23); /* Raender 1 und 2 gleich? */
                             /* <=> codelen1==codelen2 && code1[0]==code2[0] */
              while (t3e = suche_randcode(&code3[i],codelen3,aend,&t3[3],&k)) {
                /* Patch 3 gefunden */ 
                len2 = MIN(len23,len12);
                len2 -= (1+(len2&1));    /* groesste Laenge fuer Naht 2 */ 
                if (len2 > (k<<1) &&     /* k ist klein genug */
                   (!recover || len2-(k<<1)==l2_rec)) {
                  count++;  count = count % mod;
                  if (!mod_used || recover || class==count) {
                    len2 -= (k<<1);        /* aktuelle Laenge von Nahtteil 2 */
                    e1 = t2[2+codelen2]->weiter.firstpatch;
                    nebenzweig[0] = 0L;
                    while (e1) {
                      iso = -1;     /* unbestimmt, ob Raender isomorph sind */
                      e2 = t3e->weiter.firstpatch;
                      while (e2) {
                        if (!recover &&
                           (!facerestrict || flaechenzahlen3_ok(e1,e2,nil))) {
                          start = 0;  connfl = 0;  arraypos = 0;
                          konstruiere_patch(patchmap1,&start,dummyarray,
                                          e1,gk1,nil,&connfl,&arraypos);
                          if (iso==-1) {iso = gleiche_randcodes ? 
                                        (char)iso_raender(e1,0,1) : 0;}
                             /* "iso" nur einmal berechnen */
                          start = 0;  arraypos = 0;
                          konstruiere_patch(patchmap2,&start,dummyarray,
                                            e2,gk2,nil,&connfl,&arraypos);
                          bestimme_gute_basen(e1);
                          bestimme_gute_basen(e2);
                          graphenzahl[ARRAYPOS_LN(g,n,2)]++;
                          gk3[0] = verknuepfe_sandwichpatches(gk1[0],gk1[1],
                                   gk2[0],len12-len2,len2,len23-len2,&code3[i],
                                   i ? 1+(fall>2) : 0,fall);
                          /* gk1[0] und gk1[1] duerfen nicht vertauscht werden,
                             denn gk1[1] spielt die Rolle von Rand 2 */
                          /* gk1[0] ist nicht automatisch die Grundkante vom 
                             ersten Rand, sondern die Grundkante vom LAENGEREN 
                             Rand (d.h. vom Rand mit der hoeheren Prioritaet). 
                             Im vorliegenden Fall ist der erste Rand aber
                             nie kuerzer als der zweite. */
                          sandwich_minimalitaetstest(gk3[0]->next,
                            !gleiche_randcodes,n,g,e1,e2,nil,fall>2,21,False,
                            0);
                          /* Falls Randcodes von Patch 1 gleich, aber Raender 
                             nicht
                             isomorph sind: noch ein Durchgang mit vertauschten
                             Raendern (fall,len12,len23 bleiben erhalten) */
                          if (gleiche_randcodes && iso==0) {
                            start = 0;  connfl = 0;  arraypos = 0;
                            konstruiere_patch(patchmap1,&start,dummyarray,
                                              e1,gk1,nil,&connfl,&arraypos);
                            start = 0;  arraypos = 0;
                            konstruiere_patch(patchmap2,&start,dummyarray,
                                              e2,gk2,nil,&connfl,&arraypos);
                            graphenzahl[ARRAYPOS_LN(g,n,2)]++;
                            gk3[0] = verknuepfe_sandwichpatches(gk1[1],gk1[0],
                                     gk2[0],len23-len2,len2,len12-len2,
                                     &code3[i],i ? 1+(fall>2) : 0,fall);
                            /* gk1[0] und gk1[1] duerfen nicht vertauscht 
                               werden,
                               denn gk1[1] spielt hier die Rolle von Rand 1 */
                            sandwich_minimalitaetstest(gk3[0]->next,
                              False,n,g,e1,e2,nil,fall>2,22,False,0);
                          }
                        }
                        if (!recover && (save_flag || save_flag2)) 
                           {speichere_graphen_aus_outputliste_in_files(0,2,2,0,
                            len12,len2,len23,fl1,0,n,g1,0,g,krit1,0,krit3);}
                        if (recover && nebenzweig[0]==recovernebenzweig[0]) 
                           {recover = False;   count = recovercount;}
                        nebenzweig[0]++; 
                        if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
                        e2 = e2->next;
                      }   /* while e2 */ 
                      e1 = e1->next; 
                    }    /* while e1 */
                  }     /* if */
                }     /* if len2>k*2 */
              }    /* while t3e */
            }     /* if t3[3] */
          }      /* if (do_sandwich) */

          if (do_brille && !loop_brille && !digon_brille && !digon_path &&
             (!recover || (pfadtyp_rec==3 &&
             (code1[0]<<1)+codelen1==l1_rec &&
             (code2[0]<<1)+codelen2==l3_rec))) {
            t3[3] = t3[2]->weiter.nextlevel;      /* erster Randcodeeintrag */
            t3[4] = nil;  k = 0;
            fall = 7 - (codelen1<<1) - codelen2;   /* zunaechst Faelle 1-4 */
            while (t3[3]) {        
              bereite_brillencodes_vor(fall,code1,code2,code3,&aend,&i,
                                       1+(fall>4));
              gleiche_randcodes = (codelen1==codelen2 && code1[0]==code2[0]); 
              while (t3e = suche_randcode(&code3[i],codelen3,aend,&t3[3],&k)) {
                /* Patch 3 gefunden */
                len = (k<<1)+(fall<5);       /* mittlere Naht */
                if (!recover || len==l2_rec) { 
                  count++;  count = count % mod;
                  if (!mod_used || recover || class==count) {
                    e1 = t2[2+codelen2]->weiter.firstpatch;
                    nebenzweig[0] = 0L;
                    while (e1) {    
                      iso = -1;
                      e3 = t3e->weiter.firstpatch;
                      while (e3) {
                        if (!recover &&
                           (!facerestrict || flaechenzahlen3_ok(e1,e3,nil))) {
                          start = 0;  connfl = 0;  arraypos = 0;
                          konstruiere_patch(patchmap1,&start,dummyarray,
                                            e1,gk1,nil,&connfl,&arraypos);
                          if (iso==-1) {iso = gleiche_randcodes ? 
                                        (char)iso_raender(e1,0,1) : 0;}
                          start = 0;  arraypos = 0;
                          konstruiere_patch(patchmap3,&start,dummyarray,
                                            e3,gk3,nil,&connfl,&arraypos);
                          bestimme_gute_basen(e1);
                          bestimme_gute_basen(e3);
                          graphenzahl[ARRAYPOS_LN(g,n,3)]++;
                          gk3[0] = verknuepfe_brillenpatches(gk1[0],gk1[1],
                                   gk3[0],(code1[0]<<1)+codelen1,(code2[0]<<1)+
                                   codelen2,len,&code3[i],i ? 3-codelen1 : 0,
                                   fall);
                          brillen_minimalitaetstest(gk3[0],
                                   !gleiche_randcodes,n,g,e1,e3,nil,21,0);
                          if (gleiche_randcodes && iso==0) {  /* vertauschen */
                            start = 0;  connfl = 0;  arraypos = 0;
                            konstruiere_patch(patchmap1,&start,dummyarray,
                                              e1,gk1,nil,&connfl,&arraypos);
                            start = 0;  arraypos = 0;
                            konstruiere_patch(patchmap3,&start,dummyarray,
                                              e3,gk3,nil,&connfl,&arraypos);
                            graphenzahl[ARRAYPOS_LN(g,n,3)]++;
                            gk3[0] = verknuepfe_brillenpatches(gk1[1],gk1[0],
                                     gk3[0],(code2[0]<<1)+codelen2,
                                     (code1[0]<<1)+codelen1,len,&code3[i],
                                     i ? 3-codelen2 : 0,fall);
                            brillen_minimalitaetstest(gk3[0],
                                     False,n,g,e1,e3,nil,22,0);
                          }  
                        }
                        if (!recover && (save_flag || save_flag2)) 
                           {speichere_graphen_aus_outputliste_in_files(0,3,2,0,
                            (code1[0]<<1)+codelen1,len,(code2[0]<<1)+codelen2,
                            fl1,0,n,g1,0,g,krit1,0,krit3);}
                        if (recover && nebenzweig[0]==recovernebenzweig[0]) 
                           {recover = False;   count = recovercount;}
                        nebenzweig[0]++; 
                        if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
                        e3 = e3->next;
                      }   /* while e3 */ 
                      e1 = e1->next;
                    }    /* while e1 */
                  }    /* if */
                }     /* if */
              }      /* while t3e */
              if (fall<5)     /* Faelle 5-8 starten (k ist mindestens 1) */  
  	         {fall += 4;  t3[3] = t3[2]->weiter.nextlevel;  t3[4] = nil;  
                  k = 1;}
              else {t3[3] = nil;}    /* Schleife beenden   */
            }       /* while t3[3]   */
          }        /* if do_brille */

        }      /* if richtige Codelaenge */
      }         /* if ein Rand */
      t3[1] = t3[1]->next;
    }      /* while kritische Punkte */
  }       /* if Genus passt */
  /* Ende des um 24 Stellen eingerueckten Textes */

                      }    /* if zweiter Rand passt */
                      t2[3] = t2[3]->next;
                    }
                  }      /* if erster Rand passt */
                  t1[3] = t1[3]->next;
                }
                t2[2] = t2[2]->next;
              }        /* while t2[2] */
              t1[2] = t1[2]->next;
            }          /* while t1[2] */
          }            /* if zwei Raender */
          t1[1] = t1[1]->next;
        }              /* while t1[1] */
        t1[0] = t1[0]->next;
      }                /* while t1[0] */
    }                  /* for fl1 */
  }                    /* if mgl_rec==2 */

  if (!recover || mgl_rec==3) {
    /* ---- Moeglichkeit 3: 2 Patches miteinander verkleben, wobei ein Patch
            einen Nebenrand und den Hauptrand enthaelt ---- */
    /* Patch 2 heraussuchen (Nebenrand): */
    for (fl2 = recover ? fln2_rec : 1; fl2+1<=fl; fl2++) {     /* Patch 2 */
      fl3 = fl-fl2;
      t2[0] = tree[fl2];
      while (t2[0] && (g2 = t2[0]->code) < g) {   /* erster Level: Genus */
        /* echt kleiner "g", da Genus bei Verklebung um 1 steigt */
        t2[1] = t2[0]->weiter.nextlevel;  
        while (t2[1] && (krit2 = t2[1]->code) <= krit_max) {  /*zweiter Level*/
          t2[2] = t2[1]->weiter.nextlevel;
          if (t2[2] && t2[2]->code==1 &&    /* ein Rand */
             (!recover || (g2==g2_rec && krit2==krit2_rec)) &&
             ((do_sandwich && !l1_sandwich && !digon_path) || 
              (do_brille && !loop_brille && !digon_brille && !digon_path) || 
              (g2==0 && fl2==1))) {
            t2[2] = t2[2]->weiter.nextlevel->weiter.nextlevel;   
            /* vgl. Bauchbinde */
            while (t2[2] && t2[2]->code<=5) {  /* Rand hat <=2 Bruchkanten */
              codelen2 = t2[2]->code - 3; 
              t2[3] = t2[2]->weiter.nextlevel;    /* erster Randcodeeintrag */
              while (t2[3]) {                  /* Patchliste 2 steht fest */
                code2[0] = t2[3]->code; 
                if (codelen2==2) {t2[4] = t2[3]->weiter.nextlevel; 
                                  code2[1] = t2[4]->code;}
                if ((codelen2==1 || (code2[0]!=BB_KENNUNG && code2[1]==0)) &&
                    ((do_sandwich && !l1_sandwich && !digon_path) || 
                    (do_brille && !loop_brille && !digon_brille && !digon_path)
                    || (codelen2<=2-(KNOTENTYP)(loop_brille && !do_sandwich) &&
                        code2[0]==0))) {                /* Patches gefunden */

  /* Nun Patch 1 zuordnen (Text 16 Stellen einruecken): */
  t3[0] = tree[fl3];
  while (t3[0] && g2+(g3 = t3[0]->code)+1<g) {t3[0] = t3[0]->next;}
  if (t3[0] && g3+g2+1==g) {    /* Genus passt */
    t3[1] = t3[0]->weiter.nextlevel;
    while (t3[1] && krit2+(krit3 = t3[1]->code)<krit_min) 
          {t3[1] = t3[1]->next;}
    while (t3[1] && krit2+(krit3 = t3[1]->code)<=krit_max) { 
      /* kritische Punkte im Intervall */        
      t1[0] = t3[1]->weiter.nextlevel;    /* t1[0] ist willkuerlich gewaehlt */
      while (t1[0] && t1[0]->code<2) {t1[0] = t1[0]->next;}
      if (t1[0] && t1[0]->code==2 &&    /* zwei Raender */
         (!recover || krit3==krit3_rec)) {
        t3[2] = t1[0]->weiter.nextlevel->weiter.nextlevel; /*vgl. Bauchbinde*/

        /* --- 3.1: erster Rand in Patch 1 ist fuer Nebenrand --- */
        /*    (geht nur bei Sandwich und dort nur bei Fall 2, da sonst erster
               Rand kuerzer als zweiter Rand waere)  */
        while (t3[2] && t3[2]->code<=6) {   /* Rand hat <=2 Bruchkanten */
          codelen1 = t3[2]->code - 4;
          t1[2] = t3[2]->weiter.nextlevel;
          /* t1[2] ist willkuerlich gewaehlt */
          while (t1[2] && codelen1+(codelen3 = t1[2]->code-t3[2]->code)+
                 codelen2 < 6) {t1[2] = t1[2]->next;}
          if (t1[2] && codelen1+codelen2+codelen3==6) {  /* Randlaenge passt */
            t1[3] = t1[2]->weiter.nextlevel;    /* erster Randcodeeintrag */
            while (t1[3]) {
              code1[0] = t1[3]->code;
              if (codelen1==2) {t1[4] = t1[3]->weiter.nextlevel; 
                                code1[1] = t1[4]->code;}
              if (codelen1==1 || (code1[0]!=BB_KENNUNG && code1[1]==0)) { 
                 /* Rand 1 passt */

        /* folgenden Text um 24 Stellen einruecken: */
        if (do_sandwich && ((!l1_sandwich && !digon_path) || 
           (g2==0 && fl2==1 && codelen2==2 && code2[0]==0)) &&
           (len23 = (code2[0]<<1)+codelen2)>1 &&
           (!recover || (pfadtyp_rec==2 && submgl_rec==1 && len23==l3_rec &&
            (code1[0]<<1)+codelen1==l1_rec))) {
          t3[3] = t1[2+codelen1]->weiter.nextlevel; /* Beginn von Randcode 3 */
          t3[4] = nil;  k = 0;
          len12 = (code1[0]<<1)+codelen1;  /* >1, da Patch 2 Raender hat */
          len2 = MIN(len23,len12);
          len2 -= (1+(len2&1));      /* groesstmgl. Laenge fuer Naht 2 */

          /* -- 3.1.1:  erster Rand in Patch 1 ist Nebenrand 1 -- */
          fall = 4 + codelen2 - (codelen1<<1);       /* Faelle 1-4 */
          if (fall!=2) {fprintf(stderr,"Dicker Fehler in "
                        "bilde_graphen_aus_sandwichpatches!\n"); exit(31);}
          if (t3[3]) {        
            bereite_sandwichcodes_vor(fall,len12-len2,len23-len2,code3,
                                      &aend,&i);
            while (t3e = suche_randcode(&code3[i],codelen3,aend,&t3[3],&k)) {
              /* Rand 3 gefunden */ 
              len2 = MIN(len23,len12);
              len2 -= (1+(len2&1));    /* groesste Laenge fuer Naht 2 */ 
              if (len2 > (k<<1) &&     /* k ist klein genug */
                 (!recover || len2-(k<<1)==l2_rec)) {
                count++;  count = count % mod;
                if (!mod_used || recover || class==count) {
                  len2 -= (k<<1);        /* aktuelle Laenge von Nahtteil 2 */
                  e1 = t2[2+codelen2]->weiter.firstpatch;
                  nebenzweig[0] = 0L;
                  while (e1) {
                    e2 = t3e->weiter.firstpatch;
                    while (e2) {
                      if (!recover &&
                         (!facerestrict || flaechenzahlen3_ok(e1,e2,nil))) {
                        start = 0;  connfl = 0;  arraypos = 0;
                        konstruiere_patch(patchmap1,&start,dummyarray,
                                          e1,gk1,nil,&connfl,&arraypos);
                        start = 0;  arraypos = 0;
                        konstruiere_patch(patchmap2,&start,dummyarray,
                                          e2,gk2,nil,&connfl,&arraypos);
                        bestimme_gute_basen(e1);
                        bestimme_gute_basen(e2);
                        graphenzahl[ARRAYPOS_LN(g,n,2)]++;
                        gk3[0] = verknuepfe_sandwichpatches(gk2[0],gk1[0],
                                 gk2[1],len12-len2,len2,len23-len2,&code3[i],
                                 i ? 1+(fall>2) : 0,fall);
                        /* gk2[1] und gk1[0] duerfen nicht vertauscht werden, 
                           denn gk1[0] spielt die Rolle von Nebenrand 2 */
                        /* gk2[0] muss der Nebenrand in Patch 1 sein, denn 
                           gerade danach wurde gesucht und 
                           Randcode 1==Randcode 3 ist nicht moeglich */
                        sandwich_minimalitaetstest(gk3[0]->next,True,n,g,e1,
                                                   e2,nil,fall>2,31,False,0);
                        /* festlegen=True, denn die Patches von Rand 1 und Rand
                           2 stammen immer aus unterschiedlichen Listen und 
                           werden nicht vertauscht. */
                      }
                      if (!recover && (save_flag || save_flag2)) 
                         {speichere_graphen_aus_outputliste_in_files(0,2,3,1,
                          len12,len2,len23,0,fl2,n,0,g2,g,0,krit2,krit3);}
                      if (recover && nebenzweig[0]==recovernebenzweig[0]) 
                         {recover = False;   count = recovercount;}
                      nebenzweig[0]++; 
                      if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
                      e2 = e2->next;
                    }   /* while e2 */ 
                    e1 = e1->next; 
                  }    /* while e1 */
                }     /* if */
              }    /* if len2>k*2 */
            }    /* while t3e */
          }     /* if t3[3] */
        }      /* if do_sandwich */
        /* Ende des um 24 Stellen eingerueckten Textes */

              }    /* if Rand 1 passt */
              t1[3] = t1[3]->next;
	    }    /* while t1[3] */
          }      /* if Randlaenge passt */
          t3[2] = t3[2]->next;
        }        /* while t3[2] */

        /* --- 3.2: erster Rand in Patch 1 ist fuer Hauptrand --- */
        /* Dieser Fall wird nicht durchlaufen, wenn die beiden Raender in
           Patch 1 isomorph sind, weil dann eine Dopplung gegenueber
           Fall 3.1 auftritt. */
        t3[2] = t1[0]->weiter.nextlevel->weiter.nextlevel;
        /* nochmal durchgehen */
        while (t3[2] && t3[2]->code<=8) {   /* Rand hat <=4 Bruchkanten */
          codelen3 = t3[2]->code - 4;
          if (codelen3>1) {
            t1[2] = t3[2]->weiter.nextlevel;  
            /* t1[2] ist willkuerlich gewaehlt */
            while (t1[2] && codelen2+(codelen1 = t1[2]->code-t3[2]->code)+
                   codelen3 < 6) {t1[2] = t1[2]->next;}
            if (t1[2] && codelen1+codelen2+codelen3==6) { 
              t3[3] = t1[2]->weiter.nextlevel;   
              /* erster Randcodeeintrag Rand 2 */
              j = 3;                       /* aktueller Level */
              while (t3[3] && j>2) {       /* es kommen noch Patches im Baum */
                while (j-3<codelen3) {     /* Randcode 2 ermitteln */
                  code3[j-3] = t3[j]->code;
                  j++;
                  if (j-3<codelen3) {t3[j] = t3[j-1]->weiter.nextlevel;}
                }
                j--;          /* "j" zeigt auf letzten sinnvollen Eintrag */
                if (codelen3>2 || code3[0]!=BB_KENNUNG) { 
                   /* Randcode 3 gefunden - Randcode 1 ermitteln */
                  t1[3] = t3[j]->weiter.nextlevel;
                  while (t1[3]) {
                    code1[0] = t1[3]->code;
                    if (codelen1==2) {t1[4] = t1[3]->weiter.nextlevel;
                                      code1[1] = t1[4]->code;}
                    if (codelen1==1 || (code1[0]!=BB_KENNUNG && code1[1]==0)) {
                       /* Rand 1 passt - nun schauen, ob alle drei Raender
                          zueinander passen */
                      
        /* folgenden Text um 30 Stellen einruecken: */
        /* -- 3.2.1:  zweiter Rand in Patch 1 ist Nebenrand 1 -- */
        if (do_sandwich && ((!l1_sandwich && !digon_path) || 
           (g2==0 && fl2==1 && codelen2==2 && code2[0]==0)) && 
           (len23 = (code2[0]<<1)+codelen2)>1 &&
           (!recover || (pfadtyp_rec==2 && submgl_rec==2 && len23==l3_rec &&
            (code1[0]<<1)+codelen1==l1_rec))) {
          if (fall = passen_sandwichcodes(code1,codelen1,code2,codelen2,
              code3,codelen3,&i,&k)) {    /* Codes passen zusammen */
            len12 = (code1[0]<<1)+codelen1;
            len2 = (k<<1)+1;
            if (!recover || len2==l2_rec) {
              count++;  count = count % mod;
              if (!mod_used || recover || class==count) {
                gleiche_randcodes = (codelen1==codelen3 && code1[0]==code3[0]);
                                    /* Randcodes in Patch 1 gleich? */
                e1 = t2[2+codelen2]->weiter.firstpatch;
                nebenzweig[0] = 0L;
                while (e1) {
                  e2 = t1[2+codelen1]->weiter.firstpatch;
                  while (e2) {
                    if (!recover &&
                       (!facerestrict || flaechenzahlen3_ok(e1,e2,nil))) {
                      start = 0;  connfl = 0;  arraypos = 0;
                      konstruiere_patch(patchmap1,&start,dummyarray,
                                        e1,gk1,nil,&connfl,&arraypos);
                      start = 0;  arraypos = 0;
                      konstruiere_patch(patchmap2,&start,dummyarray,
                                        e2,gk2,nil,&connfl,&arraypos);
                      if (!(gleiche_randcodes && iso_raender(e2,0,1))) {
                        /* keine Dopplung gegenueber Fall 3.1 */
                        bestimme_gute_basen(e1);
                        bestimme_gute_basen(e2);
                        graphenzahl[ARRAYPOS_LN(g,n,2)]++;
                        gk3[0] = verknuepfe_sandwichpatches(gk2[1],gk1[0],
                                 gk2[0],len12-len2,len2,len23-len2,&code3[0],i,
                                 fall);
                        /* laeuft, da "code3" in der Funktion "passen_sandwich-
                           codes" zweimal hintereinandergeschrieben wurde */
                        sandwich_minimalitaetstest(gk3[0]->next,True,n,g,e1,
                                                   e2,nil,fall>2,32,False,0);
                        /* festlegen=True, denn die Patches von Rand 1 und Rand
                           2 stammen immer aus unterschiedlichen Listen und
                           werden nicht vertauscht. */
                      }
                    }
                    if (!recover && (save_flag || save_flag2)) 
                       {speichere_graphen_aus_outputliste_in_files(0,2,3,2,
                        len12,len2,len23,0,fl2,n,0,g2,g,0,krit2,krit3);}
                    if (recover && nebenzweig[0]==recovernebenzweig[0]) 
                     {recover = False;   count = recovercount;}
                    nebenzweig[0]++; 
                    if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
                    e2 = e2->next;
                  }   /* while e2 */ 
                  e1 = e1->next; 
                }  /* while e1 */
              }   /* if */
            }    /* if */
          }     /* if passen Codes */
        }      /* if do_sandwich */

        if (do_brille && ((!loop_brille && !digon_brille && !digon_path) ||
            (fl2==1 && g2==0 && codelen2<=1+(KNOTENTYP)(digon_brille) && 
            code2[0]==0)) && (!recover || (pfadtyp_rec==3 &&
            (code1[0]<<1)+codelen1==l1_rec &&
            (code2[0]<<1)+codelen2==l3_rec))) {
          if (fall = passen_brillencodes(code1,codelen1,code2,codelen2,
              code3,codelen3,&i,&k)) {    /* Codes passen zusammen */
            /* Die Randcodes von Patch 1 sind nicht gleich, da bei der
               Brille Haupt- und Nebenrand nicht gleich sein koennen. */
            len = (k<<1)+(fall<5);        /* mittlere Naht */
            if (!recover || len==l2_rec) {
              count++;  count = count % mod;
              if (!mod_used || recover || class==count) {
                e1 = t2[2+codelen2]->weiter.firstpatch;
                nebenzweig[0] = 0L;
                while (e1) {    
                  e3 = t1[2+codelen1]->weiter.firstpatch;
                  while (e3) {
                    if (!recover &&
                       (!facerestrict || flaechenzahlen3_ok(e1,e3,nil))) {
                      start = 0;  connfl = 0;  arraypos = 0;
                      konstruiere_patch(patchmap1,&start,dummyarray,
                                        e1,gk1,nil,&connfl,&arraypos);
                      start = 0;  arraypos = 0;
                      konstruiere_patch(patchmap3,&start,dummyarray,
                                        e3,gk3,nil,&connfl,&arraypos);
                      bestimme_gute_basen(e1);
                      bestimme_gute_basen(e3);
                      graphenzahl[ARRAYPOS_LN(g,n,3)]++;
                      gk3[0] = verknuepfe_brillenpatches(gk3[1],gk1[0],
                               gk3[0],(code1[0]<<1)+codelen1,(code2[0]<<1)+
                               codelen2,len,&code3[0],i,fall);
                      brillen_minimalitaetstest(gk3[0],True,n,g,e1,e3,nil,
                                                32,0);
                    }
                    if (!recover && (save_flag || save_flag2)) 
                       {speichere_graphen_aus_outputliste_in_files(0,3,3,0,
                        (code1[0]<<1)+codelen1,len,(code2[0]<<1)+codelen2,0,
                        fl2,n,0,g2,g,0,krit2,krit3);}
                    if (recover && nebenzweig[0]==recovernebenzweig[0]) 
                       {recover = False;   count = recovercount;}
                    nebenzweig[0]++; 
                    if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
                    e3 = e3->next;
                  }   /* while e3 */ 
                  e1 = e1->next;
                }    /* while e1 */
              }     /* if */
            }      /* if */
          }      /* if passen zusammen */
        }        /* if do_brille */        
        /* Ende des um 30 Stellen einzurueckenden Textes */

                    }   /* if Rand 1 passt */
                    t1[3] = t1[3]->next;
                  }     /* while t1[3] */
                }       /* if Randcode 3 gefunden */
                do {
                  zurueck = False;    /* muss Rueckschritt erfolgen? */ 
                  t3[j] = t3[j]->next;   
                  if (!t3[j]) {zurueck = True; j--;}    /* Rueckschritt */ 
                } while (j>2 && zurueck);
              }     /* while j>2 */ 
            }       /* if t1[2] */
          }         /* if codelen3>1 */
          t3[2] = t3[2]->next;
        }           /* while t3[2] */
      }             /* if 2 Raender */
      t3[1] = t3[1]->next;
    }               /* while t3[1] */
  }                 /* if Genus passt */      
  /* Ende des um 16 Stellen einzurueckenden Textes */

                }  /* if */
                t2[3]=t2[3]->next;
              }    /* while t2[3] */
              t2[2]=t2[2]->next;
            }      /* while t2[2] */
          }        /* if */
          t2[1]=t2[1]->next;
        }          /* while t2[1] */  
        t2[0]=t2[0]->next;
      }            /* while t2[0] */
    }              /* for fl2 */
  }                /* if mgl_rec==3 */

  if ((!recover || (mgl_rec>=41 && mgl_rec<=43)) &&
      ((do_sandwich && !l1_sandwich && !digon_path) || 
       (do_brille && !loop_brille && !digon_brille && !digon_path))) {
  /* ---- Moeglichkeit 4: Einen Patch mit 3 Raendern 
          mit sich selbst verkleben (Text 2 Stellen einruecken) ---- */
  t2[0] = tree[fl];
  while (t2[0] && t2[0]->code+2<g) {t2[0] = t2[0]->next;}
  if (t2[0] && t2[0]->code+2==g) {      /* Genus passt */
    t2[1] = t2[0]->weiter.nextlevel;
    while (t2[1] && t2[1]->code<krit_min) {t2[1] = t2[1]->next;}
    while (t2[1] && t2[1]->code<=krit_max) {   /* kritische Punkte passen */
      t2[2] = t2[1]->weiter.nextlevel;
      while (t2[2] && t2[2]->code<3) {t2[2] = t2[2]->next;}
      if (t2[2] && t2[2]->code==3 &&      /* drei Raender */
         (!recover || t2[1]->code==krit1_rec)) {
        t2[2] = t2[2]->weiter.nextlevel->weiter.nextlevel;
        while (t2[2] && t2[2]->code<=9) {   /* Rand hat <=4 Bruchkanten */
          codelen1 = t2[2]->code - 5;
          t1[0] = t2[2]->weiter.nextlevel;
          /* t1[0] willkuerlich gewaehlt */
          while (t1[0] && t1[0]->code<=10) {  /* Rand 1+2 <= 5 Bruchkanten */
            codelen2 = t1[0]->code - t2[2]->code;
            t1[1] = t1[0]->weiter.nextlevel;
            while (t1[1] && t1[1]->code<11) {t1[1] = t1[1]->next;}
            if (t1[1] && t1[1]->code==11) {   /* Rand 1-3 == 6 Bruchkanten */
              codelen3 = 6-codelen1-codelen2;
              t1[3] = t1[1]->weiter.nextlevel;   /* erster Randcodeeintrag */
              j = 3;                      /* aktueller Level (3-9) */
              while (t1[3]) {             /* es kommen noch Patches im Baum */
                while (j-3<codelen1) {    /* Randcode 1 ermitteln */
                  code1[j-3] = t1[j]->code;
                  j++;
                  if (j-3<codelen1) {t1[j] = t1[j-1]->weiter.nextlevel;}
                  else              {t2[3] = t1[j-1]->weiter.nextlevel;}
                }
                while (j-3<codelen1+codelen2) {  /* Code 2 */
                  code2[j-3-codelen1] = t2[j-codelen1]->code;
                  j++;
                  if (j-3-codelen1<codelen2) 
                       {t2[j-codelen1] = t2[j-codelen1-1]->weiter.nextlevel;}
                  else {t3[3] = t2[j-codelen1-1]->weiter.nextlevel;}
                }
                while (j<9) {                    /* Code 3 */
                  code3[j-3-codelen1-codelen2] = t3[j-codelen1-codelen2]->code;
                  j++;
                  if (j<9) {t3[j-codelen1-codelen2] = 
                            t3[j-codelen1-codelen2-1]->weiter.nextlevel;}
                }
                /* nun stehen alle 3 Codes fest */
                if (code1[0]!=BB_KENNUNG && code2[0]!=BB_KENNUNG &&
                    code3[0]!=BB_KENNUNG) {      /* kein BB-Code */
                  /* Alle Moeglichkeiten fuer den Hauptrand durchgehen: */
                  if (!recover || mgl_rec==41)
                     {bruchkanten_moeglichkeit4(1,2,3,n,g,code1,codelen1,code2,
                      codelen2,code3,codelen3,
                      t3[2+codelen3]->weiter.firstpatch,t2[1]->code,41);}
                  if (!recover || mgl_rec==42)
                     {bruchkanten_moeglichkeit4(1,3,2,n,g,code1,codelen1,code3,
                      codelen3,code2,codelen2,
                      t3[2+codelen3]->weiter.firstpatch,t2[1]->code,42);}
                  if (!recover || mgl_rec==43)
                     {bruchkanten_moeglichkeit4(2,3,1,n,g,code2,codelen2,code3,
                      codelen3,code1,codelen1,
                      t3[2+codelen3]->weiter.firstpatch,t2[1]->code,43);}
                }
                /* naechste Patchliste ansteuern: */
                j--;
                do {
                  zurueck = False;    /* muss Rueckschritt erfolgen? */ 
                  t3[j-codelen1-codelen2] = t3[j-codelen1-codelen2]->next;
                  if (!t3[j-codelen1-codelen2]) {zurueck = True; j--;} 
                } while (zurueck && j>2+codelen1+codelen2);
                if (zurueck) {        /* Rueckschritt bis in Rand 2 */
                  do {
                    zurueck = False;
                    t2[j-codelen1] = t2[j-codelen1]->next;
                    if (!t2[j-codelen1]) {zurueck = True; j--;}
                  } while (zurueck && j>2+codelen1);
                  if (zurueck) {      /* Rueckschritt bis in Rand 1 */
                    do {
                      zurueck = False;
                      t1[j] = t1[j]->next;
                      if (!t1[j]) {zurueck = True; j--;}
                    } while (zurueck && j>2);
                  }
                }    /* im naechsten Schleifendurchlauf ab j neu auffuellen */
              }        /* while t1[3] */
            }        /* if t1[1] */
            t1[0] = t1[0]->next;
          }          /* while t1[0] */
          t2[2] = t2[2]->next;    
        }            /* while t2[2] */
      }        /* if t2[2] */
      t2[1] = t2[1]->next;
    }          /* while t2[1] */
  }            /* if t2[0] */
  /* Ende des um 2 Stellen eingerueckten Textes */
  }            /* if (mgl_rec==4) */

  /* ---- Moeglichkeit 5: Einen Patch mit einem Rand 
          mit sich selbst verkleben ---- */
  if (!do_sandwich || l1_sandwich || digon_path ||
     (recover && (pfadtyp_rec!=2 || mgl_rec<51 || mgl_rec>54))) {return;} 
     /* nur fuer Sandwiches ohne Zweieck */
  t2[0] = tree[fl];
  while (t2[0] && t2[0]->code+1<g) {t2[0] = t2[0]->next;}
  if (t2[0] && t2[0]->code+1==g) {      /* Genus passt */
    t2[1] = t2[0]->weiter.nextlevel;
    while (t2[1] && t2[1]->code<krit_min) {t2[1] = t2[1]->next;}
    while (t2[1] && t2[1]->code<=krit_max) {   /* kritische Punkte passen */
      t2[2] = t2[1]->weiter.nextlevel;
      if (t2[2] && t2[2]->code==1 &&         /* ein Rand */
         (!recover || t2[1]->code==krit1_rec)) {
        t2[2] = t2[2]->weiter.nextlevel->weiter.nextlevel;
        while (t2[2] && t2[2]->code<9) {t2[2] = t2[2]->next;}
        if (t2[2] && t2[2]->code==9) {     /* Rand hat genau 6 Bruchkanten */
          t2[3] = t2[2]->weiter.nextlevel;        /* erster Randcodeeintrag */
          j = 3;                           /* aktueller Level (3-9) */
          while (t2[3]) {                  /* es kommen noch Patches im Baum */
            while (j<9) {                  /* Randcode ermitteln */
              code2[j-3] = t2[j]->code;
              j++;
              if (j<9) {t2[j] = t2[j-1]->weiter.nextlevel;}
            }
            /* Im folgenden jeweils erste Bedingung, damit l1<=l3
               (so dass nicht Bild und Spiegelbild genommen werden) */ 
            if ((!recover || mgl_rec==51) &&
                code2[1]<=code2[5] && code2[2]==0 && code2[4]==0 &&
                code2[0]==code2[1]+code2[3]+code2[5]+3)   /* Fall 1 */
               {sandwich_moeglichkeit5(1,n,g,code2,
                t2[8]->weiter.firstpatch,t2[1]->code,51);}
            if ((!recover || mgl_rec==52) &&
                code2[1]<=code2[4] && code2[3]==0 && code2[5]==0 &&
                code2[0]==code2[1]+code2[2]+code2[4]+2)   /* Fall 2 */
               {sandwich_moeglichkeit5(2,n,g,code2,
                t2[8]->weiter.firstpatch,t2[1]->code,52);}
            if ((!recover || mgl_rec==53) &&
                code2[2]<code2[5] && code2[1]==0 && code2[3]==0 &&
                code2[0]==code2[2]+code2[4]+code2[5]+2)   /* Fall 3 */
               {sandwich_moeglichkeit5(3,n,g,code2,
                t2[8]->weiter.firstpatch,t2[1]->code,53);}
               /* Wichtig: code2[2] echt kleiner code2[5], da sonst l1==l3+1 */
            if ((!recover || mgl_rec==54) &&
                code2[2]<=code2[4] && code2[1]==0 && code2[5]==0 &&
                code2[0]==code2[2]+code2[3]+code2[4]+1)   /* Fall 4 */
               {sandwich_moeglichkeit5(4,n,g,code2,
                t2[8]->weiter.firstpatch,t2[1]->code,54);}
            /* naechste Patchliste ansteuern: */
            j--;
            do {
              zurueck = False;    /* muss Rueckschritt erfolgen? */ 
              t2[j] = t2[j]->next;
              if (t2[j]==nil) {zurueck = True; j--;} 
            } while (zurueck && j>2);      /* ab j neu auffuellen */
          }        /* while t2[3] */
        }        /* if t2[2] */
      }        /* if ein Rand */
      t2[1] = t2[1]->next;
    }     /* while t2[1] */
  }       /* if t2[0] */
}
  
/***********BILDE_GRAPHEN_AUS_BRUCHKANTENPATCHES1_IN_REKURSION**************/
/*  Bildet Graphen aus 2-3 Bruchkantenpatches, einer davon ist "e2". "e2" 
    besitzt genau einen Rand. Dieser Rand enthaelt Bruchkanten. Wenn
    "hauptpatch" den Wert "True" besitzt, so kann "e2" vom Randcode her
    Hauptpatch sein. Dasselbe gilt fuer "nebenpatch". "e2" ist immer der
    groessere der beiden Nebenpatches. "e2" hat
    Geschlecht "g2", "krit2" kritische Punkte und "fl2" Flaechen sowie den
    Bordercode "code". Die 
    resultierenden Graphen besitzen "n" Knoten und Geschlecht "g".
    Weitere Kommentare siehe "bilde_graphen_aus_bauchbindenpatches".       */
/*  Wenn "e2" der Hauptpatch ist, so stimmen die Bezeichnungen "e2", "codelen2"
    usw. nicht mit denen in der Funktion "bilde_graphen_aus_bruchkantenpatches"
    ueberein, denn dort bezeichnet "e3" usw. den Hauptpatch.               */
  
void bilde_graphen_aus_bruchkantenpatches1_in_rekursion(KNOTENTYP g,
  KNOTENTYP n,
  KNOTENTYP g2,KNOTENTYP krit2,KNOTENTYP fl2,ELEM *e2,KNOTENTYP *code,
  BOOL hauptpatch,BOOL nebenpatch,POSTYP his_anz) {
  static KNOTENTYP fl1,fl3;  /* Flaechenzahlen der beteiligten Patches */
  static KNOTENTYP g1,g3;     /* Geni der beteiligten Patches */
  static KNOTENTYP krit1,krit3;   /* kritische Punkte in den Patches */
  static KNOTENTYP fl;           /* Anzahl Flaechen im erzeugten Graphen */
  static TREENODE *t1[9],*t2[9],*t3[9];
         /* fuer jeden Patch und jede benoetigte Baumtiefe ein Zeiger, so dass
            Rueckspruenge moeglich sind (nicht immer werden die Elemente tx[y]
            nur fuer Patch x benutzt) */
  static TREENODE *t3e; /* Zeiger fuer Patch 3 (je nach Laenge des Randcodes
                           ist t3e gleich t3[i] fuer ein i) */
  static ELEM *e1,*e3;       /* Zeiger auf die beteiligten Patches */  
  static KANTE *gk1[2], *gk2[2], *gk3[2];
         /* Arrays koennen so klein sein, da jeweils <=2 Raender im Patch */
  static KNOTENTYP code1[8], code2[8], code3[8];  
         /* Randcodes (bei Bedarf zweimal hintereinander) */
  static KNOTENTYP codelen1,codelen2,codelen3; 
         /* Randcodelaengen der einzelnen Patches */
  static KNOTENTYP i;      /* Offset in code3, so dass der Code maximal ist */
  static KNOTENTYP j;      /* Zaehlvariable */
  static KNOTENTYP dummyarray[11];   /* nimmt einen Bordercode auf */
         /* groesstmoegliche Laenge:  1 + 4 + 6 fuer Anzahl Raender +
            Randanfangsindices (3 Stueck + Endekennung) + Randcodes */ 
  static KNOTENTYP len;    /* Laenge des mittleren Nahtteils (Brille) */
  static KNOTENTYP len2;   /* Laenge von Nahtteil 2 (Verknuepfung von Patch 1
                              und Patch 2) (Sandwich) */
  static unsigned char fall;  /* "fall" gibt an, welcher der Faelle 1-4 bzw. 
                                 1-8 beim Verknuepfen angewendet werden muss */
  static KNOTENTYP k;      /* Anzahl der Winkel in Nahtteil 2 (aus
                              dieser errechnet sich der Wert von "len2") */
  static unsigned char aend;  /* Erklaerung siehe "suche_randcode" */
  static KNOTENTYP len12, len23;   /* Laengen der Nahtteile 1 und 2 bzw.
                                      2 und 3 zusammen (Sandwich) */
  static KANTENARRAY patchmap1,patchmap2,patchmap3;
  static BOOL zurueck;
  static POSTYP start,arraypos;
  static char iso;     /* gibt bei bestimmten Faellen an, ob zwei Raender
                          isomorph sind (1 = ja, 0 = nein, -1 = unbestimmt) */
  static BOOL gleiche_randcodes;    /* gibt bei bestimmten Faellen an, ob
                                       zwei Randcodes gleich sind */ 
  static KNOTENTYP connfl;
  static POSTYP ii,erg,l;     /* "l" siehe "setze_history_weiter" */
  static BOOL wh;          /* True => Schleife wird mehrfach durchlaufen */

  erg = his_anz;
  pco = patchcheck && !overflow[his_anz-1];
  fl = (n>>1)+2-(g<<1);
  codelen2 = code[2]-code[1];
  memcpy(code2,&code[3],sizeof(KNOTENTYP)*codelen2);
  memcpy(&code2[codelen2],code2,sizeof(KNOTENTYP)*codelen2);
        /* nun enthaelt "code2" zweimal hintereinander den Randcode von "e2" */

  /* ---- Moeglichkeit 1.1:  3 Patches, "e2" ist Nebenpatch ---- */
  if ((!recover || mgl_rec==1) &&
      nebenpatch && fl2+2<=fl && g2<=g && krit2<=krit_max) {
    /* nun Patch 1 zuordnen: */
    for (fl1 = recover ? fln1_rec : 1; fl1<=fl-fl2-1; fl1++) { 
      /* Patch 1 aussuchen (wie bei Patch 2) */
      /* Patch 1 ist kleiner als Patch 2 im ueblichen Sinne (aber evtl. mit 
         kritischen Punkten als erstes Kriterium, sofern alt==False), 
         was innerhalb der Rekursion automatisch sichergestellt ist, deshalb 
         auf keinen Fall
         MIN(fl2,fl-fl2-1) bilden, denn Patch 1 braucht nicht weniger Flaechen
         zu haben als Patch 2 (falls alt==False)! Falls "loop_brille==True",
         so wird als "e1" nur das Eineck akzeptiert, sofern nicht auch
         Sandwichkarten erzeugt werden sollen. */
      fl3 = fl-fl1-fl2;
      t1[0] = tree[fl1];
      while (t1[0] && (g1 = t1[0]->code)+g2 <= g) {
        t1[1] = t1[0]->weiter.nextlevel;  
        while (t1[1] && (krit1 = t1[1]->code)+krit2 <= krit_max) {
          t1[2] = t1[1]->weiter.nextlevel;
          if (t1[2] && t1[2]->code==1 &&    /* ein Rand */
             (!recover || (g1==g1_rec && krit1==krit1_rec)) &&
             ((do_sandwich && !l1_sandwich && !digon_path) || 
              (do_brille && !loop_brille && !digon_brille && !digon_path) || 
              (fl1==1 && g1==0))) {
            t1[2] = t1[2]->weiter.nextlevel->weiter.nextlevel;  
            /* vgl. Bauchbinde */
            while (t1[2] && t1[2]->code<=5) {  /* Rand hat <=2 Bruchkanten */
              codelen1 = t1[2]->code - 3; 
              t1[3] = t1[2]->weiter.nextlevel;     /* erster Randcodeeintrag */
              while (t1[3]) {                  /* Patchliste 1 steht fest */
                code1[0] = t1[3]->code; 
                if (codelen1==2) {t1[4] = t1[3]->weiter.nextlevel; 
                                  code1[1] = t1[4]->code;}
                if ((codelen1==1 || (code1[0]!=BB_KENNUNG && code1[1]==0)) &&
                    ((do_sandwich && !l1_sandwich && !digon_path) || 
                    (do_brille && !loop_brille && !digon_brille && !digon_path)
                    || (codelen1<=2-(KNOTENTYP)(loop_brille && !do_sandwich)
                    && code1[0]==0))) {       /* Patches gefunden */

  /* nun Patch 3 zuordnen (Text 16 Stellen einruecken): */
  t3[0] = tree[fl3];
  while (t3[0] && g1+g2+(g3 = t3[0]->code)<g) {t3[0] = t3[0]->next;}
  if (t3[0] && g1+g2+g3==g) {    /* Genus passt */
    t3[1] = t3[0]->weiter.nextlevel;
    while (t3[1] && krit1+krit2+(krit3 = t3[1]->code)<krit_min) 
          {t3[1] = t3[1]->next;}
    while (t3[1] && krit1+krit2+(krit3 = t3[1]->code)<=krit_max) { 
      /* kritische Punkte im Intervall */        
      t3[2] = t3[1]->weiter.nextlevel;
      if (t3[2] && t3[2]->code==1 &&    /* ein Rand */
         (!recover || krit3==krit3_rec)) {
        t3[2] = t3[2]->weiter.nextlevel->weiter.nextlevel;  /*vgl. Bauchbinde*/
        while (t3[2] && t3[2]->code<9-codelen1-codelen2)
              {t3[2] = t3[2]->next;}
        if (t3[2] && codelen1+codelen2+(codelen3 = t3[2]->code-3)==6) {
          /* Randlaenge passt */ 

          if (do_sandwich && ((!l1_sandwich && !digon_path) || 
             (g1==0 && fl1==1 && codelen1==2 && code1[0]==0)) && 
             (len12 = (code1[0]<<1)+codelen1)>1 &&
             (len23 = (code2[0]<<1)+codelen2)>1 &&
             (!recover || (submgl_rec==1 && len12==l1_rec && len23==l3_rec))) {
            t3[3] = t3[2]->weiter.nextlevel;       /* erster Randcodeeintrag */
            t3[4] = nil;  k = 0;
            len2 = MIN(len23,len12);
            len2 -= (1+(len2&1));   /* groesstmoegliche Laenge fuer Naht 2 */
              /* len2 ist immer ungerade => man kann ausrechnen, ob len1 und 
                 len3 (immer) gerade oder ungerade sind: len12 ist ungerade,
                 wenn codelen1==1. len1 ist dann, da len2 ungerade ist, 
                 gerade. Entsprechend fuer len3. */
            fall = 4 + codelen2 - (codelen1<<1);       /* Faelle 1-4 */
            if (t3[3]) {        
              bereite_sandwichcodes_vor(fall,len12-len2,len23-len2,code3,
                                        &aend,&i);
              /* Patches mit passenden Randcodes suchen:  (beachte:
                 nach dem Aufruf der Funktion "suche_randcode" sind nur 
                 noch die Eintraege code3[i] bis code3[i+codelen3-1] 
                 korrekt) */
              while (t3e = suche_randcode(&code3[i],codelen3,aend,&t3[3],&k)) {
                /* Patch 3 gefunden */ 
                len2 = MIN(len23,len12);
                len2 -= (1+(len2&1));    /* groesste Laenge fuer Naht 2 */ 
                if (len2 > (k<<1) &&      /* k ist klein genug */
                   (!recover || len2-(k<<1)==l2_rec)) {
                  len2 -= (k<<1);        /* aktuelle Laenge von Nahtteil 2 */
                  l = 1;
                  if (pco) {
                    for (ii=0; ii<his_anz; ii++) {his_check_pos[ii] = 0;}
                    starte_history(his_anz);
                  }
                  nebenzweig[0] = 0L;
                  do {
                    e1 = t1[2+codelen1]->weiter.firstpatch;  wh = False;
                    while (e1) {    
                      e3 = t3e->weiter.firstpatch;
                      while (e3) {
                        start = 0;  connfl = 0;  arraypos = 0;
                        if (wh || pco) 
                           /* direkt konstruieren, da kein Fehler moeglich */
                           {konstruiere_patch(patchmap2,&start,dummyarray,e2,
                            gk2,nil,&connfl,&arraypos);}
                        else {
                          erg = konstruiere_patch_in_rekursion(patchmap2,
                                &start,dummyarray,e2,gk2,l-1,his_anz,
                                his_anz-1,&connfl);
                        }
                        if (erg==his_anz) {    /* Konstruktion hat geklappt */
                          wh = True;
                          if (!recover && 
                             (!facerestrict || flaechenzahlen3_ok(e1,e2,e3))) {
                            start = 0;  arraypos = 0;
                            konstruiere_patch(patchmap1,&start,dummyarray,
                                              e1,gk1,nil,&connfl,&arraypos);
                            start = 0;  arraypos = 0;
                            konstruiere_patch(patchmap3,&start,dummyarray,
                                              e3,gk3,nil,&connfl,&arraypos);
                            bestimme_gute_basen(e1);
                            bestimme_gute_basen(e2);
                            bestimme_gute_basen(e3);
                            graphenzahl[ARRAYPOS_LN(g,n,2)]++;
                            gk3[0] = verknuepfe_sandwichpatches(gk1[0],gk2[0],
                                     gk3[0],len12-len2,len2,len23-len2,
                                     &code3[i],i ? 1+(fall>2) : 0,fall);
                            sandwich_minimalitaetstest(gk3[0]->next,
                              True,n,g,e1,e2,e3,fall>2,1,False,0);
                          }
                        }
                        else {e1 = nil;  e3 = nil;}  /* Ende, da e2 schlecht */
                        if (e3) {e3 = e3->next;}
                        if (!recover && (save_flag || save_flag2)) 
                           {speichere_graphen_aus_outputliste_in_files(his_anz,
                            0,1,1,len12,len2,len23,fl1,0,n,g1,0,g,krit1,0,
                            krit3);}
                        if (recover && nebenzweig[0]==recovernebenzweig[0]) 
                           {recover = False;   count = recovercount;}
                        nebenzweig[0]++;
                        if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
                      }   /* while e3 */ 
                      if (e1) {e1 = e1->next;}  /* Patches aus gleicher Liste
                         2mal verknuepfen, da "e3" Hauptpatch und "e1"
                         Nebenpatch ist */
                    }    /* while e1 */
                  } while (l = setze_history_weiter(his_anz,MIN(erg,his_anz-1),
                                                    pco));
                }     /* if len2>k*2 */
              }      /* while t3e */
            }       /* if t3[3] */
          }        /* if do_sandwich */

          if (do_brille && ((!loop_brille && !digon_brille && !digon_path) ||
             (g1==0 && fl1==1 && codelen1<=1+(KNOTENTYP)(digon_brille) && 
             code1[0]==0)) && (!recover || (submgl_rec==2 && 
             (code1[0]<<1)+codelen1==l1_rec && 
             (code2[0]<<1)+codelen2==l3_rec))) { 
            t3[3] = t3[2]->weiter.nextlevel;       /* erster Randcodeeintrag */
            t3[4] = nil;  k = 0;
            fall = 7 - (codelen1<<1) - codelen2;   /* zunaechst Faelle 1-4 */
            while (t3[3]) {        
              bereite_brillencodes_vor(fall,code1,code2,code3,&aend,&i,
                                       1+(fall>4));
              /* Patches mit passenden Randcodes suchen:  (beachte:
                 nach dem Aufruf der Funktion "suche_randcode" sind nur 
                 noch die Eintraege code3[i] bis code3[i+codelen3-1] 
                 korrekt) */
              while (t3e = suche_randcode(&code3[i],codelen3,aend,&t3[3],&k)) {
                /* Patch 3 gefunden */ 
                len = (k<<1)+(fall<5);
                if (!recover || len==l2_rec) {
                  l = 1;
                  if (pco) {
                    for (ii=0; ii<his_anz; ii++) {his_check_pos[ii] = 0;}
                    starte_history(his_anz);
                  }
                  nebenzweig[0] = 0L;
                  do {
                    e1 = t1[2+codelen1]->weiter.firstpatch;  wh = False;
                    while (e1) {    
                      e3 = t3e->weiter.firstpatch;
                      while (e3) {
                        start = 0;  connfl = 0;  arraypos = 0;
                        if (wh || pco) 
                           /* direkt konstruieren, da kein Fehler moeglich */
                           {konstruiere_patch(patchmap2,&start,dummyarray,e2,
                            gk2,nil,&connfl,&arraypos);}
                        else {
                          erg = konstruiere_patch_in_rekursion(patchmap2,
                                &start,dummyarray,e2,gk2,l-1,his_anz,
                                his_anz-1,&connfl);
                        }
                        if (erg==his_anz) {    /* Konstruktion hat geklappt */
                          wh = True;
                          if (!recover &&
                             (!facerestrict || flaechenzahlen3_ok(e1,e2,e3))) {
                            start = 0;  arraypos = 0;
                            konstruiere_patch(patchmap1,&start,dummyarray,
                                              e1,gk1,nil,&connfl,&arraypos);
                            start = 0;  arraypos = 0;
                            konstruiere_patch(patchmap3,&start,dummyarray,
                                              e3,gk3,nil,&connfl,&arraypos);
                            bestimme_gute_basen(e1);
                            bestimme_gute_basen(e2);
                            bestimme_gute_basen(e3);
                            graphenzahl[ARRAYPOS_LN(g,n,3)]++;
                            gk3[0] = verknuepfe_brillenpatches(gk1[0],gk2[0],
                                     gk3[0],(code1[0]<<1)+codelen1,
                                     (code2[0]<<1)+codelen2,len,&code3[i],
                                     i ? 3-codelen1 : 0,fall);
                            brillen_minimalitaetstest(gk3[0],
                              True,n,g,e1,e2,e3,1,0);
                          }
                        }
                        else {e1 = nil;  e3 = nil;}  /* Ende, da e2 schlecht */
                        if (e3) {e3 = e3->next;}
                        if (!recover && (save_flag || save_flag2)) 
                           {speichere_graphen_aus_outputliste_in_files(his_anz,
                            0,1,2,(code1[0]<<1)+codelen1,len,(code2[0]<<1)+
                            codelen2,fl1,0,n,g1,0,g,krit1,0,krit3);}
                        if (recover && nebenzweig[0]==recovernebenzweig[0]) 
                           {recover = False;   count = recovercount;}
                        nebenzweig[0]++;
                        if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
                      }   /* while e3 */ 
                      if (e1) {e1 = e1->next;}  /* Patches aus gleicher Liste
                                               2mal verknuepfen (siehe oben) */
                    }    /* while e1 */
                  } while (l = setze_history_weiter(his_anz,MIN(erg,his_anz-1),
                                                    pco));
                }    /* if */
              }      /* while t3e */
              if (fall<5)   /* Faelle 5-8 starten (k ist mindestens 1) */
    	         {fall += 4;  t3[3] = t3[2]->weiter.nextlevel;  t3[4] = nil; 
                  k = 1;}
              else {t3[3] = nil;}
            }       /* while t3[3] */
          }        /* if do_brille */

        }        /* if richtige Codelaenge */
      }         /* if ein Rand */
      t3[1] = t3[1]->next;
    }      /* while kritische Punkte */
  }       /* if Genus passt */
  /* Ende des um 16 Stellen eingerueckten Textes */

                }  /* if */
                t1[3]=t1[3]->next;
              }    /* while t1[3] */
              t1[2]=t1[2]->next;
            }      /* while t1[2] */
          }        /* if */
          t1[1]=t1[1]->next;
        }          /* while t1[1] */  
        t1[0]=t1[0]->next;
      }            /* while t1[0] */
    }              /* for fl1 */
  }           /* if Patch e2 passt */

  
  /* ---- Moeglichkeit 1.2:  3 Patches, "e2" ist Hauptpatch ---- */
  if ((!recover || mgl_rec==12) && 
      hauptpatch && fl2+2<=fl && g2<=g && krit2<=krit_max) {
    /* Patch 3 heraussuchen: */
    for (fl3 = recover ? fln1_rec : ((fl-fl2-1)>>1)+1; fl3+fl2<fl; fl3++) {
      t2[0] = tree[fl3];
      fl1 = fl-fl2-fl3;                               /* fl1 <= fl3 */
      while (t2[0] && g2+(g3 = t2[0]->code) <= g) {   /* erster Level: Genus */
        t2[1] = t2[0]->weiter.nextlevel;  
        while (t2[1] && krit2+(krit3 = t2[1]->code) <= krit_max) { 
          /* zweiter Level */
          t2[2] = t2[1]->weiter.nextlevel;
          if (t2[2] && t2[2]->code==1 &&     /* ein Rand */
             (!recover || (g3==g1_rec && krit3==krit3_rec))) { 
            t2[2] = t2[2]->weiter.nextlevel->weiter.nextlevel;   
            /* vgl. Bauchbinde */
            while (t2[2] && t2[2]->code<=5) {  /* Rand hat <=2 Bruchkanten */
              codelen3 = t2[2]->code - 3; 
              t2[3] = t2[2]->weiter.nextlevel;    /* erster Randcodeeintrag */
              while (t2[3]) {                  /* Patchliste 2 steht fest */
                code3[0] = t2[3]->code; 
                if (codelen3==2) {t2[4] = t2[3]->weiter.nextlevel; 
                                  code3[1] = t2[4]->code;}
                if (codelen3==1 || (code3[0]!=BB_KENNUNG && code3[1]==0)) {
                   /* Patches gefunden */

      /* nun Patch 1 zuordnen (Text 12 Stellen einruecken): */
      /* Patch 1 muss kleiner sein als Patch 3 im ueblichen Sinne */
      t1[0] = tree[fl1];
      while (t1[0] && (g1 = t1[0]->code)+g2+g3<g && t1[0]!=t2[0]) 
            {t1[0] = t1[0]->next;}  /* 3.Bedingung: Patch 1 ueberholt nicht
                                       Patch 3 (Reihenfolge der Bedingungen
                                       wichtig, damit "g1" festgelegt wird) */
      if (t1[0] && g1+g2+g3==g) {   /* Genus passt */
        t1[1] = t1[0]->weiter.nextlevel;  
        while (t1[1] && (krit1 = t1[1]->code)+krit2+krit3 < krit_min && 
               t1[1]!=t2[1]) {t1[1] = t1[1]->next;}
        if (t1[1] && krit1+krit2+krit3>=krit_min) {
          while (t1[1] && (krit1 = t1[1]->code)+krit2+krit3<=krit_max) {   
            t1[2] = t1[1]->weiter.nextlevel;
            if (t1[2] && t1[2]->code==1 &&    /* ein Rand */
               (!recover || krit1==krit1_rec) &&
               ((do_sandwich && !l1_sandwich && !digon_path) || 
                (do_brille && !loop_brille && !digon_brille && !digon_path) || 
                (g1==0 && fl1==1))) {
              t1[2] = t1[2]->weiter.nextlevel->weiter.nextlevel;  
              /* vgl. Bauchbinde */
              while (t1[2] && t1[2]->code<=5) {  /* Rand hat <=2 Bruchkanten */
                codelen1 = t1[2]->code - 3; 
                if (codelen1+codelen2+codelen3==6) {   /* Laengen passen */
                  t1[3] = t1[2]->weiter.nextlevel;     
                  /* erster Randcodeeintrag */
                  while (t1[3]) {                 /* Patchliste 1 steht fest */
                    code1[0] = t1[3]->code; 
                    if (codelen1==2) {t1[4] = t1[3]->weiter.nextlevel; 
                                      code1[1] = t1[4]->code;}
                    if ((codelen1==1 || (code1[0]!=BB_KENNUNG && code1[1]==0))
                        && ((do_sandwich && !l1_sandwich && !digon_path) || 
                        (do_brille && !loop_brille && !digon_brille && 
                        !digon_path) || 
                        (codelen1<=2-(KNOTENTYP)(loop_brille && !do_sandwich)
                        && code1[0]==0))) {     /* Patches gefunden */
  
            /* Text 22 Stellen einruecken): */
            if (do_sandwich && ((!l1_sandwich && !digon_path) || 
               (g1==0 && fl1==1 && codelen1==2 && code1[0]==0)) && 
               (len12 = (code1[0]<<1)+codelen1)>1 &&
               (len23 = (code3[0]<<1)+codelen3)>1 &&
               (!recover || (submgl_rec==1 && len12==l1_rec && len23==l3_rec))
               && (fall = passen_sandwichcodes(code1,codelen1,
                          code3,codelen3,code2,codelen2,&i,&k))) {
              /* Codes passen */
              len2 = (k<<1)+1;
              if (!recover || len2==l2_rec) {
                l = 1;
                if (pco) {
                  for (ii=0; ii<his_anz; ii++) {his_check_pos[ii] = 0;}
                  starte_history(his_anz);
                }
                nebenzweig[0] = 0L;
                do {
                  e1 = t1[2+codelen1]->weiter.firstpatch;   wh = False;
                  while (e1) {    
                    e3 = t2[2+codelen3]->weiter.firstpatch;
                    while (e3) {
                      start = 0;  connfl = 0;  arraypos = 0;
                      if (wh || pco) 
                         /* direkt konstruieren, da kein Fehler moeglich */
                         {konstruiere_patch(patchmap2,&start,dummyarray,e2,
                          gk2,nil,&connfl,&arraypos);}
                      else {
                        erg = konstruiere_patch_in_rekursion(patchmap2,
                              &start,dummyarray,e2,gk2,l-1,his_anz,
                              his_anz-1,&connfl);
                      }
                      if (erg==his_anz) {    /* Konstruktion hat geklappt */
                        wh = True;
                        if (!recover && 
                           (!facerestrict || flaechenzahlen3_ok(e1,e2,e3))) {
                          start = 0;  arraypos = 0;
                          konstruiere_patch(patchmap1,&start,dummyarray,
                                            e1,gk1,nil,&connfl,&arraypos);
                          start = 0;  arraypos = 0;
                          konstruiere_patch(patchmap3,&start,dummyarray,
                                            e3,gk3,nil,&connfl,&arraypos);
                          bestimme_gute_basen(e1);
                          bestimme_gute_basen(e2);
                          bestimme_gute_basen(e3);
                          graphenzahl[ARRAYPOS_LN(g,n,2)]++;
                          gk3[0] = verknuepfe_sandwichpatches(gk1[0],gk3[0],
                                   gk2[0],len12-len2,len2,len23-len2,&code2[0],
                                   i,fall);
                          sandwich_minimalitaetstest(gk3[0]->next,
                            t1[2+codelen1]!=t2[2+codelen3],n,g,e1,e3,e2,fall>2,
                            1,False,0);
                        }
                      }
                      else {e1 = nil;  e3 = nil;} 
                           /* beenden, da "e2" schlecht */
                      if (e3) {e3 = e3->next;}
                      if (!recover && (save_flag || save_flag2)) 
                         {speichere_graphen_aus_outputliste_in_files(his_anz,
                          0,12,1,len12,len2,len23,fl3,0,n,g3,0,g,krit1,0,
                          krit3);}
                      if (recover && nebenzweig[0]==recovernebenzweig[0]) 
                         {recover = False;   count = recovercount;}
                      nebenzweig[0]++;
                      if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
                    }   /* while e3 */ 
                    if (e1) {e1 = e1->next;} /* Patches aus gleicher Liste 2mal
                                                verknuepfen (siehe oben) */
                  }    /* while e1 */
                } while (l = setze_history_weiter(his_anz,MIN(erg,his_anz-1),
                                                  pco));
              }       /* if */
            }       /* if passen Sandwichcodes */
  
            if (do_brille && ((!loop_brille && !digon_brille && !digon_path) ||
               (g1==0 && fl1==1 && codelen1<=1+(KNOTENTYP)(digon_brille) && 
               code1[0]==0)) && (!recover || (submgl_rec==2 &&  
               (code1[0]<<1)+codelen1==l1_rec && 
               (code3[0]<<1)+codelen3==l3_rec)) && 
               (fall = passen_brillencodes(code1,codelen1,code3,
                codelen3,code2,codelen2,&i,&k))) {  /* Codes passen zusammen */
              len = (k<<1) + (fall<5);
              if (!recover || len==l2_rec) {
                l = 1;
                if (pco) {
                  for (ii=0; ii<his_anz; ii++) {his_check_pos[ii] = 0;}
                  starte_history(his_anz);
                }
                nebenzweig[0] = 0L;
                do {
                  e1 = t1[2+codelen1]->weiter.firstpatch;   wh = False;
                  while (e1) {    
                    e3 = t2[2+codelen3]->weiter.firstpatch;
                    while (e3) {
                      start = 0;  connfl = 0;  arraypos = 0;
                      if (wh || pco) 
                         {konstruiere_patch(patchmap2,&start,dummyarray,e2,
                          gk2,nil,&connfl,&arraypos);}
                      else {
                        erg = konstruiere_patch_in_rekursion(patchmap2,
                              &start,dummyarray,e2,gk2,l-1,his_anz,
                              his_anz-1,&connfl);
                      }
                      if (erg==his_anz) {    /* Konstruktion hat geklappt */
                        wh = True;
                        if (!recover && 
                           (!facerestrict || flaechenzahlen3_ok(e1,e2,e3))) {
                          start = 0;  arraypos = 0;
                          konstruiere_patch(patchmap1,&start,dummyarray,
                                            e1,gk1,nil,&connfl,&arraypos);
                          start = 0;  arraypos = 0;
                          konstruiere_patch(patchmap3,&start,dummyarray,
                                            e3,gk3,nil,&connfl,&arraypos);
                          bestimme_gute_basen(e1);
                          bestimme_gute_basen(e2);
                          bestimme_gute_basen(e3);
                          graphenzahl[ARRAYPOS_LN(g,n,3)]++;
                          gk3[0] = verknuepfe_brillenpatches(gk1[0],gk3[0],
                                   gk2[0],(code1[0]<<1)+codelen1,(code3[0]<<1)+
                                   codelen3,len,&code2[0],i,fall);
                          brillen_minimalitaetstest(gk3[0],
                            t1[2+codelen1]!=t2[2+codelen3],n,g,e1,e3,e2,1,0);
                        }
                      }
                      else {e1 = nil;  e3 = nil;}
                      if (e3) {e3 = e3->next;}
                      if (!recover && (save_flag || save_flag2)) 
                         {speichere_graphen_aus_outputliste_in_files(his_anz,
                          0,12,2,(code1[0]<<1)+codelen1,len,(code3[0]<<1)+
                          codelen3,fl3,0,n,g3,0,g,krit1,0,krit3);}
                      if (recover && nebenzweig[0]==recovernebenzweig[0]) 
                         {recover = False;   count = recovercount;}
                      nebenzweig[0]++;
                      if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
                    }   /* while e3 */ 
                    if (e1) {e1 = e1->next;} /* Patches aus gleicher Liste 2mal
                                                verknuepfen (siehe oben) */
                  }    /* while e1 */
                } while (l = setze_history_weiter(his_anz,MIN(erg,his_anz-1),
                                                  pco));
              }     /* if */
            }       /* if passen Brillencodes */
            /* Ende des um 22 Stellen eingerueckten Textes */
  
                    }  /* if */
                    if (t1[3]==t2[3]) {t1[3]=nil;} else {t1[3]=t1[3]->next;}
                       /* t1 darf t2 nicht "ueberholen" */
                  }    /* while t1[3] */
	        }    /* if */     
                if (t1[2]==t2[2]) {t1[2]=nil;} else {t1[2]=t1[2]->next;}
              }      /* while t1[2] */
            }        /* if */
            if (t1[1]==t2[1]) {t1[1]=nil;} else {t1[1]=t1[1]->next;}
          }          /* while t1[1] */  
        }           /* if t1[1] */
      }            /* if t1[0] */
      /* Ende des um 12 Stellen eingerueckten Textes */

                }  /* if */
                t2[3]=t2[3]->next;
              }    /* while t2[3] */
              t2[2]=t2[2]->next;
            }      /* while t2[2] */
          }        /* if */
          t2[1]=t2[1]->next;
        }          /* while t2[1] */  
        t2[0]=t2[0]->next;
      }            /* while t2[0] */
    }              /* for fl3 */
  }                /* if Patch e2 passt */


  /* ---- Moeglichkeit 2:    2 Patches, "e2" ist Hauptpatch ---- */
  if ((!recover || mgl_rec==2) && !digon_path &&
      ((do_sandwich && !l1_sandwich) || 
       (do_brille && !loop_brille && !digon_brille)) &&
      hauptpatch && fl2+1<=fl && g2<g && krit2<=krit_max) {
    /* Patch 1 heraussuchen (Nebenraender):  Die Raenderinformationen 
       werden so auf t1,t3,codelen1,codelen3 usw. verteilt, als ob es sich um
       2 getrennte Patches handelte. fl3, krit3 und g3 werden nicht belegt. */
    /* Falls "digon_path==False", so wird Bedingung nie erfuellt (im Gegensatz
       zu einigen anderen Stellen, an denen "digon_path" geprueft wird). */
    fl1 = fl-fl2;
    t1[0] = tree[fl1];
    while (t1[0] && (g1 = t1[0]->code)+g2+1 < g) {t1[0] = t1[0]->next;} 
    if (t1[0] && g1+g2+1==g) {                   /* erster Level: Genus */
      t1[1] = t1[0]->weiter.nextlevel;  
      while (t1[1] && (krit1 = t1[1]->code)+krit2 < krit_min) 
            {t1[1] = t1[1]->next;}      /* zweiter Level */
      while (t1[1] && (krit1 = t1[1]->code)+krit2 <= krit_max) { 
        t1[2] = t1[1]->weiter.nextlevel;
        while (t1[2] && t1[2]->code<2) {t1[2] = t1[2]->next;}
        if (t1[2] && t1[2]->code==2 &&           /* zwei Raender */
           (!recover || krit1==krit1_rec)) {
          t1[2] = t1[2]->weiter.nextlevel->weiter.nextlevel;   
          /* vgl. Bauchbinde */
          while (t1[2] && t1[2]->code<=6) {  /* erster Rand <=2 Bruchkanten */
            codelen1 = t1[2]->code - 4; 
            t2[2] = t1[2]->weiter.nextlevel;  
            /* t2[2] ist willkuerlich gewaehlt */
            while (t2[2] && (codelen3=t2[2]->code-t1[2]->code)<=2) { 
              /* 2.Rand <=2 Bruchkanten */
              if (codelen1+codelen2+codelen3==6) {    /* Randlaengen passen */
                t1[3] = t2[2]->weiter.nextlevel;
                while (t1[3]) {
                  code1[0] = t1[3]->code;
                  if (codelen1==2) {t1[4] = t1[3]->weiter.nextlevel; 
                                    code1[1] = t1[4]->code;}
                  if (codelen1==1 || (code1[0]!=BB_KENNUNG && code1[1]==0)) { 
                    /* erster Rand passt */
                    t2[3] = t1[2+codelen1]->weiter.nextlevel;
                    while (t2[3]) {
                      code3[0] = t2[3]->code;
                      if (codelen3==2) {t2[4] = t2[3]->weiter.nextlevel; 
                                        code3[1] = t2[4]->code;}
                      if (codelen3==1 || (code3[0]!=BB_KENNUNG && 
                          code3[1]==0)) {
                         /* dritter Rand passt */
                         /* kein Schleifendurchlauf fuer t2[4] erforderlich,
                            da Codeeintrag sowieso =0 sein soll (also wenn, 
                            dann immer nur erster Zweig interessant) */
                      
	  /* Text 14 Stellen einruecken: */
          if (do_sandwich && !l1_sandwich && (!recover || (submgl_rec==1 && 
             (code1[0]<<1)+codelen1==l1_rec && 
             (code3[0]<<1)+codelen3==l3_rec)) &&
             (fall = passen_sandwichcodes(code1,codelen1,code3,
              codelen3,code2,codelen2,&i,&k))) {    /* Codes passen zusammen */
            len12 = (code1[0]<<1)+codelen1;
            len23 = (code3[0]<<1)+codelen3;
            len2 = (k<<1)+1;
            if (fall==4) {fprintf(stderr,"Logischer Fehler in "
                    "bilde_graphen_aus_sandwichpatches1_in_rekursion: fall 4 "
                    "in case 2\n"); exit(32);}  
               /* zweiter Randcode kann nicht laenger sein als erster */
            if (!recover || len2==l2_rec) {
              gleiche_randcodes = (len12==len23); /* Raender 1 und 3 gleich? */
                             /* <=> codelen1==codelen3 && code1[0]==code3[0] */
              l = 1;
              if (pco) {
                for (ii=0; ii<his_anz; ii++) {his_check_pos[ii] = 0;}
                starte_history(his_anz);
              }
              nebenzweig[0] = 0L;
              do {    /* Obwohl bei e1 jedesmal die Raender verglichen werden
                         muessen, ist e2 in der aeusseren Schleife, denn e1 ist
                         klein und e2 gross, so dass eine ueberfluessige
                         Konstruktion von e2 schwerer wiegen wuerde. */
                e1 = t2[2+codelen3]->weiter.firstpatch;   wh = False;
                while (e1) {
                  start = 0;  connfl = 0;  arraypos = 0;
                  if (wh || pco) 
                     {konstruiere_patch(patchmap2,&start,dummyarray,e2,
                      gk2,nil,&connfl,&arraypos);}
                  else {
                    erg = konstruiere_patch_in_rekursion(patchmap2,
                          &start,dummyarray,e2,gk2,l-1,his_anz,
                          his_anz-1,&connfl);
                  }
                  if (erg==his_anz) {    /* Konstruktion hat geklappt */
                    wh = True;
                    if (!recover &&
                       (!facerestrict || flaechenzahlen3_ok(e1,e2,nil))) {
                      start = 0;  arraypos = 0;
                      konstruiere_patch(patchmap1,&start,dummyarray,
                                        e1,gk1,nil,&connfl,&arraypos);
                      iso = gleiche_randcodes ? (char)iso_raender(e1,0,1) : 0;
                      bestimme_gute_basen(e1);
                      bestimme_gute_basen(e2);
                      graphenzahl[ARRAYPOS_LN(g,n,2)]++;
                      gk3[0] = verknuepfe_sandwichpatches(gk1[0],gk1[1],gk2[0],
                               len12-len2,len2,len23-len2,&code2[0],i,fall);
                      /* gk1[0] und gk1[1] duerfen nicht vertauscht werden, 
                         denn gk1[1] spielt die Rolle von Rand 2 */
                      sandwich_minimalitaetstest(gk3[0]->next,
                           !gleiche_randcodes,n,g,e1,e2,nil,fall>2,21,False,0);
                      /* Falls Randcodes von Patch 1 gleich, aber Raender nicht
                         isomorph sind: noch ein Durchgang mit vertauschten
                         Raendern (fall,len12,len23 bleiben erhalten) */
                      if (gleiche_randcodes && iso==0) {
                        start = 0;  connfl = 0;  arraypos = 0;
                        konstruiere_patch(patchmap1,&start,dummyarray,
                                          e1,gk1,nil,&connfl,&arraypos);
                        start = 0;  arraypos = 0;
                        konstruiere_patch(patchmap2,&start,dummyarray,e2,
                                          gk2,nil,&connfl,&arraypos);
                        /* Konstruktion hat schon einmal geklappt, deshalb
                           einfache Konstruktion ohne Tests */
                        graphenzahl[ARRAYPOS_LN(g,n,2)]++;
                        gk3[0] = verknuepfe_sandwichpatches(gk1[1],gk1[0],
                                 gk2[0],len23-len2,len2,len12-len2,&code2[0],i,
                                 fall);
                        /* gk1[0] und gk1[1] duerfen nicht vertauscht werden, 
                           denn gk1[1] spielt hier die Rolle von Rand 1 */
                        sandwich_minimalitaetstest(gk3[0]->next,
                          False,n,g,e1,e2,nil,fall>2,22,False,0);
                      }
                    } 
                  }
                  else {e1 = nil;}  /* Schleife beenden, da "e2" schlecht */
                  if (e1) {e1 = e1->next;} 
                  if (!recover && (save_flag || save_flag2)) 
                     {speichere_graphen_aus_outputliste_in_files(his_anz,
                      0,2,1,len12,len2,len23,0,0,n,0,0,g,krit1,0,0);}
                  if (recover && nebenzweig[0]==recovernebenzweig[0]) 
                     {recover = False;   count = recovercount;}
                  nebenzweig[0]++;
                  if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
                }    /* while e1 */
              } while (l = setze_history_weiter(his_anz,MIN(erg,his_anz-1),
                                                pco));
            }    /* if */
          }      /* if passen Sandwichcodes */

          if (do_brille && !loop_brille && !digon_brille &&
             (!recover || (submgl_rec==2 &&
             (code1[0]<<1)+codelen1==l1_rec && 
             (code3[0]<<1)+codelen3==l3_rec)) && 
             (fall = passen_brillencodes(code1,codelen1,code3,
              codelen3,code2,codelen2,&i,&k))) {    /* Codes passen zusammen */
            len = (k<<1) + (fall<5);
            if (!recover || len==l2_rec) {
              gleiche_randcodes = (codelen1==codelen3 && code1[0]==code3[0]);
              l = 1;
              if (pco) {
                for (ii=0; ii<his_anz; ii++) {his_check_pos[ii] = 0;}
                starte_history(his_anz);
              }
              nebenzweig[0] = 0L;
              do {    /* Obwohl bei e1 jedesmal die Raender verglichen werden
                         muessen, ist e2 in der aeusseren Schleife, denn e1 ist
                         klein und e2 gross, so dass eine ueberfluessige
                         Konstruktion von e2 schwerer wiegen wuerde. */
                e1 = t2[2+codelen3]->weiter.firstpatch;   wh = False;
                while (e1) {
                  start = 0;  connfl = 0;  arraypos = 0;
                  if (wh || pco) 
                     {konstruiere_patch(patchmap2,&start,dummyarray,e2,
                      gk2,nil,&connfl,&arraypos);}
                  else {
                    erg = konstruiere_patch_in_rekursion(patchmap2,
                          &start,dummyarray,e2,gk2,l-1,his_anz,
                          his_anz-1,&connfl);
                  }
                  if (erg==his_anz) {    /* Konstruktion hat geklappt */
                    wh = True;
                    if (!recover &&
                       (!facerestrict || flaechenzahlen3_ok(e1,e2,nil))) {
                      start = 0;  arraypos = 0;
                      konstruiere_patch(patchmap1,&start,dummyarray,
                                        e1,gk1,nil,&connfl,&arraypos);
                      iso = gleiche_randcodes ? (char)iso_raender(e1,0,1) : 0;
                      bestimme_gute_basen(e1);
                      bestimme_gute_basen(e2);
                      graphenzahl[ARRAYPOS_LN(g,n,3)]++;
                      gk3[0] = verknuepfe_brillenpatches(gk1[0],gk1[1],gk2[0],
                               (code1[0]<<1)+codelen1,(code3[0]<<1)+codelen3,
                               len,&code2[0],i,fall);
                      /* gk1[0] und gk1[1] duerfen nicht vertauscht werden, 
                         denn gk1[1] spielt die Rolle von Rand 2 */
                      brillen_minimalitaetstest(gk3[0],
                              !gleiche_randcodes,n,g,e1,e2,nil,21,0);
                      /* Falls Randcodes von Patch 1 gleich, aber Raender nicht
                         isomorph sind: noch ein Durchgang mit vertauschten
                         Raendern */
                      if (gleiche_randcodes && iso==0) {
                        start = 0;  connfl = 0;  arraypos = 0;
                        konstruiere_patch(patchmap1,&start,dummyarray,
                                          e1,gk1,nil,&connfl,&arraypos);
                        start = 0;  arraypos = 0;
                        konstruiere_patch(patchmap2,&start,dummyarray,e2,
                                          gk2,nil,&connfl,&arraypos);
                        /* Konstruktion hat schon einmal geklappt, deshalb
                           einfache Konstruktion ohne Tests */
                        graphenzahl[ARRAYPOS_LN(g,n,3)]++;
                        gk3[0] = verknuepfe_brillenpatches(gk1[1],gk1[0],
                                 gk2[0],(code3[0]<<1)+codelen3,
                                 (code1[0]<<1)+codelen1,len,&code2[0],i,fall);
                        /* gk1[0] und gk1[1] duerfen nicht vertauscht werden, 
                           denn gk1[1] spielt hier die Rolle von Rand 1 */
                        brillen_minimalitaetstest(gk3[0],
                          False,n,g,e1,e2,nil,22,0);
                      }
                    }
                  }
                  else {e1 = nil;}  /* Schleife beenden, da "e2" schlecht */
                  if (e1) {e1 = e1->next;} 
                  if (!recover && (save_flag || save_flag2)) 
                     {speichere_graphen_aus_outputliste_in_files(his_anz,
                      0,2,2,(code1[0]<<1)+codelen1,len,(code3[0]<<1)+
                      codelen3,0,0,n,0,0,g,krit1,0,0);}
                  if (recover && nebenzweig[0]==recovernebenzweig[0]) 
                     {recover = False;   count = recovercount;}
                  nebenzweig[0]++;
                  if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
                }    /* while e1 */
              } while (l = setze_history_weiter(his_anz,MIN(erg,his_anz-1),
                                                pco));
            }    /* if */
          }      /* if passen Brillencodes */
          /* Ende des um 14 Stellen eingerueckten Textes */

                      }    /* if zweiter Rand passt */
                      t2[3] = t2[3]->next;
                    }
                  }      /* if erster Rand passt */
                  t1[3] = t1[3]->next;
                }
              }      /* if */
              t2[2] = t2[2]->next;
            }        /* while t2[2] */
            t1[2] = t1[2]->next;
          }          /* while t1[2] */
        }            /* if zwei Raender */
        t1[1] = t1[1]->next;
      }              /* while t1[1] */
    }                /* if t1[0] */
  }                  /* if Patch e2 passt */


  /* ---- Moeglichkeit 3:  2 Patches, "e2" ist Nebenpatch ---- */
  /* nicht moeglich bei "loop_brille" etc., da "e2" kein Eineck und kein 
     Zweieck sein kann */
  if ((!recover || mgl_rec==3) && !digon_path &&
      ((do_sandwich && !l1_sandwich) || 
       (do_brille && !loop_brille && !digon_brille)) &&
      nebenpatch && fl2<fl && g2<g && krit2<=krit_max) {
    /* "e2" kann Nebenpatch bei Moeglichkeit 3 sein */
    /* Patch 1 zuordnen: */
    t3[0] = tree[fl3 = fl-fl2];
    while (t3[0] && g2+(g3 = t3[0]->code)+1<g) {t3[0] = t3[0]->next;}
    if (t3[0] && g3+g2+1==g) {    /* Genus passt */
      t3[1] = t3[0]->weiter.nextlevel;
      while (t3[1] && krit2+(krit3 = t3[1]->code)<krit_min) 
            {t3[1] = t3[1]->next;}
      while (t3[1] && krit2+(krit3 = t3[1]->code)<=krit_max) { 
        /* kritische Punkte im Intervall */        
        t1[0] = t3[1]->weiter.nextlevel;  /* t1[0] ist willkuerlich gewaehlt */
        while (t1[0] && t1[0]->code<2) {t1[0] = t1[0]->next;}
        if (t1[0] && t1[0]->code==2 &&
           (!recover || krit3==krit3_rec)) {    /* zwei Raender */
          t3[2] = t1[0]->weiter.nextlevel->weiter.nextlevel; 
          /* vgl. Bauchbinde */

          /* --- 3.1: erster Rand in Patch 1 ist fuer Nebenrand --- */
          /*    (geht nur bei Sandwiches und dort nur bei Fall 2, da sonst 
                 erster Rand kuerzer als zweiter Rand waere)                 */
          while (t3[2] && t3[2]->code<=6) {   /* Rand hat <=2 Bruchkanten */
            codelen1 = t3[2]->code - 4;
            t1[2] = t3[2]->weiter.nextlevel;  
            /* t1[2] ist willkuerlich gewaehlt */
            while (t1[2] && codelen1+(codelen3 = t1[2]->code-t3[2]->code)+
                   codelen2 < 6) {t1[2] = t1[2]->next;}
            if (t1[2] && codelen1+codelen2+codelen3==6) {  /* Randlg. passt */
              t1[3] = t1[2]->weiter.nextlevel;    /* erster Randcodeeintrag */
              while (t1[3]) {
                code1[0] = t1[3]->code;
                if (codelen1==2) {t1[4] = t1[3]->weiter.nextlevel; 
                                  code1[1] = t1[4]->code;}
                if (codelen1==1 || (code1[0]!=BB_KENNUNG && code1[1]==0)) { 
                   /* Rand 1 passt */

        /* folgenden Text um 10 Stellen einruecken: */
        if (do_sandwich && !l1_sandwich && (len23 = (code2[0]<<1)+codelen2)>1 
           && (!recover || (submgl_rec==1 && len23==l3_rec && 
           (code1[0]<<1)+codelen1==l1_rec))) {
          t3[3] = t1[2+codelen1]->weiter.nextlevel; /* Beginn von Randcode 3 */
          t3[4] = nil;  k = 0;
          len12 = (code1[0]<<1)+codelen1;
          len2 = MIN(len23,len12);
          len2 -= (1+(len2&1));      /* groesstmgl. Laenge fuer Naht 2 */

          /* -- 3.1.1:  erster Rand in Patch 1 ist Nebenrand 1 -- */
          fall = 4 + codelen2 - (codelen1<<1);       /* Faelle 1-4 */
          if (fall!=2) {fprintf(stderr,"Dicker Fehler in "
                        "bilde_graphen_aus_sandwichpatches!\n"); exit(33);}
          if (t3[3]) {        
            bereite_sandwichcodes_vor(fall,len12-len2,len23-len2,code3,
                                      &aend,&i);
            while (t3e = suche_randcode(&code3[i],codelen3,aend,&t3[3],&k)) {
              /* Rand 3 gefunden */ 
              len2 = MIN(len23,len12);
              len2 -= (1+(len2&1));    /* groesste Laenge fuer Naht 2 */ 
              if (len2 > (k<<1) &&     /* k ist klein genug */
                 (!recover || len2-(k<<1)==l2_rec)) {
                len2 -= (k<<1);        /* aktuelle Laenge von Nahtteil 2 */
                l = 1;
                if (pco) {
                  for (ii=0; ii<his_anz; ii++) {his_check_pos[ii] = 0;}
                  starte_history(his_anz);
                }
                nebenzweig[0] = 0L;
                do {
                  e1 = t3e->weiter.firstpatch;   wh = False;
                  while (e1) {
                    start = 0;  connfl = 0;  arraypos = 0;
                    if (wh || pco) 
                       {konstruiere_patch(patchmap2,&start,dummyarray,e2,
                        gk2,nil,&connfl,&arraypos);}
                    else {
                      erg = konstruiere_patch_in_rekursion(patchmap2,
                            &start,dummyarray,e2,gk2,l-1,his_anz,
                            his_anz-1,&connfl);
                    }
                    if (erg==his_anz) {    /* Konstruktion hat geklappt */
                      wh = True;
                      if (!recover &&
                         (!facerestrict || flaechenzahlen3_ok(e1,e2,nil))) {
                        start = 0;  arraypos = 0;
                        konstruiere_patch(patchmap1,&start,dummyarray,
                                          e1,gk1,nil,&connfl,&arraypos);
                        bestimme_gute_basen(e1);
                        bestimme_gute_basen(e2);
                        graphenzahl[ARRAYPOS_LN(g,n,2)]++;
                        gk3[0] = verknuepfe_sandwichpatches(gk1[0],gk2[0],
                                 gk1[1],len12-len2,len2,len23-len2,&code3[i],
                                 i ? 1+(fall>2) : 0,fall);
                        /* gk1[1] und gk2[0] duerfen nicht vertauscht werden, 
                           denn gk2[0] spielt die Rolle von Nebenrand 2 */
                        /* gk1[0] muss der Nebenrand in Patch 1 sein, denn 
                           gerade danach wurde gesucht und 
                           Randcode 1==Randcode 3 ist nicht moeglich */
                        sandwich_minimalitaetstest(gk3[0]->next,
                               True,n,g,e2,e1,nil,fall>2,31,False,0);
                        /* festlegen=True, denn die Patches von Rand 1 und 2
                           stammen immer aus unterschiedlichen Listen und 
                           werden nicht vertauscht. */
                      }
                    }
                    else {e1 = nil;}  /* Schleife beenden, da e2 schlecht */
                    if (e1) {e1 = e1->next;}
                    if (!recover && (save_flag || save_flag2)) 
                       {speichere_graphen_aus_outputliste_in_files(his_anz,
                        0,3,1,len12,len2,len23,0,0,n,0,0,g,0,0,krit3);}
                    if (recover && nebenzweig[0]==recovernebenzweig[0]) 
                       {recover = False;   count = recovercount;}
                    nebenzweig[0]++;
                    if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
                  }   /* while e1 */ 
                } while (l = setze_history_weiter(his_anz,MIN(erg,his_anz-1),
                                                  pco));
              }     /* if len2>k*2 */
            }    /* while t3e */
          }     /* if t3[3] */
        }      /* if do_sandwich */
        /* Ende des um 10 Stellen eingerueckten Textes */

                }    /* if Rand 1 passt */
                t1[3] = t1[3]->next;
	      }    /* while t1[3] */
            }      /* if Randlaenge passt */
            t3[2] = t3[2]->next;
          }        /* while t3[2] */

          /* --- 3.2: erster Rand in Patch 1 ist fuer Hauptrand --- */
          /* Dieser Fall wird nicht durchlaufen, wenn die beiden Raender in
             Patch 1 isomorph sind, weil dann eine Dopplung gegenueber
             Fall 3.1 auftritt. */
          t3[2] = t1[0]->weiter.nextlevel->weiter.nextlevel;  
          /* nochmal durchgehen */
          while (t3[2] && t3[2]->code<=8) {   /* Rand hat <=4 Bruchkanten */
            codelen3 = t3[2]->code - 4;
            if (codelen3>1) {
              t1[2] = t3[2]->weiter.nextlevel;  
              /* t1[2] ist willkuerlich gewaehlt */
              while (t1[2] && codelen2+(codelen1 = t1[2]->code-t3[2]->code)+
                     codelen3 < 6) {t1[2] = t1[2]->next;}
              if (t1[2] && codelen1+codelen2+codelen3==6) { 
                t3[3] = t1[2]->weiter.nextlevel;  
                /* erster Randcodeeintrag Rand 2 */
                j = 3;                       /* aktueller Level */
                while (t3[3] && j>2) {     /* es kommen noch Patches im Baum */
                  while (j-3<codelen3) {     /* Randcode 2 ermitteln */
                    code3[j-3] = t3[j]->code;
                    j++;
                    if (j-3<codelen3) {t3[j] = t3[j-1]->weiter.nextlevel;}
                  }
                  j--;          /* "j" zeigt auf letzten sinnvollen Eintrag */
                  if (code3[0]!=BB_KENNUNG) { 
                     /* Randcode 3 gefunden - Randcode 1 ermitteln */
                    t1[3] = t3[j]->weiter.nextlevel;
                    while (t1[3]) {
                      code1[0] = t1[3]->code;
                      if (codelen1==2) {t1[4] = t1[3]->weiter.nextlevel;
                                        code1[1] = t1[4]->code;}
                      if (codelen1==1 || 
                         (code1[0]!=BB_KENNUNG && code1[1]==0)) {
                         /* Rand 1 passt - nun schauen, ob alle drei Raender
                          zueinander passen */
                      
          /* folgenden Text um 14 Stellen einruecken: */
          /* -- 3.2.1:  zweiter Rand in Patch 1 ist Nebenrand 1 -- */
          if (do_sandwich && !l1_sandwich && 
             (len23 = (code2[0]<<1)+codelen2)>1 &&
             (!recover || (submgl_rec==2 && len23==l3_rec && 
             (code1[0]<<1)+codelen1==l1_rec)) &&
             (fall = passen_sandwichcodes(code1,codelen1,code2,
              codelen2,code3,codelen3,&i,&k))) {    /* Codes passen zusammen */
            len12 = (code1[0]<<1)+codelen1;
            len2 = (k<<1)+1;
            if (!recover || len2==l2_rec) {
              gleiche_randcodes = (codelen1==codelen3 && code1[0]==code3[0]);
                                  /* Randcodes in Patch 1 gleich? */
              l = 1;
              if (pco) {
                for (ii=0; ii<his_anz; ii++) {his_check_pos[ii] = 0;}
                starte_history(his_anz);
              }
              nebenzweig[0] = 0L;
              do {
                e1 = t1[2+codelen1]->weiter.firstpatch;   wh = False;
                while (e1) {
                  start = 0;  connfl = 0;  arraypos = 0;
                  if (wh || pco) 
                     {konstruiere_patch(patchmap2,&start,dummyarray,e2,
                      gk2,nil,&connfl,&arraypos);}
                  else {
                    erg = konstruiere_patch_in_rekursion(patchmap2,
                          &start,dummyarray,e2,gk2,l-1,his_anz,
                          his_anz-1,&connfl);
                  }
                  if (erg==his_anz) {    /* Konstruktion hat geklappt */
                    wh = True;
                    if (!recover &&
                       (!facerestrict || flaechenzahlen3_ok(e1,e2,nil))) {
                      start = 0;  arraypos = 0;
                      konstruiere_patch(patchmap1,&start,dummyarray,
                                        e1,gk1,nil,&connfl,&arraypos);
                      if (!(gleiche_randcodes && iso_raender(e1,0,1))) {
                        /* keine Dopplung gegenueber Fall 3.1 */
                        bestimme_gute_basen(e1);
                        bestimme_gute_basen(e2);
                        graphenzahl[ARRAYPOS_LN(g,n,2)]++;
                        gk3[0] = verknuepfe_sandwichpatches(gk1[1],gk2[0],
                           gk1[0],len12-len2,len2,len23-len2,&code3[0],i,fall);
                        /* laeuft, da "code3" in der Funktion 
                           "passen_sandwichcodes"
                           zweimal hintereinandergeschrieben wurde */
                        sandwich_minimalitaetstest(gk3[0]->next,True,
                                              n,g,e2,e1,nil,fall>2,32,False,0);
                        /* festlegen=True, denn die Patches von Rand 1 und Rand
                           2 stammen immer aus unterschiedlichen Listen und 
                           werden nicht vertauscht. */
                      }
                    }
                  }
                  else {e1 = nil;}   /* Schleife beenden, da "e2" schlecht */
                  if (e1) {e1 = e1->next;} 
                  if (!recover && (save_flag || save_flag2)) 
                     {speichere_graphen_aus_outputliste_in_files(his_anz,
                      0,3,2,len12,len2,len23,0,0,n,0,0,g,0,0,krit3);}
                  if (recover && nebenzweig[0]==recovernebenzweig[0]) 
                     {recover = False;   count = recovercount;}
                  nebenzweig[0]++;
                  if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
                }    /* while e1 */
              } while (l = setze_history_weiter(his_anz,MIN(erg,his_anz-1),
                                                pco));
            }   /* if */
          }     /* if passen Sandwichcodes */

          if (do_brille && !loop_brille && !digon_brille &&
             (!recover || (submgl_rec==3 &&
             (code1[0]<<1)+codelen1==l1_rec && (code2[0]<<1)+codelen2==l3_rec))
             && (fall = passen_brillencodes(code1,codelen1,code2,
                 codelen2,code3,codelen3,&i,&k))) { /* Codes passen zusammen */
            /* Die Randcodes von Patch 1 sind nicht gleich, da bei der
               Brille Haupt- und Nebenrand nicht gleich sein koennen. */
            len = (k<<1) + (fall<5);
            if (!recover || len==l2_rec) {
              l = 1;
              if (pco) {
                for (ii=0; ii<his_anz; ii++) {his_check_pos[ii] = 0;}
                starte_history(his_anz);
              }
              nebenzweig[0] = 0L;
              do {
                e1 = t1[2+codelen1]->weiter.firstpatch;   wh = False;
                while (e1) {
                  start = 0;  connfl = 0;  arraypos = 0;
                  if (wh || pco) 
                     {konstruiere_patch(patchmap2,&start,dummyarray,e2,
                      gk2,nil,&connfl,&arraypos);}
                  else {
                    erg = konstruiere_patch_in_rekursion(patchmap2,
                          &start,dummyarray,e2,gk2,l-1,his_anz,
                          his_anz-1,&connfl);
                  }
                  if (erg==his_anz) {    /* Konstruktion hat geklappt */
                    wh = True;
                    if (!recover &&
                       (!facerestrict || flaechenzahlen3_ok(e1,e2,nil))) {
                      start = 0;  arraypos = 0;
                      konstruiere_patch(patchmap1,&start,dummyarray,
                                        e1,gk1,nil,&connfl,&arraypos);
                      bestimme_gute_basen(e1);
                      bestimme_gute_basen(e2);
                      graphenzahl[ARRAYPOS_LN(g,n,3)]++;
                      gk3[0] = verknuepfe_brillenpatches(gk1[1],gk2[0],gk1[0],
                               (code1[0]<<1)+codelen1,(code2[0]<<1)+codelen2,
                               len,&code3[0],i,fall);
                      /* laeuft, da "code3" in der Funktion 
                         "passen_brillencodes"
                         zweimal hintereinandergeschrieben wurde */
                      brillen_minimalitaetstest(gk3[0],True,
                                                 n,g,e2,e1,nil,31,0);
                      /* festlegen=True, denn die Patches von Rand 1 und Rand 2
                         stammen immer aus unterschiedlichen Listen und werden
                         nicht vertauscht. */
                    }
                  }
                  else {e1 = nil;}   /* Schleife beenden, da "e2" schlecht */
                  if (e1) {e1 = e1->next;} 
                  if (!recover && (save_flag || save_flag2)) 
                     {speichere_graphen_aus_outputliste_in_files(his_anz,
                      0,3,3,(code1[0]<<1)+codelen1,len,(code2[0]<<1)+
                      codelen2,0,0,n,0,0,g,0,0,krit3);}
                  if (recover && nebenzweig[0]==recovernebenzweig[0]) 
                     {recover = False;   count = recovercount;}
                  nebenzweig[0]++;
                  if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
                }    /* while e1 */
              } while (l = setze_history_weiter(his_anz,MIN(erg,his_anz-1),
                                                pco));
            }   /* if */
          }     /* if passen Brillencodes */
          /* Ende des um 14 Stellen eingerueckten Textes */

                      }   /* if Rand 1 passt */
                      t1[3] = t1[3]->next;
                    }     /* while t1[3] */
                  }       /* if Randcode 3 gefunden */
                  do {
                    zurueck = False;    /* muss Rueckschritt erfolgen? */ 
                    t3[j] = t3[j]->next;   
                    if (!t3[j]) {zurueck = True; j--;}    /* Rueckschritt */ 
                  } while (j>2 && zurueck);
                }     /* while j>2 */ 
              }       /* if t1[2] */
            }         /* if codelen3>1 */
            t3[2] = t3[2]->next;
          }           /* while t3[2] */
        }             /* if 2 Raender */
        t3[1] = t3[1]->next;
      }               /* while t3[1] */
    }                 /* if Genus passt */      
  }                   /* if Patch e2 passt */
}

/***********BILDE_GRAPHEN_AUS_BRUCHKANTENPATCHES2_IN_REKURSION**************/
/*  Bildet Graphen aus 2 Bruchkantenpatches, einer davon ist "e2". "e2" 
    besitzt genau zwei Raender. Diese Raender enthalten Bruchkanten. Wenn
    "hauptrand1" den Wert "True" besitzt, so kann Rand 1 vom Randcode her
    Hauptrand sein. Dasselbe gilt fuer "nebenrand1" sowie "hauptrand2" und
    "nebenrand2". "e2" hat Geschlecht "g2", "krit2" kritische Punkte und 
    "fl2" Flaechen sowie den Bordercode "code". Die 
    resultierenden Graphen besitzen "n" Knoten und Geschlecht "g".
    Weitere Kommentare siehe "bilde_graphen_aus_bauchbindenpatches".       */

void bilde_graphen_aus_bruchkantenpatches2_in_rekursion(KNOTENTYP g,
  KNOTENTYP n,
  KNOTENTYP g2,KNOTENTYP krit2,KNOTENTYP fl2,ELEM *e2,KNOTENTYP *code,
  BOOL hauptrand1,BOOL nebenrand1,BOOL hauptrand2,BOOL nebenrand2,
  POSTYP his_anz) {
  static KNOTENTYP fl1;   /* Flaechenzahl des anderen beteiligten Patches */
  static KNOTENTYP g1;     /* Geni des anderen beteiligten Patches */
  static KNOTENTYP krit1;   /* kritische Punkte des anderen Patches */
  static KNOTENTYP fl;           /* Anzahl Flaechen im erzeugten Graphen */
  static TREENODE *t1[9],*t2[9],*t3[9];
         /* fuer jeden Patch und jede benoetigte Baumtiefe ein Zeiger, so dass
            Rueckspruenge moeglich sind (nicht immer werden die Elemente tx[y]
            nur fuer Patch x benutzt) */
  static TREENODE *t3e; /* Zeiger fuer Patch 3 (je nach Laenge des Randcodes
                           ist t3e gleich t3[i] fuer ein i) */
  static ELEM *e1;       /* Zeiger auf den anderen beteiligten Patch */  
  static KANTE *gk1[2], *gk2[2];
         /* Arrays koennen so klein sein, da jeweils <=2 Raender im Patch */
  static KNOTENTYP code1[8], code2[8], code3[8];  
         /* Randcodes (bei Bedarf zweimal hintereinander) */
  static KNOTENTYP codelen1,codelen2,codelen3; 
         /* Randcodelaengen der einzelnen Patches */
  static KNOTENTYP i;      /* Offset in code3, so dass der Code maximal ist */
  static KNOTENTYP j;      /* Zaehlvariable */
  static KNOTENTYP dummyarray[11];   /* nimmt einen Bordercode auf */
         /* groesstmoegliche Laenge:  1 + 4 + 6 fuer Anzahl Raender +
            Randanfangsindices (3 Stueck + Endekennung) + Randcodes */ 
  static KNOTENTYP connfl;      
  static KNOTENTYP len;    /* Laenge des mittleren Nahtteils (Brille) */ 
  static KNOTENTYP len2;   /* Laenge von Nahtteil 2 (Verknuepfung von Patch 1
                              und Patch 2) (Sandwich) */
  static unsigned char fall;  /* "fall" gibt an, welcher der Faelle 1-4 beim 
    Verknuepfen angewendet werden muss */
  static KNOTENTYP k;      /* Anzahl der Winkel in Nahtteil 2 (aus
                              dieser errechnet sich der Wert von "len2") */
  static unsigned char aend;  /* Erklaerung siehe "suche_randcode" */
  static KNOTENTYP len12, len23;   /* Laengen der Nahtteile 1 und 2 bzw.
                                      2 und 3 zusammen (Sandwich) */
  static KANTENARRAY patchmap1,patchmap2;
  static BOOL zurueck;
  static POSTYP start,arraypos;
  static char iso;     /* gibt bei bestimmten Faellen an, ob zwei Raender
                          isomorph sind (1 = ja, 0 = nein, -1 = unbestimmt) */
  static BOOL gleiche_randcodes;    /* gibt bei bestimmten Faellen an, ob
                                       zwei Randcodes gleich sind */ 
  static POSTYP ii,erg,l;     /* "l" siehe "setze_history_weiter" */
  static BOOL wh;          /* True => Schleife wird mehrfach durchlaufen */
  
  erg = his_anz;
  pco = patchcheck && !overflow[his_anz-1];
  fl = (n>>1)+2-(g<<1);
  codelen2 = code[2]-code[1];
  memcpy(code2,&code[4],sizeof(KNOTENTYP)*codelen2);
  memcpy(&code2[codelen2],code2,sizeof(KNOTENTYP)*codelen2);
    /* nun enthaelt "code2" zweimal hintereinander den 1.Randcode von "e2" */
  codelen3 = code[3]-code[2];
  memcpy(code3,&code[code[2]],sizeof(KNOTENTYP)*codelen3);
  memcpy(&code3[codelen3],code3,sizeof(KNOTENTYP)*codelen3);
    /* nun enthaelt "code3" zweimal hintereinander den 2.Randcode von "e2" */

  /* ---- Moeglichkeit 2:  "e2" enthaelt beide Nebenraender ---- */
  /* nicht moeglich bei Loop-Brille etc., da beide Nebenraender Kerben haben */
  if ((!recover || mgl_rec==2) && nebenrand1 && nebenrand2 && fl2<fl && g2<g 
      && krit2<=krit_max && !digon_path && ((do_sandwich && !l1_sandwich) || 
      (do_brille && !loop_brille && !digon_brille))) {
    /* Patch 1 (Hauptpatch) zuordnen: */
    t3[0] = tree[fl1 = fl-fl2];
    while (t3[0] && g2+(g1 = t3[0]->code)+1<g) {t3[0] = t3[0]->next;}
    if (t3[0] && g1+g2+1==g) {    /* Genus passt */
      t3[1] = t3[0]->weiter.nextlevel;
      while (t3[1] && krit2+(krit1 = t3[1]->code)<krit_min) 
            {t3[1] = t3[1]->next;}
      while (t3[1] && krit2+(krit1 = t3[1]->code)<=krit_max) { 
        /* kritische Punkte im Intervall */        
        t3[2] = t3[1]->weiter.nextlevel;
        if (t3[2] && t3[2]->code==1 &&    /* ein Rand */
           (!recover || krit1==krit1_rec)) {
          t3[2] = t3[2]->weiter.nextlevel->weiter.nextlevel;   
          /* vgl. Bauchbinde */
          while (t3[2] && t3[2]->code<9-codelen3-codelen2)
                {t3[2] = t3[2]->next;}
          if (t3[2] && codelen3+codelen2+(codelen1 = t3[2]->code-3)==6) {
            /* Randlaenge passt */ 

            if (do_sandwich && !l1_sandwich && (!recover || (submgl_rec==1 &&
               (code2[0]<<1)+codelen2==l1_rec && 
               (code3[0]<<1)+codelen3==l3_rec))) {
              t3[3] = t3[2]->weiter.nextlevel;     /* erster Randcodeeintrag */
              t3[4] = nil;  k = 0;
              len12 = (code2[0]<<1)+codelen2;
              len23 = (code3[0]<<1)+codelen3;
              len2 = MIN(len23,len12);
              len2 -= (1+(len2&1));   /* groesstmoegliche Laenge fuer Naht 2 */
              fall = 4 + codelen3 - (codelen2<<1);       /* Faelle 1-4 */
              if (fall==4) {fprintf(stderr,"Logischer Fehler in "
                      "bilde_graphen_aus_sandwichpatches: fall 4 in case 2\n");
                      exit(34);}  /* zweiter Randcode kann nicht laenger sein
                                      als erster */
              if (t3[3]) {        
                bereite_sandwichcodes_vor(fall,len12-len2,len23-len2,code1,
                                          &aend,&i);
                gleiche_randcodes = (len12==len23); /* Raender 1 und 2 gleich?
                               <=> codelen2==codelen3 && code2[0]==code3[0] */
                while (t3e = suche_randcode(&code1[i],codelen1,aend,&t3[3],
                       &k)) {  /* Patch 1 gefunden */ 
                  len2 = MIN(len23,len12);
                  len2 -= (1+(len2&1));    /* groesste Laenge fuer Naht 2 */ 
                  if (len2 > (k<<1) &&     /* k ist klein genug */
                     (!recover || len2-(k<<1)==l2_rec)) {
                    len2 -= (k<<1);        /* aktuelle Laenge von Nahtteil 2 */
                    l = 1;
                    if (pco) {
                      for (ii=0; ii<his_anz; ii++) {his_check_pos[ii] = 0;}
                      starte_history(his_anz);
                    }
                    nebenzweig[0] = 0L;
                    do {
                      iso = -1;   /* unbestimmt, ob Raender isomorph sind */
                      e1 = t3e->weiter.firstpatch;    wh = False;
                      while (e1) {
                        start = 0;  connfl = 0;  arraypos = 0;
                        if (wh || pco) 
                           {konstruiere_patch(patchmap2,&start,dummyarray,e2,
                            gk2,nil,&connfl,&arraypos);}
                        else {
                          erg = konstruiere_patch_in_rekursion(patchmap2,
                                &start,dummyarray,e2,gk2,l-1,his_anz,
                                his_anz-1,&connfl);
                        }
                        if (erg==his_anz) {    /* Konstruktion hat geklappt */
                          wh = True;
                          if (!recover &&
                             (!facerestrict || flaechenzahlen3_ok(e1,e2,nil))){
                            start = 0;  arraypos = 0;
                            konstruiere_patch(patchmap1,&start,dummyarray,
                                              e1,gk1,nil,&connfl,&arraypos);
                            if (iso==-1) {iso = gleiche_randcodes ? 
                                          (char)iso_raender(e2,0,1) : 0;}
                               /* "iso" nur einmal berechnen */
                            bestimme_gute_basen(e1);
                            bestimme_gute_basen(e2);
                            graphenzahl[ARRAYPOS_LN(g,n,2)]++;
                            gk1[0] = verknuepfe_sandwichpatches(gk2[0],gk2[1],
                                     gk1[0],len12-len2,len2,len23-len2,
                                     &code1[i],i ? 1+(fall>2) : 0,fall);
                            /* gk2[0] und gk2[1] duerfen nicht vertauscht wer-
                               den, denn gk2[1] spielt die Rolle von Rand 2 */
                            sandwich_minimalitaetstest(gk1[0]->next,
                             !gleiche_randcodes,n,g,e2,e1,nil,fall>2,21,
                             False,0);
                            /* Falls Randcodes von Patch 1 gleich, aber Raender
                               nicht isomorph sind: noch ein Durchgang mit 
                               vertauschten Raendern (fall,len12,len23 
                               bleiben erhalten) */
                            if (gleiche_randcodes && iso==0) {
                              start = 0;  connfl = 0;  arraypos = 0;
                              konstruiere_patch(patchmap1,&start,dummyarray,
                                                e1,gk1,nil,&connfl,&arraypos);
                              start = 0;  arraypos = 0;
                              konstruiere_patch(patchmap2,&start,dummyarray,
                                                e2,gk2,nil,&connfl,&arraypos);
                              graphenzahl[ARRAYPOS_LN(g,n,2)]++;
                              gk1[0] = verknuepfe_sandwichpatches(gk2[1],
                                       gk2[0],
                                       gk1[0],len23-len2,len2,len12-len2,
                                       &code1[i],i ? 1+(fall>2) : 0,fall);
                              sandwich_minimalitaetstest(gk1[0]->next,
                                False,n,g,e2,e1,nil,fall>2,22,False,0);
                            }
                          }
                        }
                        else {e1 = nil;} /* Schleife beenden, da e2 schlecht */
                        if (e1) {e1 = e1->next;}
                        if (!recover && (save_flag || save_flag2)) 
                           {speichere_graphen_aus_outputliste_in_files(his_anz,
                            0,2,1,len12,len2,len23,0,0,n,0,0,g,krit1,0,0);}
                        if (recover && nebenzweig[0]==recovernebenzweig[0]) 
                           {recover = False;   count = recovercount;}
                        nebenzweig[0]++;
                        if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
                      }  /* while e1 */ 
                    } while (l = setze_history_weiter(his_anz,
                                 MIN(erg,his_anz-1),pco));
                  }   /* if len2>k*2 */
                }    /* while t3e */
              }     /* if t3[3] */
            }      /* if do_sandwich */

            if (do_brille && !loop_brille && !digon_brille &&
               (!recover || (submgl_rec==2 &&
               (code2[0]<<1)+codelen2==l1_rec && 
               (code3[0]<<1)+codelen3==l3_rec))) {
              t3[3] = t3[2]->weiter.nextlevel;    
              /* erster Randcodeeintrag */
              t3[4] = nil;  k = 0;
              fall = 7 - (codelen2<<1) - codelen3;  /* zunaechst Faelle 1-4 */
              while (t3[3]) {        
                bereite_brillencodes_vor(fall,code2,code3,code1,&aend,&i,
                                         1+(fall>4));
                gleiche_randcodes = (codelen2==codelen3 && code2[0]==code3[0]);
                while (t3e = suche_randcode(&code1[i],codelen1,aend,&t3[3],
                       &k)) {    /* Patch 1 gefunden */ 
                  len = (k<<1) + (fall<5);
                  if (!recover || len==l2_rec) {
                    l = 1;
                    if (pco) {
                      for (ii=0; ii<his_anz; ii++) {his_check_pos[ii] = 0;}
                      starte_history(his_anz);
                    }
                    nebenzweig[0] = 0L;
                    do {
                      iso = -1;   /* unbestimmt, ob Raender isomorph sind */
                      e1 = t3e->weiter.firstpatch;   wh = False;
                      while (e1) {
                        start = 0;  connfl = 0;  arraypos = 0;
                        if (wh || pco) 
                           {konstruiere_patch(patchmap2,&start,dummyarray,e2,
                            gk2,nil,&connfl,&arraypos);}
                        else {
                          erg = konstruiere_patch_in_rekursion(patchmap2,
                                &start,dummyarray,e2,gk2,l-1,his_anz,
                                his_anz-1,&connfl);
                        }
                        if (erg==his_anz) {    /* Konstruktion hat geklappt */
                          wh = True;
                          if (!recover &&
                             (!facerestrict || flaechenzahlen3_ok(e1,e2,nil))){
                            start = 0;  arraypos = 0;
                            konstruiere_patch(patchmap1,&start,dummyarray,
                                              e1,gk1,nil,&connfl,&arraypos);
                            if (iso==-1) {iso = gleiche_randcodes ? 
                                          (char)iso_raender(e2,0,1) : 0;}
                               /* "iso" nur einmal berechnen */
                            bestimme_gute_basen(e1);
                            bestimme_gute_basen(e2);
                            graphenzahl[ARRAYPOS_LN(g,n,3)]++;
                            gk1[0] = verknuepfe_brillenpatches(gk2[0],gk2[1],
                                     gk1[0],(code2[0]<<1)+codelen2,
                                     (code3[0]<<1)+codelen3,len,&code1[i],
                                     i ? 3-codelen2 : 0,fall);
                            brillen_minimalitaetstest(gk1[0],
                                !gleiche_randcodes,n,g,e2,e1,nil,21,0);
                            /* Falls Randcodes von Patch 1 gleich, aber Raender 
                               nicht isomorph sind: noch ein Durchgang mit 
                               vertauschten Raendern */
                            if (gleiche_randcodes && iso==0) {
                              start = 0;  connfl = 0;  arraypos = 0;
                              konstruiere_patch(patchmap1,&start,dummyarray,
                                                e1,gk1,nil,&connfl,&arraypos);
                              start = 0;  arraypos = 0;
                              konstruiere_patch(patchmap2,&start,dummyarray,
                                                e2,gk2,nil,&connfl,&arraypos);
                              graphenzahl[ARRAYPOS_LN(g,n,3)]++;
                              gk1[0] = verknuepfe_brillenpatches(gk2[1],gk2[0],
                                       gk1[0],(code3[0]<<1)+codelen3,
                                       (code2[0]<<1)+codelen2,len,
                                       &code1[i],i ? 3-codelen3 : 0,fall);
                              brillen_minimalitaetstest(gk1[0],
                                  False,n,g,e2,e1,nil,22,0);
                            }
                          }
                        }
                        else {e1 = nil;} /* Schleife beenden, da e2 schlecht */
                        if (e1) {e1 = e1->next;}
                        if (!recover && (save_flag || save_flag2)) 
                           {speichere_graphen_aus_outputliste_in_files(his_anz,
                            0,2,2,(code2[0]<<1)+codelen2,len,(code3[0]<<1)+
                            codelen3,0,0,n,0,0,g,krit1,0,0);}
                        if (recover && nebenzweig[0]==recovernebenzweig[0]) 
                           {recover = False;   count = recovercount;}
                        nebenzweig[0]++;
                        if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
                      }  /* while e1 */ 
                    } while (l = setze_history_weiter(his_anz,
                                 MIN(erg,his_anz-1),pco));
                  }        /* if */
                }    /* while t3e */
                if (fall<5) {fall += 4;  t3[3] = t3[2]->weiter.nextlevel;  
                             t3[4] = nil;  k=1;}
                else {t3[3] = nil;}                
              }     /* while t3[3] */
            }      /* if do_brille */

          }      /* if richtige Codelaenge */
        }       /* if ein Rand */
        t3[1] = t3[1]->next;
      }      /* while kritische Punkte */
    }       /* if Genus passt */
  }        /* if Patch e2 passt */


  /* ---- Moeglichkeit 3:  2 Patches, "e2" enthaelt einen Nebenrand und den 
          Hauptrand ---- */
  if ((!recover || mgl_rec==3) &&
      ((hauptrand1 && nebenrand2) || (hauptrand2 && nebenrand1)) &&
      g2<g && fl2<fl && krit2<=krit_max) {  
    /* Patch 1 heraussuchen (Nebenrand): */
    t2[0] = tree[fl1 = fl-fl2];
    while (t2[0] && (g1 = t2[0]->code)+g2+1 < g) {t2[0] = t2[0]->next;}
    if (t2[0] && g1+g2+1==g &&   /* Genus passt */
       ((do_sandwich && !l1_sandwich && !digon_path) || 
        (do_brille && !loop_brille && !digon_brille && !digon_path) || 
        (g1==0 && fl1==1))) {
       /* bei loop_brille: "e1" ist eine Flaeche */
      t2[1] = t2[0]->weiter.nextlevel;  
      while (t2[1] && (krit1 = t2[1]->code)+krit2 < krit_min) 
   	    {t2[1] = t2[1]->next;} 
      while (t2[1] && (krit1 = t2[1]->code)+krit2 <= krit_max) {
        t2[2] = t2[1]->weiter.nextlevel;
        if (t2[2] && t2[2]->code==1 &&    /* ein Rand */
           (!recover || krit1==krit1_rec)) {
          t2[2] = t2[2]->weiter.nextlevel->weiter.nextlevel;  
          /* vgl. Bauchbinde */
          while (t2[2] && t2[2]->code<=5) {  /* Rand hat <=2 Bruchkanten */
            codelen1 = t2[2]->code - 3; 
            if (codelen1+codelen2+codelen3==6) {  /* Randlaengen passen */
              t2[3] = t2[2]->weiter.nextlevel;    /* erster Randcodeeintrag */
              while (t2[3]) {                  /* Patchliste 2 steht fest */
                code1[0] = t2[3]->code; 
                if (codelen1==2) {t2[4] = t2[3]->weiter.nextlevel; 
                                  code1[1] = t2[4]->code;}
                if ((codelen1==1 || (code1[0]!=BB_KENNUNG && code1[1]==0)) &&
                   ((do_sandwich && !l1_sandwich && !digon_path) || 
                    (do_brille && !loop_brille && !digon_brille && !digon_path)
                    || (codelen1<=2-(KNOTENTYP)(loop_brille && !do_sandwich) &&
                        code1[0]==0))) {
                        /* Patches gefunden (loop_brille => "e1" ist Eineck) */

	/*    Text 10 Zeichen einruecken:    */ 
        /* --- 3.1: erster Rand in "e2" ist fuer Nebenrand --- */
        /*    (geht nur beim Sandwich und dort nur bei Fall 2, da sonst erster
               Rand kuerzer als zweiter Rand waere)   */
	if (do_sandwich && nebenrand1 && hauptrand2 && 
           ((!l1_sandwich && !digon_path) ||
            (g1==0 && fl1==1 && codelen1==2 && code1[0]==0)) &&
            (len12 = (code1[0]<<1)+codelen1)>1 &&
            (!recover || (submgl_rec==1 && len12==l1_rec &&
            (code2[0]<<1)+codelen2==l3_rec)) &&
            (fall = passen_sandwichcodes(code1,
            codelen1,code2,codelen2,code3,codelen3,&i,&k))) {  
          len23 = (code2[0]<<1)+codelen2;
          len2 = (k<<1)+1;
          if (!recover || len2==l2_rec) {
            gleiche_randcodes = (codelen2==codelen3 && code2[0]==code3[0]);
                                /* Randcodes in Patch 2 gleich? */
            /* -- 3.1.1:  erster Rand in Patch 1 ist Nebenrand 1 -- */
            fall = 4 + codelen2 - (codelen1<<1);       /* Faelle 1-4 */
            if (fall!=2) {fprintf(stderr,"Dicker Fehler in "
                         "bilde_graphen_aus_sandwichpatches2_in_rekursion!\n");
                          exit(35);}
            l = 1;
            if (pco) {
              for (ii=0; ii<his_anz; ii++) {his_check_pos[ii] = 0;}
              starte_history(his_anz);
            }
            nebenzweig[0] = 0L;
            do {
              e1 = t2[2+codelen1]->weiter.firstpatch;    wh = False;
              while (e1) {
                start = 0;  connfl = 0;  arraypos = 0;
                if (wh || pco) 
                   {konstruiere_patch(patchmap2,&start,dummyarray,e2,
                    gk2,nil,&connfl,&arraypos);}
                else {
                  erg = konstruiere_patch_in_rekursion(patchmap2,
                        &start,dummyarray,e2,gk2,l-1,his_anz,
                        his_anz-1,&connfl);
                }
                if (erg==his_anz) {    /* Konstruktion hat geklappt */
                  wh = True;
                  if (!recover &&
                     (!facerestrict || flaechenzahlen3_ok(e1,e2,nil))) {
                    start = 0;  arraypos = 0;
                    konstruiere_patch(patchmap1,&start,dummyarray,
                                      e1,gk1,nil,&connfl,&arraypos);
                    bestimme_gute_basen(e1);
                    bestimme_gute_basen(e2);
                    graphenzahl[ARRAYPOS_LN(g,n,2)]++;
                    gk1[0] = verknuepfe_sandwichpatches(gk1[0],gk2[0],gk2[1],
                             len12-len2,len2,len23-len2,&code3[0],i,fall);
                    /* gk2[1] und gk1[0] duerfen nicht vertauscht werden, 
                       denn gk1[0] spielt die Rolle von Nebenrand 2 */
                    sandwich_minimalitaetstest(gk1[0]->next,True,n,g,e1,e2,
                                               nil,fall>2,31,False,0);
                    /* festlegen=True, denn die Patches von Rand 1 und Rand 2
                       stammen immer aus unterschiedlichen Listen und werden
                       nicht vertauscht. */
                  }
                }
                else {e1 = nil;}  /* Schleife beenden, da "e2" schlecht */
                if (e1) {e1 = e1->next;} 
                if (!recover && (save_flag || save_flag2)) 
                   {speichere_graphen_aus_outputliste_in_files(his_anz,
                    0,3,1,len12,len2,len23,0,0,n,0,0,g,krit1,0,0);}
                if (recover && nebenzweig[0]==recovernebenzweig[0]) 
                   {recover = False;   count = recovercount;}
                nebenzweig[0]++;
                if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
              }    /* while e1 */
            } while (l = setze_history_weiter(his_anz,MIN(erg,his_anz-1),pco));
          }    /* if */
        }      /* if passen Sandwichcodes */

        /* --- 3.2: zweiter Rand in "e2" ist fuer Nebenrand --- */
        /* Dieser Fall wird nicht durchlaufen, wenn die beiden Raender in
           Patch 1 isomorph sind, weil dann eine Dopplung gegenueber
           Fall 3.1 auftritt. */
	if (do_sandwich && nebenrand2 && hauptrand1 && 
            ((!l1_sandwich && !digon_path) ||
            (g1==0 && fl1==1 && codelen1==2 && code1[0]==0)) &&    
            (len12 = (code1[0]<<1)+codelen1)>1 &&
            (!recover || (submgl_rec==2 && len12==l1_rec &&
            (code3[0]<<1)+codelen3==l3_rec)) &&
            (fall = passen_sandwichcodes(code1,
            codelen1,code3,codelen3,code2,codelen2,&i,&k))) {  
          len23 = (code3[0]<<1)+codelen3;
          len2 = (k<<1)+1;
          if (!recover || len2==l2_rec) {
            gleiche_randcodes = (codelen2==codelen3 && code2[0]==code3[0]);
                                /* Randcodes in Patch 2 gleich? */
            l = 1;
            if (pco) {
              for (ii=0; ii<his_anz; ii++) {his_check_pos[ii] = 0;}
              starte_history(his_anz);
            }
            nebenzweig[0] = 0L;       
            do {
              iso = -1;
              e1 = t2[2+codelen1]->weiter.firstpatch;   wh = False;
              while (e1) {
                start = 0;  connfl = 0;  arraypos = 0;
                if (wh || pco) 
                   {konstruiere_patch(patchmap2,&start,dummyarray,e2,
                    gk2,nil,&connfl,&arraypos);}
                else {
                  erg = konstruiere_patch_in_rekursion(patchmap2,
                        &start,dummyarray,e2,gk2,l-1,his_anz,
                        his_anz-1,&connfl);
                }
                if (erg==his_anz) {    /* Konstruktion hat geklappt */
                  wh = True;
                  if (!recover &&
                     (!facerestrict || flaechenzahlen3_ok(e1,e2,nil))) {
                    start = 0;  arraypos = 0;
                    if (iso==-1) {iso = gleiche_randcodes ? 
                                        (char)iso_raender(e2,0,1) : 0;}
                    if (!iso) {    /* keine Dopplung gegenueber Fall 3.1 */
                      konstruiere_patch(patchmap1,&start,dummyarray,
                                        e1,gk1,nil,&connfl,&arraypos);
                      bestimme_gute_basen(e1);
                      bestimme_gute_basen(e2);
                      graphenzahl[ARRAYPOS_LN(g,n,2)]++;
                      gk1[0] = verknuepfe_sandwichpatches(gk1[0],gk2[1],gk2[0],
                               len12-len2,len2,len23-len2,&code2[0],i,fall);
                      sandwich_minimalitaetstest(gk1[0]->next,True,n,g,e1,e2,
                                                 nil,fall>2,32,False,0);
                      /* festlegen=True, denn die Patches von Rand 1 und Rand 2
                         stammen immer aus unterschiedlichen Listen und werden
                         nicht vertauscht. */
                    }
                  } 
                }
                else {e1 = nil;}  /* Schleife beenden, da "e2" schlecht */
                if (e1) {e1 = e1->next;} 
                if (!recover && (save_flag || save_flag2)) 
                   {speichere_graphen_aus_outputliste_in_files(his_anz,
                    0,3,2,len12,len2,len23,0,0,n,0,0,g,krit1,0,0);}
                if (recover && nebenzweig[0]==recovernebenzweig[0]) 
                   {recover = False;   count = recovercount;}
                nebenzweig[0]++;
                if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
              }    /* while e1 */
            } while (l = setze_history_weiter(his_anz,MIN(erg,his_anz-1),pco));
          }    /* if */
        }      /* if passen Sandwichcodes */

        /* bei der Brille kann Nebenrand nicht isomorph zum Hauptrand sein */
	if (do_brille && nebenrand2 && hauptrand1 && 
           ((!loop_brille && !digon_brille && !digon_path) || 
            (g1==0 && fl1==1 && 
             codelen1<=1+(KNOTENTYP)(digon_brille) && code1[0]==0)) &&
           (!recover || (submgl_rec==3 && (code1[0]<<1)+codelen1==l1_rec &&
           (code3[0]<<1)+codelen3==l3_rec)) &&
           (fall = passen_brillencodes(code1,
            codelen1,code3,codelen3,code2,codelen2,&i,&k))) {  
          len = (k<<1) + (fall<5);
          if (!recover || len==l2_rec) {
            l = 1;
            if (pco) {
              for (ii=0; ii<his_anz; ii++) {his_check_pos[ii] = 0;}
              starte_history(his_anz);
            }
            nebenzweig[0] = 0L;
            do {
              e1 = t2[2+codelen1]->weiter.firstpatch;    wh = False;
              while (e1) {
                start = 0;  connfl = 0;  arraypos = 0;
                if (wh || pco) 
                   {konstruiere_patch(patchmap2,&start,dummyarray,e2,
                    gk2,nil,&connfl,&arraypos);}
                else {
                  erg = konstruiere_patch_in_rekursion(patchmap2,
                        &start,dummyarray,e2,gk2,l-1,his_anz,
                        his_anz-1,&connfl);
                }
                if (erg==his_anz) {    /* Konstruktion hat geklappt */
                  wh = True;
                  if (!recover &&
                     (!facerestrict || flaechenzahlen3_ok(e1,e2,nil))) {
                    start = 0;  arraypos = 0;
                    konstruiere_patch(patchmap1,&start,dummyarray,
                                      e1,gk1,nil,&connfl,&arraypos);
                    bestimme_gute_basen(e1);
                    bestimme_gute_basen(e2);
                    graphenzahl[ARRAYPOS_LN(g,n,3)]++;
                    gk1[0] = verknuepfe_brillenpatches(gk1[0],gk2[1],gk2[0],
                             (code1[0]<<1)+codelen1,(code3[0]<<1)+codelen3,len,
                             &code2[0],i,fall);
                    brillen_minimalitaetstest(gk1[0],True,n,g,e1,e2,nil,31,0);
                    /* festlegen=True, denn die Patches von Rand 1 und Rand 2
                       stammen immer aus unterschiedlichen Listen und werden
                       nicht vertauscht. */
                  }
                } 
                else {e1 = nil;}  /* Schleife beenden, da "e2" schlecht */
                if (e1) {e1 = e1->next;} 
                if (!recover && (save_flag || save_flag2)) 
                   {speichere_graphen_aus_outputliste_in_files(his_anz,
                    0,3,3,(code1[0]<<1)+codelen1,len,(code3[0]<<1)+
                    codelen3,0,0,n,0,0,g,krit1,0,0);}
                if (recover && nebenzweig[0]==recovernebenzweig[0]) 
                   {recover = False;   count = recovercount;}
                nebenzweig[0]++;
                if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
              }    /* while e1 */
            } while (l = setze_history_weiter(his_anz,MIN(erg,his_anz-1),pco));
          }      /* if */
        }        /* if passen Brillencodes */
        /* Ende des um 10 Stellen eingerueckten Textes */

                }  /* if */
                t2[3]=t2[3]->next;
              }    /* while t2[3] */
	    }      /* if */             
            t2[2]=t2[2]->next;
          }      /* while t2[2] */
        }        /* if */
        t2[1]=t2[1]->next;
      }          /* while t2[1] */  
    }            /* if t2[0] */
  }              /* if passt "e2" */
}

/***********BILDE_GRAPHEN_AUS_BRUCHKANTENPATCHES3_IN_REKURSION**************/
/*  Bildet Graphen aus 1 Bruchkantenpatch "e1". "e1" 
    besitzt genau drei Raender. Diese Raender enthalten Bruchkanten.
    "e1" hat Geschlecht "g1", "krit1" kritische Punkte und 
    "fl1" Flaechen sowie den Bordercode "code". Die 
    resultierenden Graphen besitzen "n" Knoten und Geschlecht "g".
    Weitere Kommentare siehe "bilde_graphen_aus_bauchbindenpatches".       */

void bilde_graphen_aus_bruchkantenpatches3_in_rekursion(KNOTENTYP g,
  KNOTENTYP n,
  KNOTENTYP g1,KNOTENTYP krit1,KNOTENTYP fl1,ELEM *e1,KNOTENTYP *code,
  POSTYP his_anz) {
  static KNOTENTYP fl;           /* Anzahl Flaechen im erzeugten Graphen */
  static KNOTENTYP code1[8], code2[8], code3[8];  
         /* Randcodes (bei Bedarf zweimal hintereinander) */
  static KNOTENTYP codelen1,codelen2,codelen3; 
         /* Randcodelaengen der einzelnen Patches */

  fl = (n>>1)+2-(g<<1);

  if (g1+2==g && fl1==fl && krit1>=krit_min && krit1<=krit_max && 
      code[4]==11) {
     /* Patchdaten passen (code[4]==11 => insgesamt 6 Bruchkanten => jeder
        Rand hat hoechstens 4 Bruchkanten (da jeder Rand mindestens eine
        Bruchkante hat) */
    codelen1 = code[2]-code[1];
    codelen2 = code[3]-code[2];
    codelen3 = code[4]-code[3];
    memcpy(code1,&code[code[1]],sizeof(KNOTENTYP)*codelen1);
    memcpy(code2,&code[code[2]],sizeof(KNOTENTYP)*codelen2);
    memcpy(code3,&code[code[3]],sizeof(KNOTENTYP)*codelen3);
    /* Alle Moeglichkeiten fuer den Hauptrand durchgehen: */
    if (!recover || mgl_rec==41) {
      bruchkanten_moeglichkeit4_in_rekursion(1,2,3,n,g,code1,codelen1,code2,
        codelen2,code3,codelen3,e1,his_anz,krit1,41);
    }
    if (!recover || mgl_rec==42) {
      bruchkanten_moeglichkeit4_in_rekursion(1,3,2,n,g,code1,codelen1,code3,
        codelen3,code2,codelen2,e1,his_anz,krit1,42);
    }
    if (!recover || mgl_rec==43) {
      bruchkanten_moeglichkeit4_in_rekursion(2,3,1,n,g,code2,codelen2,code3,
        codelen3,code1,codelen1,e1,his_anz,krit1,43);
    }
  }
}

/***********BILDE_GRAPHEN_AUS_SANDWICHPATCHES4_IN_REKURSION*****************/
/*  Bildet Graphen aus 1 Sandwichpatch "e1". "e1" 
    besitzt genau einen Rand. Dieser Rand enthaelt sechs Bruchkanten.
    "e1" hat Geschlecht "g1", "krit1" kritische Punkte und 
    "fl1" Flaechen sowie den Bordercode "code". Die 
    resultierenden Graphen besitzen "n" Knoten und Geschlecht "g".
    Weitere Kommentare siehe "bilde_graphen_aus_bauchbindenpatches".       */

void bilde_graphen_aus_sandwichpatches4_in_rekursion(KNOTENTYP g,KNOTENTYP n,
  KNOTENTYP g1,KNOTENTYP krit1,KNOTENTYP fl1,ELEM *e1,KNOTENTYP *code,
  POSTYP his_anz) {
  static KNOTENTYP fl;           /* Anzahl Flaechen im erzeugten Graphen */
  static KNOTENTYP *code2;

  fl = (n>>1)+2-(g<<1);

  if (g1+1==g && fl1==fl && krit1>=krit_min && krit1<=krit_max) {
    code2 = &code[3];       /* Zeiger auf ersten Randcodeeintrag */
    /* Im folgenden jeweils erste Bedingung, damit l1<=l3
       (so dass nicht Bild und Spiegelbild genommen werden) */ 
    if ((!recover || mgl_rec==51) &&
        (code2[1]<=code2[5] && code2[2]==0 && code2[4]==0 &&
         code2[0]==code2[1]+code2[3]+code2[5]+3))      /* Fall 1 */
       {sandwich_moeglichkeit5_in_rekursion(1,n,g,code2,e1,his_anz,51);}
    if ((!recover || mgl_rec==52) &&
        (code2[1]<=code2[4] && code2[3]==0 && code2[5]==0 &&
         code2[0]==code2[1]+code2[2]+code2[4]+2))      /* Fall 2 */
       {sandwich_moeglichkeit5_in_rekursion(2,n,g,code2,e1,his_anz,52);}
    if ((!recover || mgl_rec==53) &&
        (code2[2]<code2[5] && code2[1]==0 && code2[3]==0 &&
         code2[0]==code2[2]+code2[4]+code2[5]+2))      /* Fall 3 */
       /* Wichtig: code2[2] echt kleiner code2[5], da sonst l1==l3+1 */
       {sandwich_moeglichkeit5_in_rekursion(3,n,g,code2,e1,his_anz,53);}
    if ((!recover || mgl_rec==54) &&
        (code2[2]<=code2[4] && code2[1]==0 && code2[5]==0 &&
         code2[0]==code2[2]+code2[3]+code2[4]+1))      /* Fall 4 */
       {sandwich_moeglichkeit5_in_rekursion(4,n,g,code2,e1,his_anz,54);}
  }
}

/******************SUCHE_GEGENSTUECKE***************************************/
/*  Sucht Gegenstuecke zu einem brauchbaren Patch, dessen Daten in der 
    history an der Stelle his_anz-1 stehen ("his_anz" enthaelt also die
    Anzahl der Eintraege in "history"). Der Patch hat Genus "g1", "fl1"
    Flaechen, "krit1" kritische Punkte und den Bordercode "code".           
    Falls es Gegenstuecke gibt, so werden an Ort und Stelle Karten 
    generiert.                                                             */

void suche_gegenstuecke(KNOTENTYP g1,KNOTENTYP fl1,KNOTENTYP krit1,
     KNOTENTYP *code,POSTYP his_anz) {
  static KNOTENTYP g;     /* Genus der Zielkarten */
  static KNOTENTYP n;     /* Knotenzahl in den Zielkarten */
  static BOOL hauptrand1,nebenrand1,hauptrand2,nebenrand2;
         /* zeigt die Rollen an, die die Raender einnehmen koennen */
  static KNOTENTYP anz_bb;    /* Anzahl Bauchbinden im Patch */
  static KNOTENTYP codelen1,codelen2,codelen3;
  static POSTYP i;
  static FLAECHENTYP f;
 
  if (code[0]>3) {return;}    /* zu viele Raender => hier unbrauchbar */ 
  if ((anz_bb = ermittle_anz_bb(code))>0 && anz_bb<code[0]) {return;}
     /* Patch mit Bauchbinden- und Bruchkantenraendern -> ergibt keine Karte */
  if (anz_bb==0 && (do_sandwich || do_brille)) {    /* Randzuordnungen */
    hauptrand1 = nebenrand1 = hauptrand2 = nebenrand2 = False;
    codelen1 = code[2]-code[1];
    if (codelen1==1 || (codelen1==2 && code[code[1]+1]==0))
       {nebenrand1 = True;}       /* Rand 1 kann Nebenrand sein */
    if (codelen1==2 || 
       (codelen1==3 && (code[code[1]+1]==0 || code[code[1]+2]==0)) ||
       (codelen1==4 && code[code[1]+1]==0 && code[code[1]+3]==0))  
       {hauptrand1 = True;}       /* Rand 1 kann Hauptrand sein   */  
    if (code[0]>1) {      /* mindestens 2 Raender   */
       codelen2 = code[3]-code[2];
       if (codelen2==1 || (codelen2==2 && code[code[2]+1]==0))
          {nebenrand2 = True;}         /* Rand 2 kann Nebenrand sein */
       if (codelen2==2 || 
          (codelen2==3 && (code[code[2]+1]==0 || code[code[2]+2]==0)) ||
          (codelen2==4 && code[code[2]+1]==0 && code[code[2]+3]==0))
	  {hauptrand2 = True;}       /* Rand 2 kann Hauptrand sein */
       if (code[0]==2) {
         if (!(hauptrand1 && nebenrand2) && !(nebenrand1 && hauptrand2) && 
             !(nebenrand1 && nebenrand2)) {return;}   /* hier unbrauchbar */
       }
       else  /* code[0]==3 */ if ((!hauptrand1 && !nebenrand1) ||
                                  (!hauptrand2 && !nebenrand2)) {return;}
    }
    else if (!hauptrand1 && !nebenrand1 && (codelen1!=6 || !do_sandwich)) 
            {return;}   /* Patch hier unbrauchbar */
  }
  else if (anz_bb==0 || !do_bauchbinde) {return;}  /* Patch hier unbrauchbar */

  memcpy(hiscopy,history,sizeof(ELEM)*(size_t)his_anz);

  /* gueltige Flaechenzahlen errechnen:  Muss vor der ersten Konstruktion
     eines Patches geschehen, da die Flaechenzahlen benutzt werden, um zu
     pruefen, ob ein Patch ueberhaupt konstruiert werden muss. Fuer den
     ersten Durchlauf werden die Flaechenzahlen hier ermittelt, fuer alle
     weiteren Durchlaeufe in der Funktion "setze_history_weiter". */
  if (facenumbers) {
    for (i=0; i<his_anz; i++) {
      if (history[i].prev2) {
        for (f=0; f<anz_face; f++) 
          {(history[i].flaechenzahl)[f] = 
           ((history[i].prev1)->flaechenzahl)[f] + 
           ((history[i].prev2)->flaechenzahl)[f];}
      }
      else {memcpy(history[i].flaechenzahl,(history[i].prev1)->flaechenzahl,
            sizeof(KNOTENTYP)*(size_t)anz_face);}
    } 
  }

  for (g = recover ? g_rec : genus_anf; g<=genus_end; g++) {   
      /* erlaubte Geschlechter */    
    for (n = recover ? n_rec : n_anf; n<=n_end; n+=2) {      
      /* erlaubte Knotenzahlen */
      if (is_moeglich[ARRAYPOS_N(g,n)]) {   /* um negative Werte fuer "fl" 
                              in den aufzurufenen Funktionen zu vermeiden */
        if (anz_bb>0) {     /* => do_bauchbinde==True (siehe oben); BB-Patch */
          if (bauchbindenkennung<3 || g>0 || n%4==0) {  
             /* ein BB-Pfad kann am bestbewertetsten sein */
            if (code[0]==1) 
               {bilde_graphen_aus_bauchbindenpatches1_in_rekursion(g,n,g1,
                krit1,fl1,&history[his_anz-1],code,his_anz);}
            else {bilde_graphen_aus_bauchbindenpatches2_in_rekursion(g,n,g1, 
                  krit1,fl1,&history[his_anz-1],code,his_anz);}
          }
        }
        else {     /* => (do_sandwich || do_brille)==True (s.o.);  BK-Patch */
          switch (code[0]) {     /* Anzahl Raender */
            case 1: {
              if (codelen1==6 && do_sandwich && !l1_sandwich && !digon_path) 
                 {bilde_graphen_aus_sandwichpatches4_in_rekursion(g,n,g1,
                  krit1,fl1,&history[his_anz-1],code,his_anz);}
              else if (codelen1<=4) 
                 {bilde_graphen_aus_bruchkantenpatches1_in_rekursion(g,n,g1,
                  krit1,fl1,&history[his_anz-1],code,hauptrand1,nebenrand1,
                  his_anz);}
              break;
            }  
	    case 2: {
              bilde_graphen_aus_bruchkantenpatches2_in_rekursion(g,n,g1,krit1,
                fl1,&history[his_anz-1],code,hauptrand1,nebenrand1,
                hauptrand2,nebenrand2,his_anz);
              break;
            }
            case 3: {
              if (!digon_path && ((do_sandwich && !l1_sandwich) || 
                  (do_brille && !loop_brille && !digon_brille)))
                 {bilde_graphen_aus_bruchkantenpatches3_in_rekursion(g,n,g1,
                  krit1,fl1,&history[his_anz-1],code,his_anz);}
              break;
            }
          }     /* switch */
        }       /* else */
      }         /* if is_moeglich */
    }     /* for n */
  }       /* for g */
}


/******************************************/
/* Funktionen zum Generieren der Patches: */
/******************************************/

/***********************ORDNE_PATCH_IN_BAUM**********************************/
/*   Nimmt einen Patch in den zugehoerigen Patchbaum auf.                   */
/*   fl = Anzahl der Flaechen im Patch                                      */
/*   g = Genus des Patches                                                  */
/*   elem: Informationen ueber die Vorgaenger (muss kopiert werden)         */
/*   facearray:  Anzahlen der einzelnen Flaechen                            */
/*   krit:  Anzahl der kritischen Flaechen im Patch (0, falls alternativ)   */
/*   Rueckgabewert:   erfolgreich eingeordnet                               */

BOOL ordne_patch_in_baum(ELEM *elem,KNOTENTYP *bordercode,KNOTENTYP g,
  KNOTENTYP fl,KNOTENTYP *facearray,KNOTENTYP krit) {
  static int l,len;       /* l = Zeiger auf aktuelle Stelle im Bordercode */
  static TREENODE *t, *t2, *t3, *t4; 
    /* t = aktuell, t2 = Vorgaenger, t3 = neu, t4 = letzte Wurzel */
  static ELEM *e;
  
  /* erster Level: Genus */
  t = tree[fl];   t2 = nil;
  while (t && t->code<g) {t2=t; t=t->next;}
  if (t==nil || t->code!=g) {   /* neuen Baumknoten einrichten */
  if (!(t3 = (TREENODE *)hole_speicher(sizeof(TREENODE),memory_used,!topdown)))
     {return(False);}
  if (t2==nil) {tree[fl] = t3;} else {t2->next = t3;}
    t3->next = t;    t3->code = g;    t3->weiter.nextlevel = nil;
    t = t3;       /* von hier aus weitergehen */
  }
  /* zweiter Level: Anzahl der kritischen Flaechen */
  t4 = t;   t2 = nil;   t = t->weiter.nextlevel;
  while (t && t->code<krit) {t2=t; t=t->next;}
  if (t==nil || t->code!=krit) {   /* neuen Baumknoten einrichten */
    if (!(t3 = (TREENODE *)hole_speicher(sizeof(TREENODE),memory_used,
        !topdown))) {return(False);}
    if (t2==nil) {t4->weiter.nextlevel = t3;} else {t2->next = t3;}
    t3->next = t;    t3->code = krit;    t3->weiter.nextlevel = nil;
    t = t3;       /* von hier aus weitergehen */
  }
  /* weitere Level: Bordercode */
  l = 0;   len = bordercode[bordercode[0]+1];
  while (l<len) {         /* noch nicht am Ende des Codes */
    t4 = t;  t = t->weiter.nextlevel;  t2 = nil;
    while (t && t->code<bordercode[l]) {t2=t; t=t->next;}
    if (t==nil || t->code!=bordercode[l]) { /* neuen Baumknoten einrichten */
      if (!(t3 = (TREENODE *)hole_speicher(sizeof(TREENODE),memory_used,
          !topdown))) {return(False);}
      if (t2==nil) {t4->weiter.nextlevel = t3;} else {t2->next = t3;}
      t3->next = t;
      t3->code = bordercode[l];   t3->weiter.nextlevel = nil;
      t = t3;        /* t ist Anfang der Liste, in die eingeordnet wird */
    }      /* if */
    l++;
  }        /* while */

  if (!(e = (ELEM *)hole_speicher(sizeof(ELEM),memory_used,!topdown)))
     {return(False);}
  memcpy(e,elem,sizeof(ELEM));
  e->next = t->weiter.firstpatch;  e->flaechenzahl = facearray;
  e->stamm = True;   
  e->vorg = 0;
  t->weiter.firstpatch = e; 
  /* markiere_non_iso_raender(e,bordercode); */ /* geschieht woanders,
     naemlich in der Funktion "muss_patch_konstruiert_werden" */
  /* Statistik: */
  e->test = 0;
  /* e->nr = patches+1; */
  if (elem->prev1) {nahttyp[elem->art]++;}
  patch_anz[ARRAYPOS_F(g,fl)]++;    patches++;
  if (patches==ULONG_MAX) 
     {logfile_entry((char *)"Warning:  Patch number exceeds"
                            " maximum!\n",True,True,False);}  

  /* Pruefung (Testzwecke): */
  /* if (patches%100000==0) {fprintf(stderr,"%d patches ",patches);} */
  return(True);
}  
   
/**********************VERKLEBUNG********************************************/
/* Verknuepft einen oder zwei Patches entlang eines Durchschnittpfades oder
   eines Einschlusspfades (vereinigt die beiden Funktionen "verknuepfung" 
   und "einschluss" aus dem Programm CPF), nicht jedoch fuer Fall 1.
   Variablen siehe "verknuepfe_patches".                                    */
/* Im Gegensatz zu CPF.c existiert der Parameter "gedreht" nicht mehr.
   Seine Einhaltung wird in den aufrufenden Funktionen ueberprueft.         */
/* "e1" und "e2" sind die ersten Patches in Patchlisten mit gleichen
   Bordercodes. Falls innerhalb der Rekursion "e1" oder "e2" auf einen
   Eintrag in der history zeigt, so ist die Patchliste nur implizit 
   vorhanden.                                                               */
/* Wenn nur 1 Patch mit sich selbst verklebt wird, so ist paar==False.      */
/* Falls his_anz>0 => die Rekursion kann ohne Test aufgerufen werden,
   da die Funktion bereits aus der Rekursion kommt und der Test somit 
   bereits einmal richtig war. his_anz>0 <=> Funktion wird aus Rekursion
   aufgerufen.                                                              */ 
/* g,fl = Genus und Flaechenzahl in den Ergebnispatches                     */
/* Returnwert False => Speicher ist voll                                    */

BOOL verklebung(BORDERPOS i,ELEM *e1,BORDERPOS j,ELEM *e2,
     KNOTENTYP g,KNOTENTYP fl,KNOTENTYP *ergcode,
     unsigned char art,POSTYP his_anz,KNOTENTYP krit,BOOL paar,
     KNOTENTYP nahtlen,KNOTENTYP ziellen) {
  static ELEM *ee2,e;
  static KANTE *gk[G_MAX+1];      /* fuer Grundkanten */
  static KNOTENTYP *facearray;    /* fuer die neuen Flaechenzahlen */
  static FLAECHENTYP f;
  static KNOTENTYP wh;            /* fuer Rand 2 von Fall 1 */
  static KNOTENTYP anz_bb;

  if ((anz_bb = ermittle_anz_bb(ergcode))>0 && !do_bauchbinde) {return(True);}
      /* denn ein Bauchbindenrand kann nur durch 
         Bauchbindenverklebung verschwinden */
      /* Reihenfolge der Bedingungen wichtig, denn "anz_bb" wird spaeter
         noch gebraucht, muss also auf jeden Fall ermittelt werden */

  /* Gegenstuecke zu brauchbaren Patches suchen und
     rekursiv weitere Verklebungsmoeglichkeiten suchen:   */
  if (pv>9 && !topdown &&            /* Vollstaendigkeitskriterium anwenden */
     (rekursion  ||  krit<<1 > krit_max  ||               /* ueber'n Berg 1 */
     (krit<<1==krit_max && (fl<<1 > f_max[genus_anf]  ||  /* ueber'n Berg 2 */
     (fl<<1==f_max[genus_anf] && g<<1 > genus_end))))) {  /* ueber'n Berg 3 */
     /* man beachte:  alternative==TRUE => krit<<1==krit_max */
     /* Gegenstuecke fuer Patches UND Graphen stehen fest, Rekursion */
    rekursion = True;        /* einmal ueber'n Berg - immer ueber'n Berg */
     /* allerdings darf "rekursion" nicht in die Schleife in 
        "generiere_patches" einfliessen, denn es koennten ja beide Vorgaenger
        eines History-Patches Stammpatches sein, und dann wird ein solcher
        History-Patch aus der Schleife in "generiere_patches" aus generiert. */
    history[his_anz].prev1 = e1;   history[his_anz].prev2 = paar ? e2 : nil;
    history[his_anz].i = i;        history[his_anz].j = j;
    history[his_anz].art = art;    /* ".next" und ".stamm" steht fest */ 
    history[his_anz].nahtlen = nahtlen;
    history[his_anz].ziellen = ziellen;
    if (level==his_anz) {count++;   count = count%mod;}
    if ((!recover || 
        (recover_hislen>0 && zweig[his_anz]==recoverzweig[his_anz])) &&
        (recover || !mod_used || level!=his_anz || count==class) &&
        /* tiefer */ 
        (!patchcheck || patch_check(his_anz+1))) {  /* Patch(es) benutzen */
      /* Recover-Abfrage und class-Abfrage vor Patchcheck, um sich diesen 
         beim Recovern zu ersparen. "recover_hislen" ist 0, falls die gesamte 
         Rekursion bereits vorbei ist und nur noch Karten aus vorhandenen 
         Patches erzeugt werden muessen. */
      if ((!recover || his_anz+1==recover_hislen) &&
          (recover || !mod_used || level<=his_anz || class==0))
         {suche_gegenstuecke(g,fl,krit,ergcode,his_anz+1);}
         /* bei Aufteilung alles unterhalb des Levels in erste Klasse */
      zweig[his_anz+1] = 0L;
      gehe_patchbaum_durch_in_rekursion(ergcode,g,fl,krit,his_anz+1); 
    }
    zweig[his_anz]++;
    if (zweig[his_anz]==ULONG_MAX) {zweig_error(his_anz);}
    return(True);     /* alle Verklebungen bereits durchgefuehrt */
  }

  /* ab hier gilt: die Patches sind brauchbar oder mittelbar brauchbar
     oder nicht eindeutig unbrauchbar */
  /* Bis hierhin kommt die Funktion nicht innerhalb einer Rekursion, zudem 
     wird von hier aus keine weitere Rekursion eingeleitet
     => die zugehoerigen Variablen koennen "static" sein */

  if (paar) {                     /* 2 Patches */
    while (e1) {
      if (NON_ISO_RAND(e1,i.nr)) {        /* Rand darf verklebt werden */
        ee2 = e2;                         /* Listenanfang */
        while (ee2) {
          if (NON_ISO_RAND(ee2,j.nr) && (!facerestrict ||
              (flaechenzahlen2_ok(e1,ee2) &&
              (/*pv<4 || */flaechenvorausschau_ok(e1,ee2,g,fl,ergcode[0],
                       ERMITTLE_FD(g,ergcode)))))) {
            e.prev1 = e1;  e.prev2 = ee2;  e.i = i;  e.j = j;  e.art = art; 
            e.nahtlen = nahtlen;           e.ziellen = ziellen;
            /* bei art==DRUCHSCHNITT ist nur "nahtlen" wichtig, bei 
               art==EINSCHLUSS nur "ziellen" */
            /* e.next ist unwichtig fuer "muss_patch_konstruiert_werden" */
            if (muss_patch_konstruiert_werden(&e,art==EINSCHLUSS,ergcode,False,
                0,nil,False,gk,False,True,True,0)) {
              if (facenumbers) {
                if (!(facearray = (KNOTENTYP *)hole_speicher(sizeof(KNOTENTYP)*
                     (size_t)anz_face,memory_used,!topdown)))
                   {return(False);}
                for (f=0; f<anz_face; f++) {facearray[f] = 
                    (e1->flaechenzahl)[f] + (ee2->flaechenzahl)[f];}
              }
              else {facearray = nil;} 
              if (!ordne_patch_in_baum(&e,ergcode,g,fl,facearray,krit))
                 {return(False);}
            }
          }
          ee2 = ee2->next;
        }
      }
      e1 = e1->next;
    }
  }
  else {                          /* 1 Patch */
    while (e1) {
      /* Flaechenzahlen unveraendert => keine Ueberpruefung */
      /* Zur zweiten Bedingung:  Die beiden Raender duerfen verklebt werden,
         wenn sie nicht isomorph zu anderen (Vorgaenger-)Raendern sind 
         (wie bisher). Ausnahme: Wenn Rand 2 zu Rand 1 isomorph ist, so duerfen
         diese ebenfalls verklebt werden. Wenn es jedoch mehrere zu Rand 1 
         isomorphe Raender gibt, so darf diese Verklebung nur einmal 
         vorgenommen werden. Dies wird dadurch sichergestellt, dass Rand 2 der
         direkt auf Rand 1 folgende Rand sein muss (dadurch wird insbesondere
         vermieden, dass Rand 1 mit Rand 2 UND UMGEKEHRT verklebt wird) und
         Rand 1 nicht isomorph zu seinen Vorgaengern sein darf. */
      if (NON_ISO_RAND(e1,i.nr) && (!facerestrict || ((anz_bb<2 ||
           flaechenzahlen_ok(e1)) && (/*pv<4 ||*/ 
           flaechenvorausschau_ok(e1,nil,g,fl,ergcode[0],
             ERMITTLE_FD(g,ergcode)))))) {
        e.prev1 = e1;  e.prev2 = nil;  e.i = i;  e.j = j;  e.art = art; 
        e.nahtlen = nahtlen;           e.ziellen = ziellen;
        /* e.prev2 = e2  waere falsch, da e2==e1!=nil gilt */
        /* e.next ist unwichtig fuer "muss_patch_konstruiert_werden" */
        /* falls anz_bb==2, so steht fest, dass der Patch nur noch mit sich
           selbst verklebt werden kann, also Flaechenzahlen ueberpruefen */
        if (muss_patch_konstruiert_werden(&e,True,ergcode,False,0,nil,
                                          False,gk,False,True,True,0)) {
          if (facenumbers) {
            if (!(facearray = (KNOTENTYP *)hole_speicher(sizeof(KNOTENTYP)*
                (size_t)anz_face,memory_used,!topdown))) {return(False);}
            memcpy(facearray,e1->flaechenzahl,
                   sizeof(KNOTENTYP)*(size_t)anz_face);
          }
          else {facearray = nil;} 
          if (!ordne_patch_in_baum(&e,ergcode,g,fl,facearray,krit))
             {return(False);}
        }
      }
      e1 = e1->next;
    }
  } 
  return(True);
}

/**********************VERKLEBUNG_FALL1**************************************/
/* Verknuepft einen Patch entlang eines Verbindungspfades gemaess Fall 1.
   Variablen siehe "verknuepfe_patch_fall1".                                */
/* Falls his_anz>0 => die Rekursion kann ohne Test aufgerufen werden,
   da die Funktion bereits aus der Rekursion kommt und der Test somit 
   bereits einmal richtig war. his_anz>0 <=> Funktion wird aus Rekursion
   aufgerufen.                                                              */ 
/* g,fl = Genus und Flaechenzahl in den Ergebnispatches                     */
/* Im Array "akzeptiert" wird festgehalten, welche moeglichen Markierungen
   in Rand 2 bereits akzeptiert wurden.                                     */

BOOL verklebung_fall1(BORDERPOS i,ELEM *e1,BORDERPOS j,KNOTENTYP g,
     KNOTENTYP fl,KNOTENTYP *ergcode,POSTYP his_anz,KNOTENTYP krit,
     KNOTENTYP nr2,KNOTENTYP rl2,KNOTENTYP rlg2,KNOTENTYP jj,KNOTENTYP nahtlen,
     KNOTENTYP ziellen) {
  static ELEM e;
  static KANTE *gk[G_MAX+1];      /* fuer Grundkanten */
  static KNOTENTYP *facearray;    /* fuer die neuen Flaechenzahlen */
  static KNOTENTYP ii,wh;         /* "wh" fuer Rand 2 von Fall 1 */
  static KNOTENTYP anz_bb;
  static unsigned char akzeptiert[ACCEPTLEN];
         /* Fuer jede moegliche Markierung in Rand 2 ein Bit, das angibt, ob
            die Markierung akzeptiert wird oder nicht. N_MAX_P ist die 
            Maximalzahl Knoten in einem Patch, hoechstens jeder zweite Knoten
            kann markiert werden (bei Bauchbinde) => N_MAX_P/2 ist die
            Maximalzahl moeglicher markierter Knoten. */
 
  if ((anz_bb = ermittle_anz_bb(ergcode))>0 && !do_bauchbinde) {return(True);}
      /* denn ein Bauchbindenrand kann nur durch 
         Bauchbindenverklebung verschwinden */
      /* Reihenfolge der Bedingungen wichtig, denn "anz_bb" wird spaeter
         noch gebraucht, muss also auf jeden Fall ermittelt werden */

  /* Gegenstuecke zu brauchbaren Patches suchen und
     rekursiv weitere Verklebungsmoeglichkeiten suchen:   */
  if (pv>9 && !topdown &&            /* Vollstaendigkeitskriterium anwenden */
     (rekursion  ||  krit<<1 > krit_max  ||               /* ueber'n Berg 1 */
     (krit<<1==krit_max && (fl<<1 > f_max[genus_anf]  ||  /* ueber'n Berg 2 */
     (fl<<1==f_max[genus_anf] && g<<1 > genus_end))))) {  /* ueber'n Berg 3 */
     /* man beachte:  alternative==TRUE => krit<<1==krit_max */
     /* Gegenstuecke fuer Patches UND Graphen stehen fest, Rekursion */
    rekursion = True;        /* einmal ueber'n Berg - immer ueber'n Berg */
    history[his_anz].prev1 = e1;   history[his_anz].prev2 = nil;
    history[his_anz].i = i;        history[his_anz].j = j;
    history[his_anz].art = VERBINDUNG;  /* ".next" und ".stamm" stehen fest */ 
    history[his_anz].nahtlen = nahtlen;  
    history[his_anz].ziellen = ziellen;
    his_rl2[his_anz] = rl2;        his_rlg2[his_anz] = rlg2;
    if (level==his_anz) {count++;   count = count%mod;}
    if ((!recover || 
        (recover_hislen>0 && zweig[his_anz]==recoverzweig[his_anz])) &&
         /* tiefer */ 
        (recover || !mod_used || level!=his_anz || count==class) &&
        (!patchcheck || patch_check(his_anz+1))) {  /* Patch(es) benutzen */
      if ((!recover || his_anz+1==recover_hislen) &&
          (recover || !mod_used || level<=his_anz || class==0))
         {suche_gegenstuecke(g,fl,krit,ergcode,his_anz+1);}
      zweig[his_anz+1] = 0L;
      gehe_patchbaum_durch_in_rekursion(ergcode,g,fl,krit,his_anz+1); 
    }
    zweig[his_anz]++;
    if (zweig[his_anz]==ULONG_MAX) {zweig_error(his_anz);}
    return(True);
  }

  /* ab hier gilt: die Patches sind brauchbar oder mittelbar brauchbar
     oder nicht eindeutig unbrauchbar */
  /* Bis hierhin kommt die Funktion nicht innerhalb einer Rekursion, zudem 
     wird von hier aus keine weitere Rekursion eingeleitet
     => die zugehoerigen Variablen koennen "static" sein */
  while (e1) {  /* Flaechenzahlen unveraendert => keine Ueberpruefung */
    /* Bei Fall 1 bleibt Genus unveraendert => keine Flaechenvorausschau */
    if (NON_ISO_RAND(e1,i.nr) && (!facerestrict || anz_bb<2 ||
        flaechenzahlen_ok(e1))) {
      for (ii=0; ii<jj; ii++) {akzeptiert[ii] = 0;}  /* loeschen */ 
      e.prev1 = e1;  e.prev2 = nil;  e.i = i;  e.art = VERBINDUNG;  e.j = j;
      e.nahtlen = nahtlen;           e.ziellen = ziellen;
      /* WICHTIG:  e.j.nr bekommt bei jedem neuen Patch wieder den kleinsten
                   Wert */ 
      /* e.next ist unwichtig fuer "muss_patch_konstruiert_werden" */
      while (e.j.nr < rlg2) {    /* Gleichheit ist unmoeglich */ 
        if (muss_patch_konstruiert_werden(&e,True,ergcode,True,nr2,akzeptiert,
                                          False,gk,False,True,True,0)) {
          if (facenumbers) {
            if (!(facearray = (KNOTENTYP *)hole_speicher(sizeof(KNOTENTYP)*
                 (size_t)anz_face,memory_used,!topdown))) {return(False);}
            memcpy(facearray,e1->flaechenzahl,
                   sizeof(KNOTENTYP)*(size_t)anz_face);
          }
          else {facearray = nil;} 
          if (!ordne_patch_in_baum(&e,ergcode,g,fl,facearray,krit))
             {return(False);}
        }
        e.j.nr += rl2;      /* naechste moegliche Markierung */
      }
    }
    e1 = e1->next;
  }
  return(True);
}

/*********************VERKNUEPFE_PATCHES_IN_REKURSION***********************/
/* Prueft, ob Patches mit den Bordercodes "code1" und "code2" miteinander 
   verbunden werden koennen. "e1" und "e2" zeigen (implizit) auf Listen von
   Patches mit diesen Bordercodes.                                         */
/* Diese Funktion funktioniert wie die Funktion "verknuepfe_patches",
   benutzt jedoch nicht den Inhalt der Arrays "bind" und "anz", so dass 
   sie rekursiv eingesetzt werden kann. Deshalb sind die Variablen nicht
   static.                                                                 */
/* krit = Anzahl kritischer Flaechen in beiden Patches zusammen.           */
/* Da die Patcherzeugung bei Aufruf der Rekursion "ueber den Berg" ist,
   sind die zu "code1" und "code2" gehoerigen Listen immer verschieden.
   Deshalb kann bei Paaren ohne Einschraenkung gedreht werden 
   (Typen 2,3,8,9).
   "his_anz" enthaelt die Anzahl der Eintraege in "history".               */
/* ???? Optimierungsmoeglichkeiten durch Zusamenfassung der i.nr-Schleifen
   (dann kann einmal len1 ausgerechnet werden und immer wieder darauf
    zurueckgegriffen werden)                                               */

void verknuepfe_patches_in_rekursion(ELEM *e1,KNOTENTYP *code1,ELEM *e2,
     KNOTENTYP *code2,KNOTENTYP g,KNOTENTYP fl,KNOTENTYP krit,BOOL paar,
     POSTYP his_anz) {
  static BOOL dummy;
  BORDERPOS i,j;     /* Randcodenummern + Verschiebungen im Randcode */
  KNOTENTYP l,wh1,anf1,len1;
  KNOTENTYP *randcode2;  /* fuer 2 Randcodekopien von Patch 2 */
  KNOTENTYP len2,wh2;            /* zugehoerige Laenge und Periode */
  KNOTENTYP *ergrandcode;        /* fuer RANDcode (2 Kopien) */
  KNOTENTYP ergrandlen;               /* fuer RANDcode */
  KNOTENTYP *ergcode;            /* fuer BORDERcode */
  KNOTENTYP wh;        /* wh!=0 => kanonische Verknuepfung gefunden */  
  randcode2 = randcode2_vpr[his_anz-1];
  ergrandcode = ergrandcode_vpr[his_anz-1];
  ergcode = ergcode_vpr[his_anz-1];

  for (j.nr=0; j.nr<code2[0]; j.nr++) {  /* Randcodes von Patch 2 durchgehen */

    if (code2[code2[j.nr+1]]!=BB_KENNUNG) {    /* => Bruchkantenrand */
      len2 = code2[j.nr+2]-code2[j.nr+1];
      wh2 = ermittle_wh(&code2[code2[j.nr+1]],len2);    /* Wiederholungszahl */
      memcpy(randcode2,&code2[code2[j.nr+1]],sizeof(KNOTENTYP)*(size_t)len2);
      memcpy(&randcode2[len2],randcode2,sizeof(KNOTENTYP)*(size_t)len2);

      for (j.pos=0; j.pos<wh2; j.pos++) {
 
        /* ungeraden Durchschnitt testen: */
        if (len2>2 && randcode2[j.pos]==0) { 

          for (i.nr=0; i.nr<code1[0]; i.nr++) {
            if (paar || i.nr!=j.nr) {   /* Rand nicht mit sich selbst verkl. */
              anf1 = code1[i.nr+1];
              len1 = code1[i.nr+2]-anf1;

              if (len1==3 && len2==3) {  /* len1==3 => Rand 1 ist BK-Rand */
                /* Typ 1/3 => Bauchbinde entsteht */ 
                wh1 = ermittle_wh(&code1[anf1],len1);
                for (i.pos=0; i.pos<wh1; (i.pos)++) {
                  if (code1[anf1+i.pos]==0 && 
                      code1[anf1+(i.pos+1)%len1]==randcode2[j.pos+1]) {
                    ergrandcode[0] = BB_KENNUNG;
                    ergrandcode[1] = code1[anf1+(i.pos+len1-1)%len1] +
                                     randcode2[j.pos+len2-1] + 2;
                    ergrandlen = 2;
                    /* Patch 1 links */
                    if (sortiere_randcodes(i.nr,j.nr,False,code1,
                        paar ? code2 : nil,
                        ergrandcode,ergrandlen,nil,0,ergcode,True,
                        nil,nil,nil,nil,nil))
	               {dummy = verklebung(i,e1,j,e2,g,fl,
                                   ergcode,DURCHSCHNITT,his_anz,krit,paar,
                                   (randcode2[j.pos+1]<<1)+1,0);}
                    /* Patch 1 rechts (nur bei Paaren erlaubt) */
                    if (paar && sortiere_randcodes(j.nr,i.nr,False,code2,
                        code1,
                        ergrandcode,ergrandlen,nil,0,ergcode,True,
                        nil,nil,nil,nil,nil))
        	       {dummy = verklebung(j,e2,i,e1,g,fl,
                                     ergcode,DURCHSCHNITT,his_anz,krit,paar,
                                     (randcode2[j.pos+1]<<1)+1,0);}
                  }     /* if */
                }       /* for */
              }         /* if */

              else if (len1>3) {    /* len1>3 => Rand 1 ist BK-Rand */
                /* Typ 0 => keine BB */ 
                wh1 = ermittle_wh(&code1[anf1],len1);
                for (i.pos=0; i.pos<wh1; (i.pos)++) {
                  if (code1[anf1+i.pos]==0 && 
                      code1[anf1+(i.pos+len1-1)%len1]==0 && 
                      code1[anf1+(i.pos+1)%len1]==randcode2[j.pos+1]) {
                    wh = verknuepfe_randcodes(&code1[anf1],randcode2,len1,len2,
                         (POSTYP)(i.pos),(POSTYP)(j.pos),DURCHSCHNITT,
                         ergrandcode,&ergrandlen,nil,nil,nil,True,nil,
                         (randcode2[j.pos+1]<<1)+1,0);
                    if (wh && sortiere_randcodes(i.nr,j.nr,False,code1,
                        paar ? code2 : nil,ergrandcode,
                        ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil)) 
                       {dummy = verklebung(i,e1,j,e2,g,fl,
                                   ergcode,DURCHSCHNITT,his_anz,krit,paar,
                                   (randcode2[j.pos+1]<<1)+1,0);}
                  }   /* if */
                }     /* for */
              }       /* else */
            }        /* if */
          }         /* for */

          /* ungerader Durchschnitt mit Patch 2 links 
             (nur bei Paaren erlaubt) und keine BB: */
          if (paar && len2>3 && randcode2[len2+j.pos-1]==0) {  
            /* Typ 2/3 - keine BB */
            for (i.nr=0; i.nr<code1[0]; i.nr++) {
              anf1 = code1[i.nr+1];
              len1 = code1[i.nr+2]-anf1;
              if (len1>2) {        /* => Rand 1 ist BK-Rand */
                wh1 = ermittle_wh(&code1[anf1],len1);
                for (i.pos=0; i.pos<wh1; (i.pos)++) {
                  if (code1[anf1+i.pos]==0 && 
                      code1[anf1+(i.pos+1)%len1]==randcode2[j.pos+1]) {
                    wh = verknuepfe_randcodes(randcode2,&code1[anf1],len2,
                         len1,(POSTYP)(j.pos),(POSTYP)(i.pos),DURCHSCHNITT,
                         ergrandcode,&ergrandlen,nil,nil,nil,True,nil,
                         (randcode2[j.pos+1]<<1)+1,0);
                    if (wh && sortiere_randcodes(j.nr,i.nr,False,code2,code1,
                        ergrandcode,ergrandlen,nil,0,ergcode,True,
                          nil,nil,nil,nil,nil))
                       {dummy = verklebung(j,e2,i,e1,g,fl,
                                   ergcode,DURCHSCHNITT,his_anz,krit,paar,
                                   (randcode2[j.pos+1]<<1)+1,0);}
                  }   /* if */
                }     /* for */
              }       /* if */
            }         /* for */
          }           /* if len2>3 */
	}           /* if len2>2 */

        /* geraden Durchschnitt testen, wobei Patch 2 = links
           (nur bei Paaren erlaubt): */
        if (paar && len2>3 && randcode2[j.pos]==0 && randcode2[j.pos+2]==0) {

          if (len2==4) {                /* Typ 3 => Bauchbinde entsteht */ 
            for (i.nr=0; i.nr<code1[0]; i.nr++) {
              anf1 = code1[i.nr+1];
              len1 = code1[i.nr+2]-anf1;
              if (len1==2 && code1[anf1]!=BB_KENNUNG) { 
                /* Rand 1 ist BK-Rand --- Durchschnitt mit BB moeglich */
                wh1 = ermittle_wh(&code1[anf1],len1);
                for (i.pos=0; i.pos<wh1; (i.pos)++) {
                  if (code1[anf1+i.pos]==randcode2[j.pos+1]+1) {
                    ergrandcode[0] = BB_KENNUNG;
                    ergrandcode[1] = code1[anf1+(i.pos+len1-1)%len1] +
                                     randcode2[j.pos+len2-1] + 2;
                    ergrandlen = 2;
                    if (sortiere_randcodes(j.nr,i.nr,False,code2,code1,
                        ergrandcode,ergrandlen,nil,0,ergcode,True,
                        nil,nil,nil,nil,nil)) 
	      	       {dummy = verklebung(j,e2,i,e1,g,fl,
                                   ergcode,DURCHSCHNITT,his_anz,krit,paar,
                                   (randcode2[j.pos+1]<<1)+2,0);}
                  }   /* if */
                }     /* for */
              }       /* if */
            }         /* for */
          }             /* if len2==4 */

          else if (len2>4 && randcode2[len2+j.pos-1]==0) {
            /* Typ 2/3 => keine Bauchbinde */ 
            for (i.nr=0; i.nr<code1[0]; i.nr++) {
              anf1 = code1[i.nr+1];
              len1 = code1[i.nr+2]-anf1;
              if (len1>2 || (len1==2 && code1[anf1]!=BB_KENNUNG)) {
                /* Rand 1 ist BK-Rand */
                wh1 = ermittle_wh(&code1[anf1],len1);
                for (i.pos=0; i.pos<wh1; (i.pos)++) {
                  if (code1[anf1+i.pos]==randcode2[j.pos+1]+1) {
                    wh = verknuepfe_randcodes(randcode2,&code1[anf1],len2,len1,
                         (POSTYP)(j.pos),(POSTYP)(i.pos),DURCHSCHNITT,
                         ergrandcode,&ergrandlen,nil,nil,nil,True,nil,
                         (randcode2[j.pos+1]<<1)+2,0);
                    if (wh && sortiere_randcodes(j.nr,i.nr,False,code2,code1,
                        ergrandcode,ergrandlen,nil,0,ergcode,True,
                        nil,nil,nil,nil,nil))
                       {dummy = verklebung(j,e2,i,e1,g,fl,
                                   ergcode,DURCHSCHNITT,his_anz,krit,paar,
                                   (randcode2[j.pos+1]<<1)+2,0);}
                  }   /* if */
                }     /* for */
              }       /* if */
            }         /* for */
	  }           /* else */
        }             /* if len2>3 */
  
        /* geraden Durchschnitt testen, wobei Patch 2 = rechts: */
        if (len2>1) {
      
          for (i.nr=0; i.nr<code1[0]; i.nr++) {
            if (paar || i.nr!=j.nr) {
              anf1 = code1[i.nr+1];
              len1 = code1[i.nr+2]-anf1;

              if (len1>4) {   /* Typ 0 - Durchschnitt ohne BB moeglich */
                /* len1>4 => Rand 1 ist BK-Rand */
                wh1 = ermittle_wh(&code1[anf1],len1);
                for (i.pos=0; i.pos<wh1; (i.pos)++) {
                  if (code1[anf1+i.pos]==0 && 
                      code1[anf1+(i.pos+len1-1)%len1]==0 && 
                      code1[anf1+(i.pos+2)%len1]==0 && 
                      code1[anf1+(i.pos+1)%len1]+1==randcode2[j.pos]) {
                    wh = verknuepfe_randcodes(&code1[anf1],randcode2,len1,len2,
                         (POSTYP)(i.pos),(POSTYP)(j.pos),DURCHSCHNITT,
                         ergrandcode,&ergrandlen,nil,nil,nil,True,nil,
                         (randcode2[j.pos]<<1),0);
                    if (wh && sortiere_randcodes(i.nr,j.nr,False,code1,
                        paar ? code2 : nil,ergrandcode,
                        ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil))
                       {dummy = verklebung(i,e1,j,e2,g,fl,
                                   ergcode,DURCHSCHNITT,his_anz,krit,paar,
                                   (randcode2[j.pos]<<1),0);}
                  }   /* if */
                }     /* for */
              }       /* if */

              else if (len1==4 && len2==2) {  /* Typ 1 - Durchschnitt mit BB */
                /* len1==4 => Rand 1 ist BK-Rand */ 
                wh1 = ermittle_wh(&code1[anf1],len1);
                for (i.pos=0; i.pos<wh1; (i.pos)++) {
                  if (code1[anf1+i.pos]==0 && 
                      code1[anf1+(i.pos+2)%len1]==0 && 
                      code1[anf1+(i.pos+1)%len1]+1==randcode2[j.pos]) {
                    ergrandcode[0] = BB_KENNUNG;
                    ergrandcode[1] = code1[anf1+(i.pos+len1-1)%len1] 
                                   + randcode2[len2+j.pos-1] + 2;
                    ergrandlen = 2;
                    if (sortiere_randcodes(i.nr,j.nr,False,code1,
                        paar ? code2 : nil,
                        ergrandcode,ergrandlen,nil,0,ergcode,True,
                        nil,nil,nil,nil,nil))
                       {dummy = verklebung(i,e1,j,e2,g,fl,
                                   ergcode,DURCHSCHNITT,his_anz,krit,paar,
                                   (randcode2[j.pos]<<1),0);}
                  }   /* if */
                }     /* for */
              }       /* else */
            }       /* if */
          }         /* for */
        }               /* geraden Durchschnitt mit Patch 2 rechts */
      }                 /* for j.pos */

      /* Im folgenden werden die Einschluesse getestet, bei denen Patch 2 als
         Patch A fungiert (nur bei Paaren erlaubt). */
      if (paar && len2>3) {     /* Patch 2 kann Patch A sein */ 
        
        i.pos = 0;      /* bleibt in der gesamten Schleife erhalten */
        for (j.pos=0; j.pos<wh2; j.pos++) {

          if ((len2==5 || (len2>5 && randcode2[j.pos+len2-1]==0)) && 
              randcode2[j.pos]==0 && randcode2[j.pos+2]==0 && 
              randcode2[j.pos+3]>randcode2[j.pos+1]+(small_face>2)) { 
            l = randcode2[j.pos+3]-randcode2[j.pos+1]-1;      /* Typ 8 - 1a */
            for (i.nr=0; i.nr<code1[0]; i.nr++) {
              anf1 = code1[i.nr+1];
              len1 = code1[i.nr+2]-anf1;
              if (len1==1 && code1[anf1]==l) {   /* Rand 1 ist BK-Rand */
                wh = verknuepfe_randcodes(randcode2,nil,len2,1,
                     (POSTYP)(j.pos),0,EINSCHLUSS,
                     ergrandcode,&ergrandlen,nil,nil,nil,True,nil,0,(l<<1)+1);
                     /* "nahtlen" ist hier unwichtig */
                if (wh && sortiere_randcodes(j.nr,i.nr,False,code2,
                    code1,ergrandcode,
                    ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil))
                   {dummy = verklebung(j,e2,i,e1,g,fl,ergcode,EINSCHLUSS,
                    his_anz,krit,paar,(randcode2[j.pos+1]<<1)+2,(l<<1)+1);}
                               /* hier ist "nahtlen" wichtig */
              }   /* if */
            }     /* for */
          }       /* if */

          if ((len2==4 || randcode2[j.pos+len2-1]==0) && randcode2[j.pos]==0 &&
              randcode2[j.pos+2]>randcode2[j.pos+1]+1+(small_face>2)) {
            l = randcode2[j.pos+2]-randcode2[j.pos+1]-2;      /* Typ 9 - 1b */
            for (i.nr=0; i.nr<code1[0]; i.nr++) {
              anf1 = code1[i.nr+1];
              len1 = code1[i.nr+2]-anf1;
              if (len1==2 && code1[anf1+1]==0 && code1[anf1]==l) {
                /* aus Bedingung 1 und 2 folgt: Rand 1 ist BK-Rand */
                wh = verknuepfe_randcodes(randcode2,nil,len2,2,
                     (POSTYP)(j.pos),0,EINSCHLUSS,
                     ergrandcode,&ergrandlen,nil,nil,nil,True,nil,0,(l<<1)+2);
                if (wh && sortiere_randcodes(j.nr,i.nr,False,code2,
                    code1,ergrandcode,
                    ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil))
                   {dummy = verklebung(j,e2,i,e1,g,fl,ergcode,EINSCHLUSS,
                    his_anz,krit,paar,(randcode2[j.pos+1]<<1)+2,(l<<1)+2);}
              }   /* if */
            }     /* for */
          }       /* if */

          if ((len2==5 || (len2>5 && randcode2[j.pos+len2-1]==0)) &&
              randcode2[j.pos]==0 && randcode2[j.pos+2]==0 && 
              randcode2[j.pos+1]>=randcode2[j.pos+3]+(small_face>2)) {
            l = randcode2[j.pos+1]-randcode2[j.pos+3];        /* Typ 8 - 2a */
            for (i.nr=0; i.nr<code1[0]; i.nr++) {
              anf1 = code1[i.nr+1];
              len1 = code1[i.nr+2]-anf1;
              if (len1==1 && code1[anf1]==l) {   /* Rand 1 ist BK-Rand */
                wh = verknuepfe_randcodes(randcode2,nil,len2,1,
                     (POSTYP)(j.pos),0,EINSCHLUSS,
                     ergrandcode,&ergrandlen,nil,nil,nil,True,nil,0,(l<<1)+1);
                if (wh && sortiere_randcodes(j.nr,i.nr,False,code2,
                    code1,ergrandcode,
                    ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil))
                   {dummy = verklebung(j,e2,i,e1,g,fl,ergcode,EINSCHLUSS,
                    his_anz,krit,paar,(randcode2[j.pos+3]<<1)+1,(l<<1)+1);}
              }   /* if */
            }     /* for */
          }       /* if */

          if ((len2==4 || randcode2[j.pos+len2-1]==0) && randcode2[j.pos]==0 &&
              randcode2[j.pos+1]>randcode2[j.pos+2]+(small_face>2)) {
            l = randcode2[j.pos+1]-randcode2[j.pos+2]-1;      /* Typ 9 - 2b */
            for (i.nr=0; i.nr<code1[0]; i.nr++) {
              anf1 = code1[i.nr+1];
              len1 = code1[i.nr+2]-anf1;
              if (len1==2 && code1[anf1+1]==0 && code1[anf1]==l) {
                /* aus Bedingung 1 und 2 folgt: Rand 1 ist BK-Rand */
                wh = verknuepfe_randcodes(randcode2,nil,len2,2,
                     (POSTYP)(j.pos),0,EINSCHLUSS,
                     ergrandcode,&ergrandlen,nil,nil,nil,True,nil,0,(l<<1)+2);
                if (wh && sortiere_randcodes(j.nr,i.nr,False,code2,
                    code1,ergrandcode,
                    ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil))
                   {dummy = verklebung(j,e2,i,e1,g,fl,ergcode,EINSCHLUSS,
                    his_anz,krit,paar,(randcode2[j.pos+2]<<1)+1,(l<<1)+2);}
              }   /* if */
            }     /* for */
          }       /* if */
        }         /* for j.pos */
      }           /* Patch 2 als Patch A */
          
      /* Im folgenden werden die Einschluesse getestet, bei denen Patch 2 als 
         Patch B fungiert. Schleifen ueber j.pos sind nicht notwendig, da die 
         Drehung von Patch 2 immer 0 sein muss. */
      l = randcode2[0];
      j.pos = 0;        /* bleibt im folgenden erhalten */
      if (len2==1) {                     /* => Einschluss 1a oder 2a */
        for (i.nr=0; i.nr<code1[0]; i.nr++) {
          if (paar || i.nr!=j.nr) {
            anf1 = code1[i.nr+1];
            len1 = code1[i.nr+2]-anf1;
            if (len1>4) {           /* (=> BK-Rand) Einschluss moeglich */
              wh1 = ermittle_wh(&code1[anf1],len1);
              for (i.pos=0; i.pos<wh1; (i.pos)++) {
                if ((len1==5 || code1[anf1+(i.pos+len1-1)%len1]==0) && 
                    code1[anf1+i.pos]==0 && code1[anf1+(i.pos+2)%len1]==0 && 
                    code1[anf1+(i.pos+3)%len1]==
                    code1[anf1+(i.pos+1)%len1]+1+l) {     /* Einschluss 1a */
                  wh = verknuepfe_randcodes(&code1[anf1],nil,len1,1,
                       (POSTYP)(i.pos),0,EINSCHLUSS,ergrandcode,&ergrandlen,
                       nil,nil,nil,True,nil,0,(l<<1)+1);
                  if (wh && sortiere_randcodes(i.nr,j.nr,False,code1,
                      paar ? code2 : nil,ergrandcode,
                      ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil))
                     {dummy = verklebung(i,e1,j,e2,g,fl,ergcode,EINSCHLUSS,
                      his_anz,krit,paar,(code1[anf1+(i.pos+1)%len1]<<1)+2,
                                 (l<<1)+1);}
                }   /* if */
                if ((len1==5 || code1[anf1+(i.pos+len1-1)%len1]==0) && 
                    code1[anf1+i.pos]==0 && code1[anf1+(i.pos+2)%len1]==0 && 
                    code1[anf1+(i.pos+1)%len1]==code1[anf1+(i.pos+3)%len1]+l) {
                                                        /* Einschluss 2a */
                  wh = verknuepfe_randcodes(&code1[anf1],nil,len1,1,
                       (POSTYP)(i.pos),0,EINSCHLUSS,ergrandcode,&ergrandlen,
                       nil,nil,nil,True,nil,0,(l<<1)+1);
                  if (wh && sortiere_randcodes(i.nr,j.nr,False,code1,
                      paar ? code2 : nil,ergrandcode,
                      ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil))
                     {dummy = verklebung(i,e1,j,e2,g,fl,
                                 ergcode,EINSCHLUSS,his_anz,krit,paar,
                                 (code1[anf1+(i.pos+3)%len1]<<1)+1,(l<<1)+1);}
                }   /* if */ 
              }     /* for */
            }       /* if */
          }         /* if */
        }         /* for */
      }           /* if len2==1 */
   
      if (len2==2 && randcode2[1]==0) {     /* => Einschluss 1b oder 2b */
        for (i.nr=0; i.nr<code1[0]; i.nr++) {
          if (paar || i.nr!=j.nr) {
            anf1 = code1[i.nr+1];
            len1 = code1[i.nr+2]-anf1;
            if (len1>3) {            /* (=> BK-Rand) Einschluss moeglich */
              wh1 = ermittle_wh(&code1[anf1],len1);
              for (i.pos=0; i.pos<wh1; (i.pos)++) {
                if ((len1==4 || code1[anf1+(i.pos+len1-1)%len1]==0) && 
                    code1[anf1+i.pos]==0 && 
                    code1[anf1+(i.pos+2)%len1]==
                    code1[anf1+(i.pos+1)%len1]+2+l) {    /* Einschluss 1b */
                  wh = verknuepfe_randcodes(&code1[anf1],nil,len1,2,
                       (POSTYP)(i.pos),0,EINSCHLUSS,ergrandcode,&ergrandlen,
                       nil,nil,nil,True,nil,0,(l<<1)+2);
                  if (wh && sortiere_randcodes(i.nr,j.nr,False,code1,
                      paar ? code2 : nil,ergrandcode,
                      ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil))
                     {dummy = verklebung(i,e1,j,e2,g,fl,
                                 ergcode,EINSCHLUSS,his_anz,krit,paar,
                                 (code1[anf1+(i.pos+1)%len1]<<1)+2,(l<<1)+2);}
                }   /* if */
                if ((len1==4 || code1[anf1+(i.pos+len1-1)%len1]==0) && 
                    code1[anf1+i.pos]==0 && 
                    code1[anf1+(i.pos+1)%len1]==
                    code1[anf1+(i.pos+2)%len1]+1+l) {    /* Einschluss 2b */
                  wh = verknuepfe_randcodes(&code1[anf1],nil,len1,2,
                       (POSTYP)(i.pos),0,EINSCHLUSS,ergrandcode,&ergrandlen,
                       nil,nil,nil,True,nil,0,(l<<1)+2);
                  if (wh && sortiere_randcodes(i.nr,j.nr,False,code1,
                      paar ? code2 : nil,ergrandcode,
                      ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil))
                     {dummy = verklebung(i,e1,j,e2,g,fl,
                                 ergcode,EINSCHLUSS,his_anz,krit,paar,
                                 (code1[anf1+(i.pos+2)%len1]<<1)+1,(l<<1)+2);}
                }   /* if */
              }     /* for */
            }       /* if */
          }         /* if */
        }         /* for */
      }             /* if len2==2 ... */
    }               /* if Bruchkantenrand */
  }                 /* for j.nr */
}

/**************VERKNUEPFE_PATCH_FALL1_IN_REKURSION**************************/
/* Fuer einzelne Patches, bei denen ein Rand mit sich selbst verklebt wird
   (Fall 1).                                                               */
/* Prueft, ob ein Patch mit dem uebergebenen Bordercode mit sich selbst
   verbunden werden kann. "e1" zeigt (implizit) auf eine Liste von Patches
   mit diesem Bordercode.                                                  */
/* g = Genus in den potentiellen Ergebnispatches                           */
/* fl = Anzahl Flaechen in den potentiellen Ergebnispatches                */
/* In der Rekursion werden nicht alle moeglichen (j.nr)-Werte bestimmt,
   da die Patches nicht konstruiert werden, sondern nur die Randcodes
   entscheiden, und die sind in allen Faellen gleich. Die (j.nr)-Werte
   werden spaeter bei der Konstruktion der Karten veraendert.              */
/* "his_anz" enthaelt die Anzahl der Eintraege in "history".               */

void verknuepfe_patch_fall1_in_rekursion(ELEM *e1,KNOTENTYP *code,KNOTENTYP g,
     KNOTENTYP fl,KNOTENTYP krit,KNOTENTYP his_anz) {
  static BOOL dummy;
  BORDERPOS i,j;                /* Verschiebungen im Randcode */
  KNOTENTYP *randcode;          /* fuer 2 Kopien eines Randcodes */
  KNOTENTYP h,wh,anf,len;         /* zugehoerige Werte */
  KNOTENTYP *ergrandcode;     /* fuer RANDcode (2 Kopien) */
  KNOTENTYP ergrandlen;               /* fuer RANDcode */
  KNOTENTYP *ergrandcode2;    /* fuer RANDcode (2 Kopien) */
  KNOTENTYP ergrandlen2;              /* fuer RANDcode */
  KNOTENTYP offset2;                  /* fuer Randcodemaximierung */
  KNOTENTYP *ergcode;         /* fuer BORDERcode */
  KNOTENTYP ergwh;   /* ergwh!=0 => kanonische Verknuepfung gefunden */
  KNOTENTYP bb2,wh2,nr2,rl2,rlg2;    /* Nummer des zweiten erzeugten Randes */
  unsigned char akzeptiert[ACCEPTLEN];
 
  randcode = randcode2_vpr[his_anz-1];
  ergrandcode = ergrandcode_vpr[his_anz-1];
  ergrandcode2 = ergrandcode2_vpr[his_anz-1];
  ergcode = ergcode_vpr[his_anz-1];

  for (i.nr=0; i.nr<code[0] && (len=code[i.nr+2]-(anf=code[i.nr+1]))>5; 
       i.nr++) {
    /* Randcodes durchlaufen, die lang genug sind */
    memcpy(randcode,&code[anf],sizeof(KNOTENTYP)*(size_t)len);
    memcpy(&randcode[len],randcode,sizeof(KNOTENTYP)*(size_t)len);
    wh = ermittle_wh(randcode,len);    /* Wiederholungszahl */

    for (i.pos=0; i.pos<wh; i.pos++) {

      if (randcode[i.pos]==0 /*&& (len==6 || randcode[i.pos+len-1]==0)*/) {
         /* Durchschnitt ist moeglich */

        /* geraden Durchschnitt testen: */
        if (randcode[i.pos+2]==0) {    /* Codeausschnitt passt */
          for (j.pos=0; j.pos<len; j.pos++) {
            if (randcode[j.pos]==randcode[i.pos+1]+1 
                /* => randcode[j]!=0 => j \not\in \{i,i+1,i+2\} */
                && !(j.pos==(i.pos+len-1)%len || j.pos==(i.pos+3)%len)) { 
                /* keine Ueberschneidung der Codes */
              ergwh = verknuepfe_randcodes(randcode,nil,len,len,i.pos,j.pos,
                      VERBINDUNG,ergrandcode,
                      &ergrandlen,ergrandcode2,&ergrandlen2,&offset2,True,
                      &(j.nr),randcode[j.pos]<<1,0);
              if (ergwh && sortiere_randcodes(i.nr,i.nr,True,code,
                  nil,ergrandcode,ergrandlen,&ergrandcode2[offset2],
                  ergrandlen2,ergcode,True,nil,nil,nil,nil,&nr2)) {
                bb2 = (ergrandlen2==2 && ergrandcode2[offset2]==BB_KENNUNG);
                if (bb2) {rl2 = 2;  rlg2 = ergrandcode2[offset2+1]<<1;}
                else {
                  wh2 = ermittle_wh(&ergrandcode2[0],ergrandlen2);
                  rl2 = randlaenge(&ergrandcode2[offset2],0,wh2-1);
                  rlg2 = rl2*(ergrandlen2/wh2);
                }
                dummy = verklebung_fall1(i,e1,j,g,fl,ergcode,his_anz,krit,
                                 nr2,rl2,rlg2,0,randcode[j.pos]<<1,0);
              }
	    }  /* if */
          }    /* for */
        }      /* if */
        
        /* ungeraden Durchschnitt testen: */
        for (j.pos=0; j.pos<len; j.pos++) {
          if (randcode[j.pos]==0 && randcode[j.pos+1]==randcode[i.pos+1] && 
              !(j.pos==i.pos || (j.pos+1)%len==i.pos || (j.pos+2)%len==i.pos ||
                (j.pos+len-1)%len==i.pos || (j.pos+len-2)%len==i.pos)) { 
              /* keine Ueberschneidung */
            ergwh = verknuepfe_randcodes(randcode,nil,len,len,i.pos,j.pos,
                    VERBINDUNG,ergrandcode,
                 &ergrandlen,ergrandcode2,&ergrandlen2,&offset2,True,&(j.nr),
                 (randcode[j.pos+1]<<1)+1,0);
            if (ergwh && sortiere_randcodes(i.nr,i.nr,True,code,
                nil,ergrandcode,ergrandlen,&ergrandcode2[offset2],
                ergrandlen2,ergcode,True,nil,nil,nil,nil,&nr2)) {
              bb2 = (ergrandlen2==2 && ergrandcode2[offset2]==BB_KENNUNG);
              if (bb2) {rl2 = 2;  rlg2 = ergrandcode2[offset2+1]<<1;}
              else {
                wh2 = ermittle_wh(&ergrandcode2[0],ergrandlen2);
                rl2 = randlaenge(&ergrandcode2[offset2],0,wh2-1);
                rlg2 = rl2*(ergrandlen2/wh2);
              }
              dummy =verklebung_fall1(i,e1,j,g,fl,ergcode,his_anz,krit,nr2,
                               rl2,rlg2,0,(randcode[j.pos+1]<<1)+1,0);
            }
	  }  /* if */
        }    /* for */
      }      /* if */
    }        /* for i.pos */
  }          /* for i.nr */
}

/**************SUCHE_PASSENDE_PATCHES_IN_REKURSION***************************/
/*  Sucht zu einem Bordercode alle Patches, die sich mit den zum Bordercode
    gehoerenden Patches zusammennaehen lassen.                              */
/*  Es kann nicht passieren, dass Patch 2 den Patch 1 erreicht. Deshalb
    ist kein "ende"-Flag notwendig.                                         */
/*  krit = kritische Flaechen in den Ergebnispatches                        */
/*  g,fl = Genus und Flaechenzahl in Patch 1 und Patch 2 zusammen           */
/*  Die Reihenfolge, in der die Patches zugeordnet werden, ist anders als
    bei "suche_passende_patches", aber das ist egal, da ja alle in Frage
    kommenden Patches feststehen.                                           */
/*  Weitere Kommentare siehe "suche_passende_patches".                      */ 

void suche_passende_patches_rek2_in_rekursion(KNOTENTYP *bordercode1,
     KNOTENTYP g,KNOTENTYP fl,TREENODE *root2,KNOTENTYP *bordercode2,
     KNOTENTYP len2,KNOTENTYP krit,KNOTENTYP k1,POSTYP k2,
     KNOTENTYP anz_bb_in2,POSTYP his_anz) {
  static BOOL bb_in2_new, eulerkrit1, eulerkrit2;
  static POSTYP flaechen_neu,r,k; 
  while (root2) {    /* einen Level durchgehen */
    bordercode2[len2] = root2->code;   /* ab hier ist "len2" um 1 zu niedrig */
    eulerkrit1 = eulerkrit2 = True;  
                 /* kann fuer jeden Zweig unterschiedlich sein */
    if (bb_in2_new = (bordercode2[len2]==BB_KENNUNG)) {
      if (anz_bb_in2>0) {eulerkrit1 = False;}
      else {
        r = bordercode1[0]+bordercode2[0]-1; 
        k = k2 + 2*(bordercode2[0]==2);
        if (12*((POSTYP)genus_anf-(POSTYP)g) > 6*r+k) {   
          /* neue grosse Flaechen */
          if (big_face>6) {               /* neue grosse Flaechen moeglich */
            flaechen_neu = (12*((POSTYP)genus_anf-(POSTYP)g)-6*r-k-1) /
                           (big_face-6)+1;
            if (fl+flaechen_neu > f_max[MAX(g+r-1,genus_anf)]) 
               {eulerkrit1 = False;}
          }
          else {eulerkrit1 = False;}        /* kein Ausgleich moeglich */ 
        }
      }
    }
    if (len2==bordercode2[bordercode2[0]] &&
        anz_bb_in2+(bb_in2_new==True) < 1+(bordercode2[0]==2)) { 
      r = bordercode1[0]+bordercode2[0]-1; 
      k = k2 + 2*(1+(bordercode2[0]==2)-anz_bb_in2-(bb_in2_new==True));
      if (12*(POSTYP)(genus_end-g) < 6*r+k) {    /* neue kleine Flaechen */
        if (small_face<6) {              /* neue kleine Flaechen moeglich */
          flaechen_neu = (6*r+k-12*(genus_end-g)-1)/(6-small_face)+1;
          if (fl+flaechen_neu > f_max[MAX(g+r-1,genus_anf)]) 
             {eulerkrit2 = False;}
        }
        else {eulerkrit2 = False;}         /* kein Ausgleich moeglich */
      }
    } 
    if (eulerkrit1 && eulerkrit2) {        /* weiter im Baum */
      if (len2+1<bordercode2[bordercode2[0]+1])   /* kein Codeende */
         {suche_passende_patches_rek2_in_rekursion(bordercode1,g,fl,
            root2->weiter.nextlevel,bordercode2,len2+1,krit,k1,k2,
            anz_bb_in2+(bb_in2_new==True),his_anz);}
      else          /* Patchpaar gefunden */
        {verknuepfe_patches_in_rekursion(&history[his_anz-1],bordercode1,
         root2->weiter.firstpatch,bordercode2,g,fl,krit,True,his_anz);}
    } 
    root2 = root2->next;
  }    /* while */
}

void suche_passende_patches_rek1_in_rekursion(KNOTENTYP *bordercode1,
     KNOTENTYP g,KNOTENTYP fl,TREENODE *root2,KNOTENTYP *bordercode2,
     KNOTENTYP len2,KNOTENTYP krit,KNOTENTYP k1,POSTYP his_anz) {
  static POSTYP flaechen_neu,r,k;
  static BOOL eulerkrit1;
  BOOL genuskrit = True, eulerkrit2 = True;  
  while (root2 && genuskrit && eulerkrit2) {
    /* einen Level durchgehen */
    bordercode2[len2] = root2->code;   /* ab hier ist "len2" um 1 zu niedrig */
    eulerkrit1 = True;       /* kann fuer jeden Zweig unterschiedlich sein */
    r = bordercode1[0]+bordercode2[0]-1; 
    if (g+r-1 > genus_end) {genuskrit = False;}  /* Genuskriterium versagt */
    else if (len2>1) {
      k = (POSTYP)k1 + (POSTYP)(bordercode2[len2]) - (POSTYP)(bordercode2[0]) 
          - 10 - 2*(bordercode2[0]==2);   /* Mindestzahl Bruchkanten */   
      if (12*(POSTYP)(genus_end-g) < 6*r+k) {  /* neue kleine Flaechen */
        if (small_face<6) {             /* neue kleine Flaechen moeglich */
          flaechen_neu = (6*r+k-12*(genus_end-g)-1)/(6-small_face)+1;
          if (fl+flaechen_neu > f_max[MAX(g+r-1,genus_anf)]) 
             {eulerkrit2 = False;}
        }
        else {eulerkrit2 = False;}         /* kein Ausgleich moeglich */
      }
      else if (len2==bordercode2[0]+1 && 12*((POSTYP)genus_anf-(POSTYP)g) > 
               6*r+k+2+2*(bordercode2[0]==2)) {   /* neue grosse Flaechen */
        if (big_face>6) {                /* neue grosse Flaechen moeglich */
          flaechen_neu = (12*((POSTYP)genus_anf-(POSTYP)g)-6*r-k-3
                         -2*(bordercode2[0]==2)) / (big_face-6)+1;
          if (fl+flaechen_neu > f_max[MAX(g+r-1,genus_anf)]) 
             {eulerkrit1 = False;}
        }
        else {eulerkrit1 = False;}        /* kein Ausgleich moeglich */ 
      }
    }
    if (genuskrit && eulerkrit1 && eulerkrit2) {    /* weiter im Baum */
      if (len2==bordercode2[0]+1)    
         {suche_passende_patches_rek2_in_rekursion(bordercode1,g,fl,
          root2->weiter.nextlevel,bordercode2,len2+1,krit,k1,k,0,his_anz);}
      else {suche_passende_patches_rek1_in_rekursion(bordercode1,g,fl,
            root2->weiter.nextlevel,bordercode2,len2+1,krit,k1,his_anz);}
    }  /* if */
    root2 = root2->next;
  }    /* while */
}

void suche_passende_patches_in_rekursion(KNOTENTYP *bordercode1,
     KNOTENTYP g1,KNOTENTYP fl1,KNOTENTYP krit1,KNOTENTYP k1,POSTYP his_anz) {
  KNOTENTYP i;
  TREENODE *t,*t2;
  for (i=1; i+fl1<=f_max[MAX(genus_anf,g1)]; i++) {      
    /* Falls krit1<<1==krit_max: Nach Voraussetzung ist der Patch "ueber den
       Berg". Deshalb ist als Returnwert nicht 
       die Information darueber notwendig, ob Patch 2 den Patch 1 erreicht 
       hat (das ist naemlich unmoeglich). */
    t = tree[i];
    while (t && t->code+g1<=genus_end && 
           i+fl1<=f_max[MAX(genus_anf,t->code+g1)]) {   
      /* Genus und Flaechenzahl passen noch */
      t2 = t->weiter.nextlevel;
      while (t2) {
        suche_passende_patches_rek1_in_rekursion(bordercode1,g1+t->code,
            fl1+i,t2->weiter.nextlevel,bordercode2_sppr[his_anz-1],0,
            krit1 + t2->code,k1,his_anz); 
        t2 = t2->next;
      }
      t = t->next;
    }
  }
}
      
/******************GEHE_PATCHBAUM_DURCH_IN_REKURSION************************/
/*   Loest dasselbe aus wie "gehe_patchbaum_durch", aber den Patch 1
     erhaelt man durch Rekursion anstatt durch systematisches Durchforsten
     des Baums.                                                            */
/*   Im Gegensatz zur Funktion "gehe_patchbaum_durch" muss der Bordercode
     nicht aktualisiert werden, sondern ist bereits aktuell. Die Summe wird
     in der Funktion selbst ausgerechnet und ein TREENODE eingerichtet, der
     die Information ueber die Vorgaengerknoten enthaelt.                  */ 

void gehe_patchbaum_durch_in_rekursion(KNOTENTYP *bordercode,KNOTENTYP g,
     KNOTENTYP fl,KNOTENTYP krit,POSTYP his_anz) {
  suche_passende_patches_in_rekursion(bordercode,g,fl,krit,
    bordercode[bordercode[0]+1]-bordercode[0]-2-
    (ermittle_anz_bb(bordercode)<<1),his_anz);       /* Teil 1 */
  if (g<genus_end && bordercode[0]>1) 
     {verknuepfe_patches_in_rekursion(&history[his_anz-1],
      bordercode,&history[his_anz-1],bordercode,g+1,fl,krit,False,his_anz);}
      /* Teil 2 */
  if (g+bordercode[0]<=genus_end)         /* Genuskriterium erfuellt */
     {verknuepfe_patch_fall1_in_rekursion(&history[his_anz-1],bordercode,g,fl,
                                          krit,his_anz);}   /* Teil 3 */
}

/*********************VERKNUEPFE_PATCHES************************************/
/* Fuer Paare von Patches oder einzelne Patches.                           */
/* Prueft, ob die uebergebenen Patches aus den Listen miteinander verbunden
   werden koennen (alle Patches einer Liste haben denselben Bordercode,
   "e1" und "e2" zeigen auf die ersten Elemente in diesen Listen)          */
/* l = Nahtlaenge (Anzahl identifizierter Kanten)                          */
/* g = Genus in den potentiellen Ergebnispatches                           */
/* fl = Anzahl Flaechen in den potentiellen Ergebnispatches                */
/* "typ89" gibt an, ob die Patches aus Liste 1 als Patch B in einem
   Einschluss fungieren koennen. Da das meistens nicht der Fall ist,
   kann oftmals eine ganze Schleife entfallen.                             */
/* "paar" ist True, wenn 2 Patches miteinander verklebt werden sollen, und
   False, wenn ein und derselbe Patch mit sich selbst verklebt werden soll. 
   Im letzteren Fall stimmen "liste1" und "liste2" sowie "code1" und "code2"
   ueberein. i.nr==j.nr ist dann nicht zulaessig (denn das waere Fall 1).  */
/* ???? ist Trennung nach BB-Rand und BK-Rand noch erforderlich?
        ("verknuepfe_randcodes" beherrscht alles)                          */

BOOL verknuepfe_patches(ELEM *e1,KNOTENTYP *code1,ELEM *e2,
     KNOTENTYP *code2,KNOTENTYP g,KNOTENTYP fl,BOOL expand,
     KNOTENTYP krit,BOOL typ89,BOOL paar) {
  static KNOTENTYP ii;       /* Index fuer Verschiebung im Randcode */
  static BORDERPOS i,j;     /* Randcodenummern + Verschiebungen im Randcode */
  static KNOTENTYP l,wh1,anf1,len1;
  static KNOTENTYP randcode2[2*N_MAX_P];  /*fuer 2 Randcodekopien von Patch 2*/
  static KNOTENTYP len2,wh2;              /* zugehoerige Laenge und Periode */
  static KNOTENTYP ergrandcode[2*N_MAX_P];     /* fuer RANDcode (2 Kopien) */
  static KNOTENTYP ergrandlen;               /* fuer RANDcode */
  static KNOTENTYP ergcode[N_MAX_P+3];         /* fuer BORDERcode */
  static KNOTENTYP wh;        /* wh!=0 => kanonische Verknuepfung gefunden */
  static BOOL ungleich;   /* ungleich==False => gleiche Listen =>
                             gedrehte Typen (Typ 2,3,8 oder 9) verboten */
 
  ungleich = e1!=e2;    /* sinnvoller Wert nur bei Paaren */
  if (V_MAX>1) {       /* sonst nur expand-Version */

  /* Es folgen die Tests auf gerade oder ungerade Verknuepfung: */
  /* Im folgenden kann man sich "if (anz[x][l]>0)"-Abfragen sparen. Falls die
   Bedingung nicht zutrifft, wird die zugehoerige Schleife nicht durchlaufen */
  for (j.nr=0; j.nr<code2[0]; j.nr++) {  
    /* Randcodes von Patch 2 durchgehen */
    if (code2[code2[j.nr+1]]!=BB_KENNUNG) {   /* => Bruchkantenrand */
      len2 = code2[j.nr+2]-code2[j.nr+1];
      wh2 = ermittle_wh(&code2[code2[j.nr+1]],len2);   /* Wiederholungszahl */
      memcpy(randcode2,&code2[code2[j.nr+1]],sizeof(KNOTENTYP)*(size_t)len2);
      memcpy(&randcode2[len2],randcode2,sizeof(KNOTENTYP)*(size_t)len2);
      /* 2 Kopien reichen */      
      for (j.pos=0; j.pos<wh2; j.pos++) {

        /* ungeraden Durchschnitt testen: */
        if (len2>2 && randcode2[j.pos]==0) { 
          l = (randcode2[j.pos+1]<<1)+1; /* anz[x][l] groesser ODER GLEICH 0 */

          if (len2==3) {
            for (ii=anz[1][l]; ii>0; ii--) { 
              /* Typ 1 => Bauchbinde entsteht */
              i = bind_array[1][ii][l];          /* Drehung und Nummer des Randes */
              if (paar || i.nr!=j.nr) {    /* verschiedene Raender */
                len1 = code1[i.nr+2]-code1[i.nr+1];   /* Laenge des Randes */
                ergrandcode[0] = BB_KENNUNG;          /* Bauchbindenrand */ 
                ergrandcode[1] = code1[code1[i.nr+1]+(i.pos+len1-1)%len1] 
                               + randcode2[len2+j.pos-1] + 2;
                ergrandlen = 2;
                if (sortiere_randcodes(i.nr,j.nr,False,code1,
                    paar ? code2 : nil,ergrandcode,
                    ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil)) {
                  if (!verklebung(i,e1,j,e2,g,fl,ergcode,DURCHSCHNITT,0,krit,
                                  paar,l,0)) {return(False);}
                }
              }   /* if */
            }   /* for */
            if (paar && ungleich) {
              for (ii=anz[3][l]; ii>0; ii--) {  
                /* Typ 3 - Bauchbinde (nur bei Paaren) */
                i = bind_array[3][ii][l];
                len1 = code1[i.nr+2]-code1[i.nr+1];
                ergrandcode[0] = BB_KENNUNG;
                ergrandcode[1] = code1[code1[i.nr+1]+(i.pos+len1-1)%len1] 
                               + randcode2[len2+j.pos-1] + 2;
                ergrandlen = 2;
                if (sortiere_randcodes(j.nr,i.nr,False,code2,
                    code1,ergrandcode,
                    ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil)) {
                  if (!verklebung(j,e2,i,e1,g,fl,ergcode,DURCHSCHNITT,0,krit,
                                  paar,l,0)) {return(False);}
                }
              }   /* for */
            }   /* if */
          }     /* if */

          for (ii=anz[0][l]; ii>0; ii--) {    
            /* Typ 0 => keine BB */
            i = bind_array[0][ii][l];
            if (paar || i.nr!=j.nr) {
              len1 = code1[i.nr+2]-code1[i.nr+1];
              wh = verknuepfe_randcodes(&code1[code1[i.nr+1]],randcode2,len1,
                   len2,(POSTYP)(i.pos),(POSTYP)(j.pos),DURCHSCHNITT,
                   ergrandcode,&ergrandlen,nil,nil,nil,True,nil,l,0);
              if (wh && sortiere_randcodes(i.nr,j.nr,False,code1,
                  paar ? code2 : nil,ergrandcode,
                  ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil)) {
                if (!verklebung(i,e1,j,e2,g,fl,ergcode,DURCHSCHNITT,0,krit,
                                paar,l,0)) {return(False);}
              }
            }   /* if */
          }   /* for */

          if (paar && ungleich && len2>3 && randcode2[len2+j.pos-1]==0) { 
            /* Typ 2/3 - keine Bauchbinde (nur bei Paaren) */
            for (ii=anz[2][l]; ii>0; ii--) {   
              /* Typ 2 => keine BB */
              i = bind_array[2][ii][l];
              len1 = code1[i.nr+2]-code1[i.nr+1];
              wh = verknuepfe_randcodes(randcode2,&code1[code1[i.nr+1]],len2,
                   len1,(POSTYP)(j.pos),(POSTYP)(i.pos),DURCHSCHNITT,
                   ergrandcode,&ergrandlen,nil,nil,nil,True,nil,l,0);
              if (wh && sortiere_randcodes(j.nr,i.nr,False,code2,
                  code1,ergrandcode,
                  ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil)) {
                if (!verklebung(j,e2,i,e1,g,fl,ergcode,DURCHSCHNITT,0,krit,
                                paar,l,0)) {return(False);}
              }
            }   /* for */
            for (ii=anz[3][l]; ii>0; ii--) {
              /* Typ 3 - keine BB */
              i = bind_array[3][ii][l];
              len1 = code1[i.nr+2]-code1[i.nr+1];
              wh = verknuepfe_randcodes(randcode2,&code1[code1[i.nr+1]],len2,
                   len1,(POSTYP)(j.pos),(POSTYP)(i.pos),DURCHSCHNITT,
                   ergrandcode,&ergrandlen,nil,nil,nil,True,nil,l,0);
              if (wh && sortiere_randcodes(j.nr,i.nr,False,code2,
                  code1,ergrandcode,
                  ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil)) {
                if (!verklebung(j,e2,i,e1,g,fl,ergcode,DURCHSCHNITT,0,krit,
                                paar,l,0)) {return(False);}
              }
            }   /* for */
          }     /* if */    
        }       /* ungeraden Durchschnitt testen */
           
        /* geraden Durchschnitt testen, wobei Patch 2 = links 
           (nur bei Paaren): */
        if (paar && ungleich && len2>3 && randcode2[j.pos]==0 && 
            randcode2[j.pos+2]==0) {
          l = (randcode2[j.pos+1]<<1)+2;
      
          if (len2==4) {
            for (ii=anz[3][l]; ii>0; ii--) {  
              /* Typ 3 - Bauchbinde */
              i = bind_array[3][ii][l];
              len1 = code1[i.nr+2]-code1[i.nr+1];
              ergrandcode[0] = BB_KENNUNG;
              ergrandcode[1] = code1[code1[i.nr+1]+(i.pos+len1-1)%len1] 
                             + randcode2[len2+j.pos-1] + 2;
              ergrandlen = 2;
              if (sortiere_randcodes(j.nr,i.nr,False,code2,
                  code1,ergrandcode,ergrandlen,nil,0,
                  ergcode,True,nil,nil,nil,nil,nil)) {
                if (!verklebung(j,e2,i,e1,g,fl,ergcode,DURCHSCHNITT,0,krit,
                                paar,l,0)) {return(False);}
              }
            }   /* for */
          }     /* if */

          else if (len2>4 && randcode2[len2+j.pos-1]==0) {             
            /* Typ 2/3 - keine Bauchbinde */
            for (ii=anz[2][l]; ii>0; ii--) { 
              /* Typ 2 => keine BB */
              i = bind_array[2][ii][l];
              len1 = code1[i.nr+2]-code1[i.nr+1];
              wh = verknuepfe_randcodes(randcode2,&code1[code1[i.nr+1]],len2,
                   len1,(POSTYP)(j.pos),(POSTYP)(i.pos),DURCHSCHNITT,
                   ergrandcode,&ergrandlen,nil,nil,nil,True,nil,l,0);
              if (wh && sortiere_randcodes(j.nr,i.nr,False,code2,
                  code1,ergrandcode,
                  ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil)) {
                if (!verklebung(j,e2,i,e1,g,fl,ergcode,DURCHSCHNITT,0,krit,
                                paar,l,0)) {return(False);}
              }
            }   /* for */
            for (ii=anz[3][l]; ii>0; ii--) {
              /* Typ 3 - keine BB */
              i = bind_array[3][ii][l];
              len1 = code1[i.nr+2]-code1[i.nr+1];
              wh = verknuepfe_randcodes(randcode2,&code1[code1[i.nr+1]],len2,
                   len1,(POSTYP)(j.pos),(POSTYP)(i.pos),DURCHSCHNITT,
                   ergrandcode,&ergrandlen,nil,nil,nil,True,nil,l,0);
              if (wh && sortiere_randcodes(j.nr,i.nr,False,code2,
                  code1,ergrandcode,
                  ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil)) {
                if (!verklebung(j,e2,i,e1,g,fl,ergcode,DURCHSCHNITT,0,krit,
                                paar,l,0)) {return(False);}
              }
            }   /* for */
          }     /* if */      
        }       /* geraden Durchschnitt mit Patch 2 links testen */

        /* geraden Durchschnitt testen, wobei Patch 2 = rechts: */
        if (len2>1) {
          l = randcode2[j.pos]<<1;

          for (ii=anz[0][l]; ii>0; ii--) { 
            /* Typ 0 => keine BB */
            i = bind_array[0][ii][l];
            if (paar || i.nr!=j.nr) {
              len1 = code1[i.nr+2]-code1[i.nr+1];
              wh = verknuepfe_randcodes(&code1[code1[i.nr+1]],randcode2,len1,
                   len2,(POSTYP)(i.pos),(POSTYP)(j.pos),DURCHSCHNITT,
                   ergrandcode,&ergrandlen,nil,nil,nil,True,nil,l,0);
              if (wh && sortiere_randcodes(i.nr,j.nr,False,code1,
                  paar ? code2 : nil,ergrandcode,
                  ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil)) {
                if (!verklebung(i,e1,j,e2,g,fl,ergcode,DURCHSCHNITT,0,krit,
                                paar,l,0)) {return(False);}
              }
            }  /* if */
          }   /* for */

          if (len2==2) {
            for (ii=anz[1][l]; ii>0; ii--) { 
              /* Typ 1 => Bauchbinde */
              i = bind_array[1][ii][l];
              if (paar || i.nr!=j.nr) {
                len1 = code1[i.nr+2]-code1[i.nr+1];
                ergrandcode[0] = BB_KENNUNG;
                ergrandcode[1] = code1[code1[i.nr+1]+(i.pos+len1-1)%len1] 
                               + randcode2[len2+j.pos-1] + 2;
                ergrandlen = 2;
                if (sortiere_randcodes(i.nr,j.nr,False,code1,
                    paar ? code2 : nil,ergrandcode,ergrandlen,nil,0,
                    ergcode,True,nil,nil,nil,nil,nil)) {
                  if (!verklebung(i,e1,j,e2,g,fl,ergcode,DURCHSCHNITT,0,krit,
                                  paar,l,0)) {return(False);}
                }
              }   /* if */
            }   /* for */
          }     /* if */
        }           /* gerade Verknuepfung mit Patch 2 rechts testen */
      }     /* for j.pos */

      /* Im folgenden werden die Einschluesse getestet, bei denen Patch 2 als
         Patch A fungiert (nur bei Paaren erlaubt). Diese Tests sind in einer 
         eigenen Schleife 
         untergebracht, da meistens die ganze Schleife entfallen kann. */
      if (paar && ungleich && len2>3 && typ89) {    
        /* Patch 2 kann Patch A und Patch 1 kann Patch B sein */ 

        i.pos = 0;     /* bleibt in der ganzen Schleife erhalten */
        for (j.pos=0; j.pos<wh2; j.pos++) {

          if ((len2==5 || (len2>5 && randcode2[j.pos+len2-1]==0)) && 
              randcode2[j.pos]==0 && randcode2[j.pos+2]==0 && 
              randcode2[j.pos+3]>randcode2[j.pos+1]+(small_face>2)) { 
            l = randcode2[j.pos+3]-randcode2[j.pos+1]-1;          /* Typ 8 */
            for (ii=anz[8][l]; ii>0; ii--) {
              i = bind_array[8][ii][l];
              wh = verknuepfe_randcodes(randcode2,nil,len2,1,(POSTYP)(j.pos),
                   0,EINSCHLUSS,ergrandcode,&ergrandlen,nil,nil,nil,True,nil,
                   0,(l<<1)+1);
              if (wh && sortiere_randcodes(j.nr,i.nr,False,code2,
                  code1,ergrandcode,
                  ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil)) {
                if (!verklebung(j,e2,i,e1,g,fl,ergcode,EINSCHLUSS,0,krit,paar,
                     (randcode2[j.pos+1]<<1)+2,(l<<1)+1)) {return(False);}
              }
            }  /* for */
          }    /* if */

          if ((len2==4 || randcode2[j.pos+len2-1]==0) && randcode2[j.pos]==0 &&
              randcode2[j.pos+2]>randcode2[j.pos+1]+1+(small_face>2)) {
            l = randcode2[j.pos+2]-randcode2[j.pos+1]-2;          /* Typ 9 */
            for (ii=anz[9][l]; ii>0; ii--) {
              i = bind_array[9][ii][l];
              wh = verknuepfe_randcodes(randcode2,nil,len2,2,(POSTYP)(j.pos),
                   0,EINSCHLUSS,ergrandcode,&ergrandlen,nil,nil,nil,True,nil,
                   0,(l<<1)+2);
              if (wh && sortiere_randcodes(j.nr,i.nr,False,code2,
                  code1,ergrandcode,
                  ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil)) {
                if (!verklebung(j,e2,i,e1,g,fl,ergcode,EINSCHLUSS,0,krit,paar,
                     (randcode2[j.pos+1]<<1)+2,(l<<1)+2)) {return(False);}
              }
            }  /* for */
          }    /* if */

          if ((len2==5 || (len2>5 && randcode2[j.pos+len2-1]==0)) && 
              randcode2[j.pos]==0 && randcode2[j.pos+2]==0 && 
              randcode2[j.pos+1]>=randcode2[j.pos+3]+(small_face>2)) {
            l = randcode2[j.pos+1]-randcode2[j.pos+3];            /* Typ 8 */
            for (ii=anz[8][l]; ii>0; ii--) {
              i = bind_array[8][ii][l];
              wh = verknuepfe_randcodes(randcode2,nil,len2,1,(POSTYP)(j.pos),
                   0,EINSCHLUSS,ergrandcode,&ergrandlen,nil,nil,nil,True,nil,0,
                   (l<<1)+1);
              if (wh && sortiere_randcodes(j.nr,i.nr,False,code2,
                  code1,ergrandcode,
                  ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil)) { 
                if (!verklebung(j,e2,i,e1,g,fl,ergcode,EINSCHLUSS,0,krit,paar,
                    (randcode2[j.pos+3]<<1)+1,(l<<1)+1)) {return(False);}
              }
            }  /* for */
          }    /* if */

          if ((len2==4 || randcode2[j.pos+len2-1]==0) && randcode2[j.pos]==0 &&
              randcode2[j.pos+1]>randcode2[j.pos+2]+(small_face>2)) {
            l = randcode2[j.pos+1]-randcode2[j.pos+2]-1;          /* Typ 9 */
            for (ii=anz[9][l]; ii>0; ii--) {
              i = bind_array[9][ii][l];
              wh = verknuepfe_randcodes(randcode2,nil,len2,2,(POSTYP)(j.pos),
                   0,EINSCHLUSS,ergrandcode,&ergrandlen,nil,nil,nil,True,nil,0,
                   (l<<1)+2);
              if (wh && sortiere_randcodes(j.nr,i.nr,False,code2,
                  code1,ergrandcode,
                  ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil)) {
                if (!verklebung(j,e2,i,e1,g,fl,ergcode,EINSCHLUSS,0,krit,paar,
                     (randcode2[j.pos+2]<<1)+1,(l<<1)+2)) {return(False);}
              }
            }  /* for */
          }    /* if */
        }    /* for j.pos */
      }      /* Patch 1 als Patch B und Patch 2 als Patch A */
          
      /* Im folgenden werden die Einschluesse getestet, bei denen Patch 2 als 
         Patch B fungiert. Schleifen ueber j.pos sind nicht notwendig, da die 
         Drehung von Patch 2 immer 0 sein muss. */
      l = randcode2[0];
      j.pos = 0;     /* bleibt im folgenden erhalten */
      if (len2==1) {                             /* => Einschluss 1a oder 2a */
        for (ii=anz[4][l]; ii>0; ii--) {       /* Typ 4 => 1a */
          i = bind_array[4][ii][l];
          if (paar || i.nr!=j.nr) {
            len1 = code1[i.nr+2] - (anf1 = code1[i.nr+1]);
            wh = verknuepfe_randcodes(&code1[code1[i.nr+1]],nil,len1,1,
                 (POSTYP)(i.pos),0,EINSCHLUSS,ergrandcode,&ergrandlen,nil,nil,
                 nil,True,nil,0,(l<<1)+1);
            if (wh && sortiere_randcodes(i.nr,j.nr,False,code1,
                paar ? code2 : nil,ergrandcode,
                ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil)) {
              if (!verklebung(i,e1,j,e2,g,fl,ergcode,EINSCHLUSS,0,krit,paar,
                  (code1[anf1+(i.pos+1)%len1]<<1)+2,(l<<1)+1)) {return(False);}
            }
          }  /* if */
        }   /* for */
        for (ii=anz[6][l]; ii>0; ii--) {       /* Typ 6 => 2a */  
          i = bind_array[6][ii][l];
          if (paar || i.nr!=j.nr) {
            len1 = code1[i.nr+2] - (anf1 = code1[i.nr+1]);
            wh = verknuepfe_randcodes(&code1[code1[i.nr+1]],nil,len1,1,
                 (POSTYP)(i.pos),0,EINSCHLUSS,ergrandcode,&ergrandlen,nil,nil,
                 nil,True,nil,0,(l<<1)+1);
            if (wh && sortiere_randcodes(i.nr,j.nr,False,code1,
                paar ? code2 : nil,ergrandcode,
                ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil)) {
              if (!verklebung(i,e1,j,e2,g,fl,ergcode,EINSCHLUSS,0,krit,paar,
                  (code1[anf1+(i.pos+3)%len1]<<1)+1,(l<<1)+1)) {return(False);}
            }
          }  /* if */
        }   /* for */
      }        /* if (len2==1) */

      if (len2==2 && randcode2[1]==0) {         /* => Einschluss 1b oder 2b */
        for (ii=anz[5][l]; ii>0; ii--) {       /* Typ 5 => 1b */
          i = bind_array[5][ii][l];
          if (paar || i.nr!=j.nr) {
            len1 = code1[i.nr+2] - (anf1 = code1[i.nr+1]);
            wh = verknuepfe_randcodes(&code1[code1[i.nr+1]],nil,len1,2,
                 (POSTYP)(i.pos),0,EINSCHLUSS,ergrandcode,&ergrandlen,nil,nil,
                 nil,True,nil,0,(l<<1)+2);
            if (wh && sortiere_randcodes(i.nr,j.nr,False,code1,
                paar ? code2 : nil,ergrandcode,
                ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil)) {
              if (!verklebung(i,e1,j,e2,g,fl,ergcode,EINSCHLUSS,0,krit,paar,
                  (code1[anf1+(i.pos+1)%len1]<<1)+2,(l<<1)+2)) {return(False);}
            }
          }    /* if */
        }   /* for */
        for (ii=anz[7][l]; ii>0; ii--) {       /* Typ 7 => 2b */
          i = bind_array[7][ii][l];
          if (paar || i.nr!=j.nr) {
            len1 = code1[i.nr+2] - (anf1 = code1[i.nr+1]);
            wh = verknuepfe_randcodes(&code1[code1[i.nr+1]],nil,len1,2,
                 (POSTYP)(i.pos),0,EINSCHLUSS,ergrandcode,&ergrandlen,nil,nil,
                 nil,True,nil,0,(l<<1)+2);
            if (wh && sortiere_randcodes(i.nr,j.nr,False,code1,
                paar ? code2 : nil,ergrandcode,
                ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil)) {
              if (!verklebung(i,e1,j,e2,g,fl,ergcode,EINSCHLUSS,0,krit,paar,
                  (code1[anf1+(i.pos+2)%len1]<<1)+1,(l<<1)+2)) {return(False);}
            }
          }   /* if */
        }   /* for */
      }     /* if (len2==2) */
    }       /* if Bruchkantenrand */
  }         /* for j.nr */

  if (!expand) {return(True);}      /* kein Ueberlauf: fertig */
  }         /* if V_MAX>1 */

  /* Es folgen dieselben Tests nochmal, und zwar fuer den Fall, dass ein
     Ueberlauf aufgetreten ist. Wichtig ist, dass i gross genug ist, wenn
     eine Verknuepfung durchgefuehrt wird, denn sonst ist die Verknuepfung
     bereits oben vorgenommen worden. */
  for (j.nr=0; j.nr<code2[0]; j.nr++) {  /* Randcodes von Patch 2 durchgehen */
    if (code2[code2[j.nr+1]]!=BB_KENNUNG) {   /* => Bruchkantenrand */
      len2 = code2[j.nr+2]-code2[j.nr+1];
      wh2 = ermittle_wh(&code2[code2[j.nr+1]],len2);    /* Wiederholungszahl */
      memcpy(randcode2,&code2[code2[j.nr+1]],sizeof(KNOTENTYP)*(size_t)len2);
      memcpy(&randcode2[len2],randcode2,sizeof(KNOTENTYP)*(size_t)len2);

      for (j.pos=0; j.pos<wh2; j.pos++) {

        /* ungeraden Durchschnitt testen: */
        if (len2>2 && randcode2[j.pos]==0) { 
          l = (randcode2[j.pos+1]<<1)+1;       /*  0 <= anz[x][l] <= V_MAX  */

          if (len2==3) {
            /* Typ 1 => Bauchbinde entsteht */ 
            if (anz[1][l]==V_MAX-1) {          /* moeglicherweise Ueberlauf */
              for (i.nr=bind_array[1][V_MAX-1][l].nr; i.nr<code1[0]; i.nr++) {
                if (paar || i.nr!=j.nr) {
                  anf1 = code1[i.nr+1];
                  len1 = code1[i.nr+2]-anf1;
                  if (len1==3) {             /* Durchschnitt mit BB moeglich */
                               /* insbesondere gilt: Rand 1 ist kein BB-Rand */
                    wh1 = ermittle_wh(&code1[anf1],len1);
                    for (i.pos=(V_MAX>1 && i.nr==bind_array[1][V_MAX-1][l].nr ? 
                         bind_array[1][V_MAX-1][l].pos+1 : 0); i.pos<wh1; i.pos++) {
                      if (code1[anf1+i.pos]==0 && 
                          code1[anf1+(i.pos+1)%len1]==randcode2[j.pos+1]) {
                        ergrandcode[0] = BB_KENNUNG;
                        ergrandcode[1] = code1[anf1+(i.pos+len1-1)%len1] +
                                         randcode2[j.pos+len2-1] + 2;
                        ergrandlen = 2;
                        if (sortiere_randcodes(i.nr,j.nr,False,code1,
                            paar ? code2 : nil,
                            ergrandcode,ergrandlen,nil,0,ergcode,True,
                            nil,nil,nil,nil,nil)) {    /* alles ok */
		  	  if (!verklebung(i,e1,j,e2,g,fl,ergcode,DURCHSCHNITT,
                                          0,krit,paar,l,0)) {return(False);}
                        }
                      }   /* if */
                    }     /* for */
                  }     /* if */
                }       /* if */
              }         /* for */
	    }           /* if */
 
            /* Typ 3 => Bauchbinde entsteht (nur bei Paaren erlaubt) */ 
            if (paar && ungleich && anz[3][l]==V_MAX-1) { 
              /* moeglicherweise Ueberlauf */
              for (i.nr=bind_array[3][V_MAX-1][l].nr; i.nr<code1[0]; i.nr++) {
                anf1 = code1[i.nr+1];
                len1 = code1[i.nr+2]-anf1;
                if (len1==3) {             /* Durchschnitt mit BB moeglich */
                  wh1 = ermittle_wh(&code1[anf1],len1);
                  for (i.pos=(V_MAX>1 && i.nr==bind_array[3][V_MAX-1][l].nr ? 
                       bind_array[3][V_MAX-1][l].pos+1 : 0); i.pos<wh1; (i.pos)++) {
                    if (code1[anf1+i.pos]==0 && 
                        code1[anf1+(i.pos+1)%len1]==randcode2[j.pos+1]) {
                      ergrandcode[0] = BB_KENNUNG;
                      ergrandcode[1] = code1[anf1+(i.pos+len1-1)%len1] +
                                       randcode2[j.pos+len2-1] + 2;
                      ergrandlen = 2;
                      if (sortiere_randcodes(j.nr,i.nr,False,code2,code1,
                          ergrandcode,ergrandlen,nil,0,ergcode,True,
                          nil,nil,nil,nil,nil)) {   /* alles ok */
			if (!verklebung(j,e2,i,e1,g,fl,ergcode,DURCHSCHNITT,0,
                                        krit,paar,l,0)) {return(False);}
                      }
                    }   /* if */
                  }     /* for */
                }       /* if */
              }         /* for */
	    }           /* if */
          }             /* if len2==3 */

          /* Typ 0 => keine BB */ 
          if (anz[0][l]==V_MAX-1) {        /* moeglicherweise Ueberlauf */
            for (i.nr=bind_array[0][V_MAX-1][l].nr; i.nr<code1[0]; i.nr++) {
              if (paar || i.nr!=j.nr) {
                anf1 = code1[i.nr+1];
                len1 = code1[i.nr+2]-anf1;
                if (len1>3) {              /* Durchschnitt ohne BB moeglich */
                  wh1 = ermittle_wh(&code1[anf1],len1);
                  for (i.pos=(V_MAX>1 && i.nr==bind_array[0][V_MAX-1][l].nr ? 
                       bind_array[0][V_MAX-1][l].pos+1 : 0); i.pos<wh1; (i.pos)++) {
                    if (code1[anf1+i.pos]==0 && 
                        code1[anf1+(i.pos+len1-1)%len1]==0 && 
                        code1[anf1+(i.pos+1)%len1]==randcode2[j.pos+1]) {
                      wh = verknuepfe_randcodes(&code1[anf1],randcode2,len1,
                           len2,(POSTYP)(i.pos),(POSTYP)(j.pos),DURCHSCHNITT,
                           ergrandcode,
                           &ergrandlen,nil,nil,nil,True,nil,l,0);
                      if (wh && sortiere_randcodes(i.nr,j.nr,False,code1,
                          paar ? code2 : nil,ergrandcode,
                          ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil)) {
                        if (!verklebung(i,e1,j,e2,g,fl,ergcode,DURCHSCHNITT,0,
                                        krit,paar,l,0)) {return(False);}
                      }
                    }   /* if */
                  }     /* for */
                }     /* if */
              }       /* if */
            }         /* for */
	  }           /* if */

          if (paar && ungleich && len2>3 && randcode2[len2+j.pos-1]==0) {  
            /* Typ 2/3 (nur bei Paaren erlaubt) - keine BB */
            if (anz[2][l]==V_MAX-1) {                  /* Typ 2 */
              for (i.nr=bind_array[2][V_MAX-1][l].nr; i.nr<code1[0]; i.nr++) {
                anf1 = code1[i.nr+1];
                len1 = code1[i.nr+2]-anf1;
                if (len1>3) {                     /* sonst nicht Typ 2 */
                  wh1 = ermittle_wh(&code1[anf1],len1);
                  for (i.pos=(V_MAX>1 && i.nr==bind_array[2][V_MAX-1][l].nr ? 
                       bind_array[2][V_MAX-1][l].pos+1 : 0); i.pos<wh1; (i.pos)++) {
                    if (code1[anf1+i.pos]==0 && 
                        code1[anf1+(i.pos+1)%len1]==randcode2[j.pos+1]) {
                      wh = verknuepfe_randcodes(randcode2,&code1[anf1],len2,
                           len1,(POSTYP)(j.pos),(POSTYP)(i.pos),DURCHSCHNITT,
                           ergrandcode,
                           &ergrandlen,nil,nil,nil,True,nil,l,0);
                      if (wh && sortiere_randcodes(j.nr,i.nr,False,code2,code1,
                          ergrandcode,ergrandlen,nil,0,ergcode,True,
                          nil,nil,nil,nil,nil)) { 
                        if (!verklebung(j,e2,i,e1,g,fl,ergcode,DURCHSCHNITT,0,
                                        krit,paar,l,0)) {return(False);}
                      }
                    }   /* if */
                  }     /* for */
                }       /* if */
              }         /* for */
	    }           /* if */

            if (anz[3][l]==V_MAX-1) {                  /* Typ 3 */
              for (i.nr=bind_array[3][V_MAX-1][l].nr; i.nr<code1[0]; i.nr++) {
                anf1 = code1[i.nr+1];
                len1 = code1[i.nr+2]-anf1;
                if (len1==3) {                     /* sonst nicht Typ 3 */
                  wh1 = ermittle_wh(&code1[anf1],len1);
                  for (i.pos=(V_MAX>1 && i.nr==bind_array[3][V_MAX-1][l].nr ? 
                       bind_array[3][V_MAX-1][l].pos+1 : 0); i.pos<wh1; (i.pos)++) {
                    if (code1[anf1+i.pos]==0 && 
                        code1[anf1+(i.pos+1)%len1]==randcode2[j.pos+1]) {
                      wh = verknuepfe_randcodes(randcode2,&code1[anf1],len2,
                           len1,(POSTYP)(j.pos),(POSTYP)(i.pos),DURCHSCHNITT,
                           ergrandcode,
                           &ergrandlen,nil,nil,nil,True,nil,l,0);
                      if (wh && sortiere_randcodes(j.nr,i.nr,False,code2,code1,
                          ergrandcode,ergrandlen,nil,0,ergcode,True,
                          nil,nil,nil,nil,nil)) {
                        if (!verklebung(j,e2,i,e1,g,fl,ergcode,DURCHSCHNITT,0,
                                        krit,paar,l,0)) {return(False);}
                      }
                    }   /* if */
                  }     /* for */
                }       /* if */
              }         /* for */
	    }           /* if */
          }             /* if len2>3 */
        }               /* ungeraden Durchschnitt testen */

        /* geraden Durchschnitt testen, wobei Patch 2 = links (nur bei
           Paaren erlaubt): */
        if (paar && ungleich && len2>3 && randcode2[j.pos]==0 && 
            randcode2[j.pos+2]==0) {
          l = (randcode2[j.pos+1]<<1)+2;
 
          if (len2==4) {                /* Typ 3 => Bauchbinde entsteht */ 
            if (anz[3][l]==V_MAX-1) {        /* moeglicherweise Ueberlauf */
              for (i.nr=bind_array[3][V_MAX-1][l].nr; i.nr<code1[0]; i.nr++) {
                anf1 = code1[i.nr+1];
                len1 = code1[i.nr+2]-anf1;
                if (len1==2 && code1[anf1]!=BB_KENNUNG) { 
                  /* Rand 1 ist BK-Rand --- Durchschnitt mit BB moeglich */
                  wh1 = ermittle_wh(&code1[anf1],len1);
                  for (i.pos=(V_MAX>1 && i.nr==bind_array[3][V_MAX-1][l].nr ? 
                       bind_array[3][V_MAX-1][l].pos+1 : 0); i.pos<wh1; (i.pos)++) {
                    if (code1[anf1+i.pos]==randcode2[j.pos+1]+1) {
                      ergrandcode[0] = BB_KENNUNG;
                      ergrandcode[1] = code1[anf1+(i.pos+len1-1)%len1] +
                                       randcode2[j.pos+len2-1] + 2;
                      ergrandlen = 2;
                      if (sortiere_randcodes(j.nr,i.nr,False,code2,code1,
                          ergrandcode,ergrandlen,nil,0,ergcode,True,
                          nil,nil,nil,nil,nil)) {    /* alles ok */
			if (!verklebung(j,e2,i,e1,g,fl,ergcode,DURCHSCHNITT,0,
                                        krit,paar,l,0)) {return(False);}
                      }
                    }   /* if */
                  }     /* for */
                }       /* if */
              }         /* for */
	    }           /* if */
          }             /* if len2==4 */
          else if (len2>4 && randcode2[len2+j.pos-1]==0) {
            /* Typ 2/3 => keine Bauchbinde */ 
            if (anz[2][l]==V_MAX-1) {                  /* Typ 2 - keine BB */
              for (i.nr=bind_array[2][V_MAX-1][l].nr; i.nr<code1[0]; i.nr++) {
                anf1 = code1[i.nr+1];
                len1 = code1[i.nr+2]-anf1;
                if (len1>2) {      /* sonst nicht Typ 2 (auch => BK-Rand) */
                  wh1 = ermittle_wh(&code1[anf1],len1);
                  for (i.pos=(V_MAX>1 && i.nr==bind_array[2][V_MAX-1][l].nr ? 
                       bind_array[2][V_MAX-1][l].pos+1 : 0); i.pos<wh1; (i.pos)++) {
                    if (code1[anf1+i.pos]==randcode2[j.pos+1]+1) {
                      wh = verknuepfe_randcodes(randcode2,&code1[anf1],len2,
                           len1,(POSTYP)(j.pos),(POSTYP)(i.pos),DURCHSCHNITT,
                           ergrandcode,&ergrandlen,nil,nil,nil,True,nil,l,0);
                      if (wh && sortiere_randcodes(j.nr,i.nr,False,code2,code1,
                          ergrandcode,ergrandlen,nil,0,ergcode,True,
                          nil,nil,nil,nil,nil)) {
                        if (!verklebung(j,e2,i,e1,g,fl,ergcode,DURCHSCHNITT,0,
                                        krit,paar,l,0)) {return(False);}
                      }
                    }   /* if */
                  }     /* for */
                }       /* if */
              }         /* for */
	    }           /* if */

            if (anz[3][l]==V_MAX-1) {                  /* Typ 3 - keine BB */
              for (i.nr=bind_array[3][V_MAX-1][l].nr; i.nr<code1[0]; i.nr++) {
                anf1 = code1[i.nr+1];
                len1 = code1[i.nr+2]-anf1;
                if (len1==2 && code1[anf1]!=BB_KENNUNG) { 
                  /* sonst nicht Typ 3 oder BB-Rand */
                  wh1 = ermittle_wh(&code1[anf1],len1);
                  for (i.pos=(V_MAX>1 && i.nr==bind_array[3][V_MAX-1][l].nr ? 
                       bind_array[3][V_MAX-1][l].pos+1 : 0); i.pos<wh1; (i.pos)++) {
                    if (code1[anf1+i.pos]==randcode2[j.pos+1]+1) {
                      wh = verknuepfe_randcodes(randcode2,&code1[anf1],len2,
                           len1,(POSTYP)(j.pos),(POSTYP)(i.pos),DURCHSCHNITT,
                           ergrandcode,&ergrandlen,nil,nil,nil,True,nil,l,0);
                      if (wh && sortiere_randcodes(j.nr,i.nr,False,code2,code1,
                          ergrandcode,ergrandlen,nil,0,ergcode,True,
                          nil,nil,nil,nil,nil)) {
                        if (!verklebung(j,e2,i,e1,g,fl,ergcode,DURCHSCHNITT,0,
                                        krit,paar,l,0)) {return(False);}
		      }
                    }   /* if */
                  }     /* for */
                }       /* if */
              }         /* for */
	    }           /* if */
          }             /* if len2>4 */
        }               /* geraden Durchschnitt mit Patch 2 links testen */

        /* geraden Durchschnitt testen, wobei Patch 2 = rechts: */
        if (len2>1) {
          l = randcode2[j.pos]<<1;
      
          if (anz[0][l]==V_MAX-1) {                        /* Typ 0 */
            for (i.nr=bind_array[0][V_MAX-1][l].nr; i.nr<code1[0]; i.nr++) {
              if (paar || i.nr!=j.nr) {
                anf1 = code1[i.nr+1];
                len1 = code1[i.nr+2]-anf1;
                if (len1>4) {  /* (=> BK-Rand) Durchschnitt ohne BB moeglich */
                  wh1 = ermittle_wh(&code1[anf1],len1);
                  for (i.pos=(V_MAX>1 && i.nr==bind_array[0][V_MAX-1][l].nr ? 
                       bind_array[0][V_MAX-1][l].pos+1 : 0); i.pos<wh1; (i.pos)++) {
                    if (code1[anf1+i.pos]==0 && 
                        code1[anf1+(i.pos+len1-1)%len1]==0 && 
                        code1[anf1+(i.pos+2)%len1]==0 && 
                        code1[anf1+(i.pos+1)%len1]+1==randcode2[j.pos]) {
                      wh = verknuepfe_randcodes(&code1[anf1],randcode2,len1,
                           len2,(POSTYP)(i.pos),(POSTYP)(j.pos),DURCHSCHNITT,
                           ergrandcode,&ergrandlen,nil,nil,nil,True,nil,l,0);
                      if (wh && sortiere_randcodes(i.nr,j.nr,False,code1,
                          paar ? code2 : nil,ergrandcode,
                          ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil)) {
                        if (!verklebung(i,e1,j,e2,g,fl,ergcode,DURCHSCHNITT,0,
                                        krit,paar,l,0)) {return(False);}
                      }
                    }   /* if */
                  }   /* for */
                }     /* if */
              }       /* if */
            }         /* for */
	  }           /* if */

          if (len2==2) {                   /* Typ 1 => Bauchbinde */ 
            if (anz[1][l]==V_MAX-1) {
              for (i.nr=bind_array[1][V_MAX-1][l].nr; i.nr<code1[0]; i.nr++) {
                if (paar || i.nr!=j.nr) {
                  anf1 = code1[i.nr+1];
                  len1 = code1[i.nr+2]-anf1;
                  if (len1==4) {    /* (=> BK-Rand) Durchschnitt mit BB mgl. */
                    wh1 = ermittle_wh(&code1[anf1],len1);
                    for (i.pos=(V_MAX>1 && i.nr==bind_array[1][V_MAX-1][l].nr ? 
                         bind_array[1][V_MAX-1][l].pos+1 : 0); i.pos<wh1; i.pos++) {
                      if (code1[anf1+i.pos]==0 && 
                          code1[anf1+(i.pos+2)%len1]==0 && 
                          code1[anf1+(i.pos+1)%len1]+1==randcode2[j.pos]) {
                        ergrandcode[0] = BB_KENNUNG;
                        ergrandcode[1] = code1[anf1+(i.pos+len1-1)%len1] 
                                       + randcode2[len2+j.pos-1] + 2;
                        ergrandlen = 2;
                        if (sortiere_randcodes(i.nr,j.nr,False,code1,
                            paar ? code2 : nil,
                            ergrandcode,ergrandlen,nil,0,ergcode,True,
                            nil,nil,nil,nil,nil)) {
                          if (!verklebung(i,e1,j,e2,g,fl,ergcode,DURCHSCHNITT,
                                          0,krit,paar,l,0)) {return(False);}
                        }
                      }   /* if */
                    }     /* for */
                  }     /* if */
                }       /* if */
              }         /* for */
	    }           /* if */
	  }             /* if len2==2 */
        }               /* geraden Durchschnitt mit Patch 2 rechts */
      }                 /* for j.pos */

      /* Im folgenden werden die Einschluesse getestet, bei denen Patch 2 als
         Patch A fungiert (nur bei Paaren erlaubt). Diese Tests sind in einer 
         eigenen Schleife 
         untergebracht, da meistens die ganze Schleife entfallen kann. */
      if (paar && ungleich && len2>3 && (V_MAX==1 || typ89)) {    
        /* Patch 2 kann Patch A und Patch 1 kann Patch B sein */ 

        i.pos = 0;
        for (j.pos=0; j.pos<wh2; j.pos++) {

          if ((len2==5 || (len2>5 && randcode2[j.pos+len2-1]==0)) && 
              randcode2[j.pos]==0 && randcode2[j.pos+2]==0 && 
              randcode2[j.pos+3]>randcode2[j.pos+1]+(small_face>2)) { 
            l = randcode2[j.pos+3]-randcode2[j.pos+1]-1;      /* Typ 8 - 1a */
            if (anz[8][l]==V_MAX-1) {
              for (i.nr=(V_MAX>1 ? bind_array[8][V_MAX-1][l].nr+1 : 0); 
                   i.nr<code1[0]; i.nr++) {
                anf1 = code1[i.nr+1];
                len1 = code1[i.nr+2]-anf1;
                if (len1==1 && code1[anf1]==l) {    /* Rand 1 ist BK-Rand */
                  wh = verknuepfe_randcodes(randcode2,nil,len2,1,
                       (POSTYP)(j.pos),0,EINSCHLUSS,
                       ergrandcode,&ergrandlen,nil,nil,nil,True,nil,0,
                       (l<<1)+1);
                  if (wh && sortiere_randcodes(j.nr,i.nr,False,code2,
                      code1,ergrandcode,
                      ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil)) {
                    if (!verklebung(j,e2,i,e1,g,fl,ergcode,EINSCHLUSS,0,krit,
                        paar,(randcode2[j.pos+1]<<1)+2,(l<<1)+1)) 
                       {return(False);}
                  }
                }   /* if */
              }     /* for */
            }       /* if */
          }         /* Typ 8 - 1a */

          if ((len2==4 || randcode2[j.pos+len2-1]==0) && randcode2[j.pos]==0 &&
              randcode2[j.pos+2]>randcode2[j.pos+1]+1+(small_face>2)) {
            l = randcode2[j.pos+2]-randcode2[j.pos+1]-2;      /* Typ 9 - 1b */
            if (anz[9][l]==V_MAX-1) {
              for (i.nr=(V_MAX>1 ? bind_array[9][V_MAX-1][l].nr+1 : 0); 
                   i.nr<code1[0]; i.nr++) {
                anf1 = code1[i.nr+1];
                len1 = code1[i.nr+2]-anf1;
                if (len1==2 && code1[anf1+1]==0 && code1[anf1]==l) {
                  /* aus den Bedingungen 1 und 2 folgt: Rand 1 ist BK-Rand */
                  wh = verknuepfe_randcodes(randcode2,nil,len2,2,
                       (POSTYP)(j.pos),0,EINSCHLUSS,
                       ergrandcode,&ergrandlen,nil,nil,nil,True,nil,0,
                       (l<<1)+2);
                  if (wh && sortiere_randcodes(j.nr,i.nr,False,code2,
                      code1,ergrandcode,
                      ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil)) {
                    if (!verklebung(j,e2,i,e1,g,fl,ergcode,EINSCHLUSS,0,krit,
                        paar,(randcode2[j.pos+1]<<1)+2,(l<<1)+2)) 
                       {return(False);}
                  }
                }   /* if */
              }     /* for */
            }       /* if */
          }         /* Typ 9 - 1b */

          if ((len2==5 || (len2>5 && randcode2[j.pos+len2-1]==0)) &&
              randcode2[j.pos]==0 && randcode2[j.pos+2]==0 && 
              randcode2[j.pos+1]>=randcode2[j.pos+3]+(small_face>2)) {
            l = randcode2[j.pos+1]-randcode2[j.pos+3];        /* Typ 8 - 2a */
            if (anz[8][l]==V_MAX-1) {
              for (i.nr=(V_MAX>1 ? bind_array[8][V_MAX-1][l].nr+1 : 0); 
                   i.nr<code1[0]; i.nr++) {
                anf1 = code1[i.nr+1];
                len1 = code1[i.nr+2]-anf1;
                if (len1==1 && code1[anf1]==l) {    /* Rand 1 ist BK-Rand */
                  wh = verknuepfe_randcodes(randcode2,nil,len2,1,
                       (POSTYP)(j.pos),0,EINSCHLUSS,
                       ergrandcode,&ergrandlen,nil,nil,nil,True,nil,0,
                       (l<<1)+1);
                  if (wh && sortiere_randcodes(j.nr,i.nr,False,code2,
                      code1,ergrandcode,
                      ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil)) { 
                    if (!verklebung(j,e2,i,e1,g,fl,ergcode,EINSCHLUSS,0,krit,
                        paar,(randcode2[j.pos+3]<<1)+1,(l<<1)+1)) 
                       {return(False);}
                  }
                }   /* if */
              }     /* for */
            }       /* if */
          }         /* Typ 9 - 1b */

          if ((len2==4 || randcode2[j.pos+len2-1]==0) && randcode2[j.pos]==0 &&
              randcode2[j.pos+1]>randcode2[j.pos+2]+(small_face>2)) {
            l = randcode2[j.pos+1]-randcode2[j.pos+2]-1;      /* Typ 9 - 2b */
            if (anz[9][l]==V_MAX-1) {
              for (i.nr=(V_MAX>1 ? bind_array[9][V_MAX-1][l].nr+1 : 0); 
                   i.nr<code1[0]; i.nr++) {
                anf1 = code1[i.nr+1];
                len1 = code1[i.nr+2]-anf1;
                if (len1==2 && code1[anf1+1]==0 && code1[anf1]==l) {
                  /* aus den Bedingungen 1 und 2 folgt: Rand 1 ist BK-Rand */
                  wh = verknuepfe_randcodes(randcode2,nil,len2,2,
                       (POSTYP)(j.pos),0,EINSCHLUSS,
                       ergrandcode,&ergrandlen,nil,nil,nil,True,nil,0,
                       (l<<1)+2);
                  if (wh && sortiere_randcodes(j.nr,i.nr,False,code2,
                      code1,ergrandcode,
                      ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil)) { 
                    if (!verklebung(j,e2,i,e1,g,fl,ergcode,EINSCHLUSS,0,krit,
                        paar,(randcode2[j.pos+2]<<1)+1,(l<<1)+2)) 
                       {return(False);}
                  }
                }   /* if */
              }     /* for */
            }       /* if */
          }         /* Typ 9 - 1b */
        }           /* for j.pos */
      }      /* Patch 1 als Patch B und Patch 2 als Patch A */

      /* Im folgenden werden die Einschluesse getestet, bei denen Patch 2 als 
         Patch B fungiert. Schleifen ueber j.pos sind nicht notwendig, da die 
         Drehung von Patch 2 immer 0 sein muss. */
      l = randcode2[0];
      j.pos = 0;
      if (len2==1) {                     /* => Einschluss 1a oder 2a */
        if (anz[4][l]==V_MAX-1) {          /* Typ 4 - Einschluss 1a */
          for (i.nr=bind_array[4][V_MAX-1][l].nr; i.nr<code1[0]; i.nr++) {
            if (paar || i.nr!=j.nr) {
              anf1 = code1[i.nr+1];
              len1 = code1[i.nr+2]-anf1;
              if (len1>4) {      /* (=> BK-Rand) Einschluss moeglich */
                wh1 = ermittle_wh(&code1[anf1],len1);
                for (i.pos=(V_MAX>1 && i.nr==bind_array[4][V_MAX-1][l].nr ? 
                     bind_array[4][V_MAX-1][l].pos+1 : 0); i.pos<wh1; (i.pos)++) {
                  if ((len1==5 || code1[anf1+(i.pos+len1-1)%len1]==0) && 
                      code1[anf1+i.pos]==0 && code1[anf1+(i.pos+2)%len1]==0 && 
                      code1[anf1+(i.pos+3)%len1]==
                      code1[anf1+(i.pos+1)%len1]+1+l) {
                    wh = verknuepfe_randcodes(&code1[anf1],nil,len1,1,
                         (POSTYP)(i.pos),0,EINSCHLUSS,ergrandcode,&ergrandlen,
                         nil,nil,nil,True,nil,0,(l<<1)+1);
                    if (wh && sortiere_randcodes(i.nr,j.nr,False,code1,
                        paar ? code2 : nil,ergrandcode,
                        ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil)) {
                      if (!verklebung(i,e1,j,e2,g,fl,ergcode,EINSCHLUSS,0,krit,
                          paar,(code1[anf1+(i.pos+1)%len1]<<1)+2,(l<<1)+1))
                         {return(False);}
                    }
                  }   /* if */
                }     /* for */
              }     /* if */
            }       /* if */
          }         /* for */
        }           /* if */

        if (anz[6][l]==V_MAX-1) {          /* Typ 6 - Einschluss 2a */
          for (i.nr=bind_array[6][V_MAX-1][l].nr; i.nr<code1[0]; i.nr++) {
            if (paar || i.nr!=j.nr) {
              anf1 = code1[i.nr+1];
              len1 = code1[i.nr+2]-anf1;
              if (len1>4) {          /* (=> BK-Rand) Einschluss moeglich */
                wh1 = ermittle_wh(&code1[anf1],len1);
                for (i.pos=(V_MAX>1 && i.nr==bind_array[6][V_MAX-1][l].nr ? 
                     bind_array[6][V_MAX-1][l].pos+1 : 0); i.pos<wh1; (i.pos)++) {
                  if ((len1==5 || code1[anf1+(i.pos+len1-1)%len1]==0) && 
                      code1[anf1+i.pos]==0 && code1[anf1+(i.pos+2)%len1]==0 && 
                      code1[anf1+(i.pos+1)%len1]==
                      code1[anf1+(i.pos+3)%len1]+l) {
                    wh = verknuepfe_randcodes(&code1[anf1],nil,len1,1,
                         (POSTYP)(i.pos),0,EINSCHLUSS,ergrandcode,&ergrandlen,
                         nil,nil,nil,True,nil,0,(l<<1)+1);
                    if (wh && sortiere_randcodes(i.nr,j.nr,False,code1,
                        paar ? code2 : nil,ergrandcode,
                        ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil)) {
                      if (!verklebung(i,e1,j,e2,g,fl,ergcode,EINSCHLUSS,0,krit,
                          paar,(code1[anf1+(i.pos+3)%len1]<<1)+1,(l<<1)+1))
                         {return(False);}
                    }
                  }   /* if */
                }     /* for */
              }     /* if */
            }       /* if */
          }         /* for */
        }           /* if */
      }             /* if len2==1 */

      if (len2==2 && randcode2[1]==0) {     /* => Einschluss 1b oder 2b */
        if (anz[5][l]==V_MAX-1) {          /* Typ 5 - Einschluss 1b */
          for (i.nr=bind_array[5][V_MAX-1][l].nr; i.nr<code1[0]; i.nr++) {
            if (paar || i.nr!=j.nr) {
              anf1 = code1[i.nr+1];
              len1 = code1[i.nr+2]-anf1;
              if (len1>3) {       /* (=> BK-Rand) Einschluss moeglich */
                wh1 = ermittle_wh(&code1[anf1],len1);
                for (i.pos=(V_MAX>1 && i.nr==bind_array[5][V_MAX-1][l].nr ? 
                     bind_array[5][V_MAX-1][l].pos+1 : 0); i.pos<wh1; (i.pos)++) {
                  if ((len1==4 || code1[anf1+(i.pos+len1-1)%len1]==0) && 
                      code1[anf1+i.pos]==0 && 
                      code1[anf1+(i.pos+2)%len1]==
                      code1[anf1+(i.pos+1)%len1]+2+l) {
                    wh = verknuepfe_randcodes(&code1[anf1],nil,len1,2,
                         (POSTYP)(i.pos),0,EINSCHLUSS,ergrandcode,&ergrandlen,
                         nil,nil,nil,True,nil,0,(l<<1)+2);
                    if (wh && sortiere_randcodes(i.nr,j.nr,False,code1,
                        paar ? code2 : nil,ergrandcode,
                        ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil)) {
                      if (!verklebung(i,e1,j,e2,g,fl,ergcode,EINSCHLUSS,0,krit,
                          paar,(code1[anf1+(i.pos+1)%len1]<<1)+2,(l<<1)+2))
                         {return(False);}
                    }
                  }   /* if */
                }     /* for */
              }     /* if */
            }       /* if */
          }         /* for */
        }           /* if */
        if (anz[7][l]==V_MAX-1) {          /* Typ 7 - Einschluss 2b */
          for (i.nr=bind_array[7][V_MAX-1][l].nr; i.nr<code1[0]; i.nr++) {
            if (paar || i.nr!=j.nr) {
              anf1 = code1[i.nr+1];
              len1 = code1[i.nr+2]-anf1;
              if (len1>3) {     /* (=> BK-Rand) Einschluss moeglich */
                wh1 = ermittle_wh(&code1[anf1],len1);
                for (i.pos=(V_MAX>1 && i.nr==bind_array[7][V_MAX-1][l].nr ? 
                        bind_array[7][V_MAX-1][l].pos+1 : 0); i.pos<wh1; (i.pos)++) {
                  if ((len1==4 || code1[anf1+(i.pos+len1-1)%len1]==0) && 
                      code1[anf1+i.pos]==0 && 
                      code1[anf1+(i.pos+1)%len1]==
                      code1[anf1+(i.pos+2)%len1]+1+l) {
                    wh = verknuepfe_randcodes(&code1[anf1],nil,len1,2,
                         (POSTYP)(i.pos),0,EINSCHLUSS,ergrandcode,&ergrandlen,
                         nil,nil,nil,True,nil,0,(l<<1)+2);
                    if (wh && sortiere_randcodes(i.nr,j.nr,False,code1,
                        paar ? code2 : nil,ergrandcode,
                        ergrandlen,nil,0,ergcode,True,nil,nil,nil,nil,nil)) {
                      if (!verklebung(i,e1,j,e2,g,fl,ergcode,EINSCHLUSS,0,krit,
                          paar,(code1[anf1+(i.pos+2)%len1]<<1)+1,(l<<1)+2))
                         {return(False);}
                    }
                  }   /* if */
                }     /* for */
              }     /* if */
            }       /* if */
          }         /* for */
        }           /* if */
      }             /* if len2==2 ... */
    }               /* if Bruchkantenrand */
  }                 /* for j.nr */
  return(True);
}

/*********************VERKNUEPFE_PATCH_FALL1*********************************/
/* Fuer Patches, bei denen ein Rand mit sich selbst verklebt wird (Fall 1). */
/* Prueft, ob die uebergebenen Patches aus der Liste, die mit "e" beginnt,
   mit sich selbst
   verbunden werden koennen (alle Patches haben denselben Bordercode)       */
/* g = Genus in den potentiellen Ergebnispatches                            */
/* fl = Anzahl Flaechen in den potentiellen Ergebnispatches                 */
/* Fuer j.nr muessen alle erlaubten Werte bestimmt werden.                  */

BOOL verknuepfe_patch_fall1(ELEM *e,KNOTENTYP *code,KNOTENTYP g,
     KNOTENTYP fl,KNOTENTYP krit) {
  static BORDERPOS i,j;                /* Verschiebungen im Randcode */
  static KNOTENTYP randcode[2*N_MAX_P];  /* fuer 2 Kopien eines Randcodes */
  static KNOTENTYP wh,anf,len;         /* zugehoerige Werte */
  static KNOTENTYP ergrandcode[2*N_MAX_P];     /* fuer RANDcode (2 Kopien) */
  static KNOTENTYP ergrandlen;               /* fuer RANDcode */
  static KNOTENTYP ergrandcode2[2*N_MAX_P];    /* fuer RANDcode (2 Kopien) */
  static KNOTENTYP ergrandlen2;              /* fuer RANDcode */
  static KNOTENTYP offset2;                  /* fuer Randcodemaximierung */
  static KNOTENTYP ergcode[N_MAX_P+3];         /* fuer BORDERcode */
  static KNOTENTYP ergwh;   /* ergwh!=0 => kanonische Verknuepfung gefunden */
  static KNOTENTYP jj;
  static KNOTENTYP bb2,rl2,rlg2,wh2,nr2;     /* fuer den zweiten entstandenen 
         Rand: bb2==True <=> Rand 2 BB-Rand, rl2 = Periodenlaenge (in Kanten),
         rlg2 = Gesamtlaenge (in Kanten), wh2 = Periodenlaenge 
         (in Randcodeeintraegen), nr2 = Nummer im Bordercode */

  for (i.nr=0; i.nr<code[0] && (len=code[i.nr+2]-(anf=code[i.nr+1]))>5; 
       i.nr++) {
    /* Randcodes durchlaufen, die lang genug sind */
    memcpy(randcode,&code[anf],sizeof(KNOTENTYP)*(size_t)len);
    memcpy(&randcode[len],randcode,sizeof(KNOTENTYP)*(size_t)len);
    wh = ermittle_wh(randcode,len);    /* Wiederholungszahl */
    
    for (i.pos=0; i.pos<wh; i.pos++) {

      if (randcode[i.pos]==0 /*&& (len==6 || randcode[i.pos+len-1]==0)*/) {
         /* Durchschnitt moeglich. Falls die Laenge des Randcodes groesser
            als 6 ist, so muss der aktuellen Position nicht unbedingt eine
            0 vorangehen, denn einer der beiden resultierenden Raender kann 
            ja eine Bauchbinde werden. */

        /* geraden Durchschnitt testen: */
        if (randcode[i.pos+2]==0) {    /* Codeausschnitt passt */
          for (j.pos=0; j.pos<len; j.pos++) {
            if (randcode[j.pos]==randcode[i.pos+1]+1 
                /* => randcode[j]!=0 => j \not\in \{i,i+1,i+2\} */
                && !(j.pos==(i.pos+len-1)%len || j.pos==(i.pos+3)%len)) { 
                /* keine Ueberschneidung der Codes */
              ergwh = verknuepfe_randcodes(randcode,nil,len,len,i.pos,j.pos,
                      VERBINDUNG,ergrandcode,
                      &ergrandlen,ergrandcode2,&ergrandlen2,&offset2,True,
                      &(j.nr),randcode[j.pos]<<1,0);
              if (ergwh && sortiere_randcodes(i.nr,i.nr,True,code,
                  nil,ergrandcode,ergrandlen,&ergrandcode2[offset2],
                  ergrandlen2,ergcode,True,nil,nil,nil,nil,&nr2)) {
                bb2 = (ergrandlen2==2 && ergrandcode2[offset2]==BB_KENNUNG);
                if (bb2) {rl2 = 2;  rlg2 = ergrandcode2[offset2+1]<<1;} 
                else {
                  wh2 = ermittle_wh(&ergrandcode2[0],ergrandlen2);
                  /* Offset muss 0 sein, weil der Code nur zweimal 
                     hintereinander im Speicher steht. Aber da die Periode die
                     gleiche ist, ist auch das Ergebnis das gleiche. */
                  rl2 = randlaenge(&ergrandcode2[offset2],0,wh2-1);
                  rlg2 = rl2*(ergrandlen2/wh2);
                }
                jj = (rlg2/rl2-1)/8+1;  /* Anzahl wichtiger Elemente im 
                                           akzeptiert-array */
                if (!verklebung_fall1(i,e,j,g,fl,ergcode,0,krit,nr2,rl2,rlg2,
                    jj,randcode[j.pos]<<1,0)) {return(False);}
	      }
	    }  /* if */
          }    /* for */
        }      /* if */
        
        /* ungeraden Durchschnitt testen: */
        for (j.pos=0; j.pos<len; j.pos++) {
          if (randcode[j.pos]==0 && randcode[j.pos+1]==randcode[i.pos+1] && 
              !(j.pos==i.pos || (j.pos+1)%len==i.pos || (j.pos+2)%len==i.pos ||
                (j.pos+len-1)%len==i.pos || (j.pos+len-2)%len==i.pos)) {  
              /* keine Ueberschneidung */
            ergwh = verknuepfe_randcodes(randcode,nil,len,len,i.pos,j.pos,
               VERBINDUNG,ergrandcode,
               &ergrandlen,ergrandcode2,&ergrandlen2,&offset2,True,&(j.nr),
               (randcode[j.pos+1]<<1)+1,0);
            if (ergwh && sortiere_randcodes(i.nr,i.nr,True,code,
                nil,ergrandcode,ergrandlen,&ergrandcode2[offset2],
                ergrandlen2,ergcode,True,nil,nil,nil,nil,&nr2)) {
              bb2 = (ergrandlen2==2 && ergrandcode2[offset2]==BB_KENNUNG);
              if (bb2) {rl2 = 2;  rlg2 = ergrandcode2[offset2+1]<<1;} 
              else {
                wh2 = ermittle_wh(&ergrandcode2[0],ergrandlen2);
                /* Offset 0, weil der Code nur zweimal hintereinander im
                   Speicher steht. Das Ergebnis ist das gleiche. */
                rl2 = randlaenge(&ergrandcode2[offset2],0,wh2-1);
                rlg2 = rl2*(ergrandlen2/wh2);
              }
              jj = (rlg2/rl2-1)/8+1;  /* Anzahl wichtiger Elemente im 
                                         akzeptiert-array */
              if (!verklebung_fall1(i,e,j,g,fl,ergcode,0,krit,nr2,rl2,rlg2,
                  jj,(randcode[j.pos+1]<<1)+1,0)) {return(False);}
            }
	  }  /* if */
        }    /* for */
      }      /* if */
    }        /* for i.pos */
  }          /* for i.nr */
  return(True);
}

/**********************GENERIERE_BIND_TABELLE********************************/
/*  Sucht alle moeglichen Verknuepfungen des Patches heraus, dessen Border-
    code uebergeben wird. Voraussetzung: alle anz-Elemente sind auf 0.      */
/*  Da V_MAX >= 4, kann in allen Faellen, wo eine Abfrage "if (len==x)"
    erfolgt, die Abfrage "if (anz<V_MAX)" entfallen. Es gilt naemlich
    4 >= x == len >= anz, so dass kein Ueberlauf auftreten kann.            */
/*  Sobald die Bedingung "if (anz<V_MAX)" einmal nicht zutrifft, wird die
    Variable "expand" auf True gesetzt.                                     */
/*  An der Stelle, wo ein Ueberlauf auftritt, wird der zugehoerige anz-Wert
    auf V_MAX+1 gesetzt, auch wenn natuerlich nur V_MAX Arrayelemente besetzt
    sind, */
/*  Fuer die Faelle 4-7 (Patch A bei Einschluss) kann der resultierende
    Bordercode unabhaengig von Patch B bereits berechnet werden. Somit kann
    auch schon an dieser Stelle geprueft werden, ob der resultierende Code
    kanonisch ist. */
/*  "typ89":  siehe "verknuepfe_patches"                                    */
/*  "paar" gibt an, ob es beabsichtigt ist, die Patches mit dem uebergebenen
    Bordercode mit sich selbst (False) oder mit anderen Patches (True) zu
    verkleben.                                                              */

void generiere_bind_tabelle(KNOTENTYP *code,BOOL *expand,BOOL *typ89,
                            BOOL paar) {
  static KNOTENTYP i,j,l;
  static KNOTENTYP wh,len;              /* fuer einen RANDcode */
  static KNOTENTYP randcode[3*N_MAX_P];       
  static KNOTENTYP ergcode[3*N_MAX_P];    /* fuer Faelle 4-7 (dummy) */
  static KNOTENTYP erglen;              /* fuer Faelle 4-7 (dummy) */

  if (V_MAX==1) {return;}   /* keine bind-Tabelle */

  *typ89 = *expand = False;
  for (j=0; j<code[0]; j++) {                   /* Randcodes durchgehen */
    if (code[code[j+1]]!=BB_KENNUNG) {     /*  =>  Bruchkantenrand */  
      len = code[j+2]-code[j+1]; 
      wh = ermittle_wh(&code[code[j+1]],len);   /* Wiederholungszahl */
      memcpy(randcode,&code[code[j+1]],sizeof(KNOTENTYP)*(size_t)len);
      memcpy(&randcode[len],randcode,sizeof(KNOTENTYP)*(size_t)len);
      memcpy(&randcode[len<<1],randcode,sizeof(KNOTENTYP)*(size_t)len);
       
      if (paar) {        /* sonst Typen 8 und 9 nicht erlaubt */
        if (len==1) {                                             /* Typ 8 */
          i = randcode[0];   /* erster (hier einziger) Eintrag in Randcode */
          *typ89 = True;
          if (anz[8][i]<V_MAX-1) {bind_array[8][++anz[8][i]][i].nr = j;
                                  bind_array[8][anz[8][i]][i].pos = 0;}
          else {*expand = True;} 
        }
        else if (len==2 && randcode[1]==0) {                      /* Typ 9 */
          /* "else" aus Geschwindigkeitsgruenden */
          i = randcode[0];   /* erster Eintrag in Randcode */
          *typ89 = True;
          if (anz[9][i]<V_MAX-1) {bind_array[9][++anz[9][i]][i].nr = j;
                                  bind_array[9][anz[9][i]][i].pos = 0;}
          else {*expand = True;} 
        }  
      }

      for (i=len; i<wh+len; i++) {   /* => i-len ist immer noch >=0 */
        if (randcode[i]) {    /* Unterteilung lohnt, da randcode[i] 
                                 immer wichtig ist */
          if (paar) {         /* sonst Typen 2 und 3 nicht erlaubt */
            if (len>2) {                                          /* Typ 2 */ 
              l = randcode[i]<<1;
              if (anz[2][l]<V_MAX-1) {bind_array[2][++anz[2][l]][l].nr = j;
                                      bind_array[2][anz[2][l]][l].pos = i-len;}
              else {*expand = True;}
            }
            else if (len==2) {                                    /* Typ 3 */
              l = randcode[i]<<1;    
              if (anz[3][l]<V_MAX-1) {bind_array[3][++anz[3][l]][l].nr = j;
                                      bind_array[3][anz[3][l]][l].pos = i-len;}
              else {*expand = True;}
            }
          }
        }
        else {                                         /* randcode[i]==0 */
          if (len>4 && randcode[i+2]==0 && randcode[i-1]==0) {  /* Typ 0 */
            l = (randcode[i+1]<<1)+2; 
            if (anz[0][l]<V_MAX-1) {bind_array[0][++anz[0][l]][l].nr = j;
                                    bind_array[0][anz[0][l]][l].pos = i-len;}
            else {*expand = True;}
          }
          else if (len==4 && randcode[i+2]==0) {                /* Typ 1 */
            l = (randcode[i+1]<<1)+2; 
            if (anz[1][l]<V_MAX-1) {bind_array[1][++anz[1][l]][l].nr = j;
                                    bind_array[1][anz[1][l]][l].pos = i-len;}
            else {*expand = True;}
          }
          if (len>3 && randcode[i-1]==0) {                      /* Typ 0 */
            l = (randcode[i+1]<<1)+1;
            if (anz[0][l]<V_MAX-1) {bind_array[0][++anz[0][l]][l].nr = j;
                                    bind_array[0][anz[0][l]][l].pos = i-len;}
            else {*expand = True;}
          }
          else if (len==3) {                                    /* Typ 1/3 */
            l = (randcode[i+1]<<1)+1;
            if (anz[1][l]<V_MAX-1) {   /* falls Paar:  <=> anz[3][l]<V_MAX-1 */
              bind_array[1][++anz[1][l]][l].nr = j;
              bind_array[1][anz[1][l]][l].pos = i-len;
              if (paar) {bind_array[3][++anz[3][l]][l].nr = j;
                         bind_array[3][anz[3][l]][l].pos = i-len;}
            }
            else {*expand = True;}
          }
          if (paar && len>3) {          /* Typ 2 - nur bei Paaren erlaubt */
            l = (randcode[i+1]<<1)+1;
            if (anz[2][l]<V_MAX-1) {bind_array[2][++anz[2][l]][l].nr = j;
                                    bind_array[2][anz[2][l]][l].pos = i-len;}
            else {*expand = True;}
          }
          if ((len==5 || (len>5 && randcode[i-1]==0)) && 
              randcode[i+2]==0 && randcode[i+3]>randcode[i+1]+(small_face>2) &&
              verknuepfe_randcodes(randcode,nil,len,0,i-len,0,EINSCHLUSS,
                                   ergcode,&erglen,nil,nil,nil,True,nil,0,
              ((l = randcode[i+3]-randcode[i+1]-1)<<1)+1)) {     /* Typ 4 */ 
            if (anz[4][l]<V_MAX-1) {bind_array[4][++anz[4][l]][l].nr = j;
                                    bind_array[4][anz[4][l]][l].pos = i-len;}
            else {*expand = True;}
          }
          if ((len==4 || (len>4 && randcode[i-1]==0)) && 
              randcode[i+2]>randcode[i+1]+1+(small_face>2) &&    /* Typ 5 */
              verknuepfe_randcodes(randcode,nil,len,0,i-len,0,EINSCHLUSS,
                                   ergcode,&erglen,nil,nil,nil,True,nil,0,
                                ((l = randcode[i+2]-randcode[i+1]-2)<<1)+2)) { 
            if (anz[5][l]<V_MAX-1) {bind_array[5][++anz[5][l]][l].nr = j;
                                    bind_array[5][anz[5][l]][l].pos = i-len;}
            else {*expand = True;}
          }
          if ((len==5 || (len>5 && randcode[i-1]==0)) &&       /* Typ 6 */
              randcode[i+2]==0 && randcode[i+1]>=randcode[i+3]+(small_face>2) 
              && verknuepfe_randcodes(randcode,nil,len,0,i-len,0,EINSCHLUSS,
                           ergcode,&erglen,nil,nil,nil,True,nil,0,
                                 ((l = randcode[i+1]-randcode[i+3])<<1)+1)) { 
            if (anz[6][l]<V_MAX-1) {bind_array[6][++anz[6][l]][l].nr = j;
                                    bind_array[6][anz[6][l]][l].pos = i-len;}
            else {*expand = True;}
          }
          if ((len==4 || (len>4 && randcode[i-1]==0)) && 
              randcode[i+1]>randcode[i+2]+(small_face>2) &&      /* Typ 7 */
              verknuepfe_randcodes(randcode,nil,len,0,i-len,0,EINSCHLUSS,
                                   ergcode,&erglen,nil,nil,nil,True,nil,0,
                                ((l = randcode[i+1]-randcode[i+2]-1)<<1)+2)) { 
            if (anz[7][l]<V_MAX-1) {bind_array[7][++anz[7][l]][l].nr = j;
                                    bind_array[7][anz[7][l]][l].pos = i-len;}
            else {*expand = True;}
          }
        }
      }
    }      
  }
}
 
/**********************SUCHE_PASSENDE_PATCHES********************************/
/*  Sucht zu einem Bordercode alle Patches, die kleiner oder gleich sind
    (wobei als Ordnung die Reihenfolge, in der ein Patch im Baum gefunden
    wird, gilt) und sich mit den zum Bordercode gehoerenden Patches
    zusammennaehen lassen.                                                  */
/*  Die Rekursion wird in zwei Teile geteilt:
    Teil 1 durchlaeuft die Laengen der Randcodes
    Teil 2 durchlaeuft die Randcodes selbst
    Da die Anzahl der Bruchkanten weitgehend mit den Laengen der Randcodes
    uebereinstimmt (Ausnahme: Bauchbindenrand), kann das Eulerkriterium
    bereits bei Teil 1 angewendet werden.
    In exakter Form wird das Eulerkriterium dann nochmals bei Teil 2 
    angewendet (jede Variante maximal einmal, naemlich sobald die exakte
    Anzahl Bruchkanten feststeht und eine Verschaerfung darstellt).         */
/*  k1 ist die Anzahl der Bruchkanten in Patch 1, k2 die Mindestzahl in
    den Ergebnispatches. k2 enthaelt nur sinnvollen Wert, wenn pv>1, 
    aber wird auch nur gebraucht, wenn pv>2.                                */
/*  anz_bb_in2 (nur bei Teil 2) enthaelt die Anzahl der bislang in Code 2 
    gefundenen Bauchbindenraender. Immer wenn eine neue Bauchbinde gefunden
    wird, lohnt sich die erneute Anwendung des Eulerkriteriums fuer grosse 
    Flaechen.                                                               */
/*  typ89: siehe "verknuepfe_patches"                                       */
/*  Falls pv<2 bzw. pv<3, so bleiben "eulerkrit1" und "eulerkrit2" immer 
    "True".                                                                 */
/*  Rueckgabewert:  True => Ende erreicht (zumindest fuer den vorliegenden
    Patch 1, aber evtl. sogar ganz wegen des Speicherbedarfs)               */

BOOL suche_passende_patches_rek2(TREENODE **root1,KNOTENTYP *bordercode1,
     KNOTENTYP len1,TREENODE **root2,KNOTENTYP *bordercode2,KNOTENTYP len2,
     KNOTENTYP g,KNOTENTYP fl,BOOL expand,KNOTENTYP krit,
     KNOTENTYP k1,POSTYP k2,KNOTENTYP anz_bb_in2,BOOL typ89) {
  static BOOL bb_in2_new, eulerkrit1, eulerkrit2;
  static POSTYP flaechen_neu,r,k;
       /* static ist moeglich, da die Werte nur vor der Rekursion gebraucht
          werden */
  while (root2[len2]) {     /* einen Level durchgehen */
    bordercode2[len2] = root2[len2]->code; 
    /* ab hier ist "len2" um 1 zu niedrig */
    eulerkrit1 = eulerkrit2 = True;     
                 /* kann fuer jeden Zweig unterschiedlich sein */
    bb_in2_new = (bordercode2[len2]==BB_KENNUNG);
    if (/*pv>2 && */bb_in2_new) {   /* Bauchbindenrand gefunden => scharfes 
         Eulerkriterium fuer grosse Flaechen kann angewendet werden, da
         sich Hoechstzahl Bruchkanten verringert */ 
      if (anz_bb_in2>0) {eulerkrit1 = False;}   /* Zu viele BB-Raender:
             Bei zwei BB-Raendern gibt es keine Patcherweiterung mehr */
      else {
        r = bordercode1[0]+bordercode2[0]-1; 
            /* Anzahl der Raender in den potentiellen neuen Patches */
        k = k2 + 2*(bordercode2[0]==2);
          /* Hoechstzahl Bruchkanten in Patches */ 
          /* genauer genommen kommen +2 fuer moeglichen 1.Bauchbindenrand und
             -2 fuer gefundenen Bauchbindenrand hinzu (hebt sich auf) sowie
             -2*anz_bb_in2 fuer bereits gefundene BB-Raender (muss 0 sein). */ 
          /* weitere Kommentare siehe "suche_passende_patches_rek1 */
        if (12*((POSTYP)genus_anf-(POSTYP)g) > 6*r+k) {
          /* neue grosse Flaechen */
          if (big_face>6) {               /* neue grosse Flaechen moeglich */
            flaechen_neu = (12*((POSTYP)genus_anf-(POSTYP)g)-6*r-k-1)/
                           (big_face-6)+1;
            if (fl+flaechen_neu > f_max[MAX(g+r-1,genus_anf)]) 
               {eulerkrit1 = False;}
          }
          else {eulerkrit1 = False;}        /* kein Ausgleich moeglich */ 
        }
      }
    }
    if (/*pv>2 && */len2==bordercode2[bordercode2[0]] && 
        anz_bb_in2+(bb_in2_new==True) < 1+(bordercode2[0]==2)) {
      /* letzten Randcode erreicht und weniger Bauchbindenraender gefunden als
         moeglich => scharfes Eulerkriterium fuer kleine Flaechen kann 
         angewendet werden */
      r = bordercode1[0]+bordercode2[0]-1; 
          /* Anzahl der Raender in den potentiellen neuen Patches */
      k = k2 + 2*(1+(bordercode2[0]==2)-anz_bb_in2-(bb_in2_new==True));
          /* exakte Anzahl Bruchkanten in den Ergebnispatches */
          /* weitere Kommentare siehe "suche_passende_patches_rek1 */
      if (12*(POSTYP)(genus_end-g) < 6*r+k) {    /* neue kleine Flaechen */
        if (small_face<6) {              /* neue kleine Flaechen moeglich */
          flaechen_neu = (6*r+k-12*(genus_end-g)-1)/(6-small_face)+1;
          if (fl+flaechen_neu > f_max[MAX(g+r-1,genus_anf)]) 
             {eulerkrit2 = False;}
        }
        else {eulerkrit2 = False;}         /* kein Ausgleich moeglich */
      }
    } 
    if (eulerkrit1 && eulerkrit2) {        /* weiter im Baum */
      if (len2+1<bordercode2[bordercode2[0]+1]) {   /* kein Codeende */
        root2[len2+1] = root2[len2]->weiter.nextlevel;
        if (suche_passende_patches_rek2(root1,bordercode1,len1,
            root2,bordercode2,len2+1,g,fl,expand,krit,
            k1,k2,anz_bb_in2+(bb_in2_new==True),typ89)) {return(True);}
      }
      else {                               /* Patchpaar gefunden */
        if (!verknuepfe_patches(root1[len1-1]->weiter.firstpatch,bordercode1,
            root2[len2]->weiter.firstpatch,bordercode2,g,fl,expand,krit,typ89,
            True)) {return(True);}
      }
    }  /* if */
    if (len2<len1 && root2[len2]==root1[len2]) {return(True);} 
       /* zweite Liste erreicht erste => alle gesuchten Codepaare gebildet */  
    else {root2[len2] = root2[len2]->next;}
  }    /* while */
  return(False);
}

BOOL suche_passende_patches_rek1(TREENODE **root1,KNOTENTYP *bordercode1,
     KNOTENTYP len1,TREENODE **root2,KNOTENTYP *bordercode2,KNOTENTYP len2,
     KNOTENTYP g,KNOTENTYP fl,BOOL expand,KNOTENTYP krit,
     KNOTENTYP k1,BOOL typ89) {
  static BOOL eulerkrit1;
  static POSTYP flaechen_neu,r,k;
       /* static ist moeglich, da die Werte nur vor der Rekursion gebraucht
          werden */
  BOOL genuskrit = True, eulerkrit2 = True;  
       /* Variablen nicht static wegen Rekursion */
  while (root2[len2] && genuskrit && eulerkrit2) {
    /* einen Level durchgehen */
    if (topdown && len2==0) {
      if (fl==fmax_g[g] && bordercode1[0] + root2[0]->code -1 > bmax_g[g]) 
         {return(True);}  /* beim vorliegenden und allen folgenden Zweigen 
                             wuerden zu viele Raender entstehen */
    }
    bordercode2[len2] = root2[len2]->code; 
    /* ab hier ist "len2" um 1 zu niedrig */
    eulerkrit1 = True;       /* kann fuer jeden Zweig unterschiedlich sein */
    r = bordercode1[0]+bordercode2[0]-1; 
        /* Anzahl der Raender in den potentiellen neuen Patches */
    if (g+r-1 > genus_end) {genuskrit = False;}  /* Genuskriterium versagt */
    else if (/*pv>1 &&*/ len2>1) {
            /* Eulerkriterium kann angewendet werden, da eine
               Mindestzahl fuer die Bruchkanten in Patch 2 vorliegt */
      k = (POSTYP)k1 + (POSTYP)(bordercode2[len2]) - (POSTYP)(bordercode2[0]) 
          - 10 - 2*(bordercode2[0]==2);   
          /* Mindestanzahl der Bruchkanten in potentiellen neuen Patches */ 
          /* bordercode2[bordercode2[0]+1]-bordercode2[0]-2 waere die Laenge
             aller Randcodes in Patch 2 zusammen. Das waere gleichzeitig die
             Anzahl Bruchkanten dort (sofern der Patch keinen Bauchbindenrand
             besitzt). bordercode2[bordercode2[0]+1] ist jedoch noch nicht 
             sicher belegt, deshalb muss bei Patch 2 die Mindestanzahl 
             Bruchkanten durch den aktuellen Wert bordercode2[len2] 
             ermittelt werden. Desweiteren werden 6 Kanten 
             abgezogen, die bei einer beliebigen Verklebung entfallen. 
             Schliesslich werden 2-4 Kanten abgezogen, die eventuell zuviel 
             gezaehlt wurden, weil in Patch 2 1-2 Bauchbinden auftreten 
             koennen, die im Bordercode mit 2-4 Eintraegen zu Buche schlagen,
             die nicht zu Bruchkanten korrespondieren. Falls zwei Bauchbinden
             auftreten, so darf der Patch zwar eh nicht verklebt werden, aber
             eventuell einige der Patches, die spaeter im Baum gespeichert 
             sind. Deswegen darf an dieser Stelle nur dann davon ausgegangen
             werden, dass der Patch maximal einen BB-Rand hat, wenn 
             bordercode2[0]!=2 (siehe "passt_anz_bb"). */
          /* Falls keine Bauchbinde in Patch 2 vorliegt, so ist k um 2-4 zu 
             niedrig (macht aber nichts, ist nur weniger effektiv). */
      if (12*(POSTYP)(genus_end-g) < 6*r+k) {  /* neue kleine Flaechen */
        if (small_face<6) {             /* neue kleine Flaechen moeglich */
          flaechen_neu = (6*r+k-12*(genus_end-g)-1)/(6-small_face)+1;
          if (fl+flaechen_neu > f_max[MAX(g+r-1,genus_anf)]) 
             {eulerkrit2 = False;}
        }
        else {eulerkrit2 = False;}         /* kein Ausgleich moeglich */
      }
      else if (len2==bordercode2[0]+1 && 12*((POSTYP)genus_anf-(POSTYP)g) >
                                         6*r+k+2+2*(bordercode2[0]==2)) { 
         /* neue grosse Flaechen */
         /* nur wenn len2==bordercode2[0]+1 ist, steht die Maximalzahl
            Bruchkanten fest. Sie betraegt k+2+2*(bordercode2[0]==2), 
            wobei die Zahl je nach Anzahl der BB-Raender um 2-4 zu hoch ist. */
        if (big_face>6) {               /* neue grosse Flaechen moeglich */
          flaechen_neu = (12*((POSTYP)genus_anf-(POSTYP)g)-6*r-k-3 
                         - 2*(bordercode2[0]==2)) / (big_face-6) + 1;
          /* -3 setzt sich zusammen aus -1 zum Abrunden und -2 wie oben */
          if (fl+flaechen_neu > f_max[MAX(g+r-1,genus_anf)]) 
             {eulerkrit1 = False;}
        }
        else {eulerkrit1 = False;}        /* kein Ausgleich moeglich */ 
      }
    }
    /* Da die Eintraege im Baum aufsteigend sortiert sind, gilt sowohl fuer das
       Genuskriterium als auch fuer das Eulerkriterium 2:  Falls es einmal
       versagt, so versagt es auch im restlichen Level (bei allen durch 
       root2->next und root2->weiter.nextlevel erreichbaren Eintraegen) */
    if (genuskrit && eulerkrit1 && eulerkrit2) {     /* weiter im Baum */
      root2[len2+1] = root2[len2]->weiter.nextlevel;
      if ((len2==bordercode2[0]+1) ?   /* es beginnen die Randcodes */   
           suche_passende_patches_rek2(root1,bordercode1,len1,
               root2,bordercode2,len2+1,g,fl,expand,
               krit,k1,k,0,typ89) :      /* noch bei Randlaengen */
           suche_passende_patches_rek1(root1,bordercode1,len1,
               root2,bordercode2,len2+1,g,fl,expand,krit,k1,typ89))
         {return(True);}
    }  /* if */
    if (len2<len1 && root2[len2]==root1[len2]) {return(True);}  
       /* zweiter Pfad erreicht ersten -> Ueberschreitung vermeiden */ 
    else {root2[len2] = root2[len2]->next;} 
  }    /* while */
  return(False);
}

KNOTENTYP suche_passende_patches(TREENODE **root1,TREENODE *root2,KNOTENTYP
     *bordercode1,KNOTENTYP len1,KNOTENTYP g,KNOTENTYP fl,BOOL expand,
     KNOTENTYP krit,KNOTENTYP k1,BOOL typ89) {
  static KNOTENTYP bordercode2[N_MAX_P+3];
  static TREENODE *pfad2[N_MAX_P+3];   /* fuer jeden Eintrag im Bordercode
                                        ein Knoten im Patchbaum */    
  static BOOL dummy;
  pfad2[0] = root2;
  dummy = suche_passende_patches_rek1(root1,bordercode1,len1,pfad2,bordercode2,
          0,g,fl,expand,krit,k1,typ89);
  if (memory_overflow) {return(bordercode1[0] + pfad2[0]->code - 1);} 
  else {return(0);}
     /* Dies ist die einzige Stelle, an der wirklich die globale
        Variable "memory_overflow" benutzt werden muss, weil der 
        Returnwert der Funktion "suche_passende_patches_rek1" aus mehreren
        Gruenden "True" sein kann ("Overflow" oder "Patch 2 erreicht 
        Patch 1" oder "zu viele Raender"). Insbesondere enthaelt "pfad2[0]"
        nach Rueckkehr aus "suche_passende_patches_rek1" den korrekten Wert. */
}

/******************GEHE_PATCHBAUM_DURCH*************************************/
/*   Fuer 2 Patches, die miteinander verklebt werden.                      */
/*   Vorgehensweise:  Patch 1 ist immer der groessere, alle kleineren
     oder gleichen werden herausgesucht und zusammengenaeht                */
/*   g = Genus jedes Ergebnispatches                                       */
/*   fl = Flaechenzahl jedes Ergebnispatches                               */
/*   krit = Anzahl der kritischen Punkte in den Ergebnispatches            */
/*   anz_bb gibt die Anzahl der bislang gefundenen Bauchbindenraender an   */
/*   bb_neu = True   =>  im aktuellen Level Bauchbindenrand gefunden       */
/*   typ89: siehe "verknuepfe_patches"                                     */
/*   "maxentry" ist der groesste Eintrag im Bordercode, der zu einem
     RANDcode gehoert (also kein Laengeneintrag)                           */
/*   "root1" enthaelt die Knoten auf dem Weg durch den Patchbaum fuer 
     Patch 1, "root2" die fuer Patch 2 (zu Beginn nur erster Eintrag
     relevant). "root1[len]" ist beim Aufruf der Funktion bereits belegt,
     wird aber eventuell noch veraendert.                                  */
/*   Returnwert:  0 = Generierung komplett, >0 = Generierung abbrechen
     wegen Speichermangels. Der Returnwert gibt die Anzahl der Raender
     in den zuletzt generierten Patches an.                                */
     
KNOTENTYP gehe_patchbaum_durch(TREENODE **root1,TREENODE *root2,
          KNOTENTYP *bordercode,KNOTENTYP len,KNOTENTYP g,KNOTENTYP fl,
          KNOTENTYP krit,KNOTENTYP anz_bb,KNOTENTYP maxentry) {
  static BOOL bb_neu;
  static KNOTENTYP i,erg;
  static BOOL typ89;
  static BOOL expand;   /* "static" ist moeglich, da "expand" erst
                           nach Rueckkehr aus Rekursion gebraucht wird */ 
  while (root1[len]) {                          /* einen Level durchgehen */
    if (topdown && len==0 && krit==cmax_g[g] && fl==fmax_g[g] && 
        root1[0]->code > bmax_g[g]) {return(0);}
       /* zu viele Raender, denn vom anderen Patch kommt noch mindestens ein
          Rand hinzu */
    bordercode[len] = root1[len]->code;  len++;
    bb_neu = False;          /* kann bei jedem Zweig verschieden sein */
    if (len>bordercode[0]+2) {             /* bei Randcodes angekommen */ 
      if (bordercode[len-1]==BB_KENNUNG) {bb_neu = True;}
      else if (bordercode[len-1] > maxentry) {maxentry = bordercode[len-1];}
    }
    if (len>bordercode[0]+1 && len==bordercode[bordercode[0]+1] &&
       /* Codeende erreicht -- die erste Bedingung ist wichtig, weil sonst 
          die zweite nicht definiert ist */
       (anz_bb==0 || bordercode[0]>1)) {   /* Patches mit nur einem Rand,
        der ein Bauchbindenrand ist, nicht beruecksichtigen
        (Codeende erreicht  =>  bb_neu==False, denn
         der letzte Eintrag des BB-Codes ist NICHT BB_KENNUNG) */ 
      generiere_bind_tabelle(bordercode,&expand,&typ89,True);
      if (erg = suche_passende_patches(root1,root2,bordercode,len,g,fl,expand,
          krit,bordercode[bordercode[0]+1]-bordercode[0]-2-2*anz_bb,typ89))
         {return(erg);}
      for (i=2+(maxentry<<1); i>0; i--)
        {anz[0][i] = anz[1][i] = anz[2][i] = anz[3][i] = anz[4][i] =
         anz[5][i] = anz[6][i] = anz[7][i] = anz[8][i] = anz[9][i] = 0;}
         /* 2*maxentry+2 ist hoechstmoegliche Nahtlaenge bzw. mehr als
            hoechstmoeglicher erster Bordercode-Eintrag (bei Einschluss) */ 
         /* Abwaertszaehlen aus Geschwindigkeitsgruenden (Vergleich i>0 ist
            einfacher als i<...) */
      anz[4][0] = anz[5][0] = anz[6][0] = anz[7][0] = anz[8][0] = anz[9][0] = 
                  0;    /* fuer Ein- und Zweiecke */
    }
    else {    /* Codeende noch nicht erreicht */
      root1[len] = root1[len-1]->weiter.nextlevel;   /* ist definiert */
      if (erg = gehe_patchbaum_durch(root1,root2,bordercode,len,g,fl,
                krit,anz_bb+(bb_neu==True),maxentry)) {return(erg);}
    }
    len--;
    root1[len] = root1[len]->next;
  }
  return(0);
}

/******************GEHE_PATCHBAUM_DURCH2************************************/
/*  Fuer einen Patch, der mit sich selbst verklebt wird, wobei sich das
    Genus erhoeht.                                                         */
/*  Vorgehensweise:  Patch 1 wird mit sich selbst verklebt. Die Einhaltung
    des Genuskriteriums und des Eulerkriteriums brauchen nicht ueberprueft
    zu werden. Sie werden immer eingehalten (die Werteveraenderungen nach
    der Verklebung wiegen sich gegeneinander auf).                         */
/*   g = Genus jedes Ergebnispatches (= Genus von Patch 1 plus 1)          */
/*   fl = Flaechenzahl jedes Ergebnispatches                               */
/*   krit1 = Anzahl der kritischen Punkte                                  */
/*   anz_bb gibt die Anzahl der bislang gefundenen Bauchbindenraender an   */
/*   bb_neu = True   =>  im aktuellen Level Bauchbindenrand gefunden       */
/*   typ89: siehe "verknuepfe_patches"                                     */

KNOTENTYP gehe_patchbaum_durch2(TREENODE *root1,KNOTENTYP *bordercode,
     KNOTENTYP len,KNOTENTYP g,KNOTENTYP fl,KNOTENTYP krit1,KNOTENTYP anz_bb,
     KNOTENTYP maxentry) {
  static BOOL bb_neu;
  static KNOTENTYP i,erg;
  static BOOL typ89;
  static BOOL expand;   /* "static" ist moeglich, da "expand" erst
                           nach Rueckkehr aus Rekursion gebraucht wird */ 
  while (root1) {                                 /* einen Level durchgehen */
    if (topdown && len==0) {
      if (krit1==cmax_g[g] && fl==fmax_g[g] && root1->code>bmax_g[g]+1) 
         {return(0);} 
         /* beim vorliegenden und allen folgenden Zweigen wuerden zu viele 
            Flaechen und/oder Raender entstehen */
      if (root1->code>2) {savemem = currmem;}      /* denn alle neuen Patches
         werden mindestens 2 Raender haben => bis zu root1->code-2 Raendern ist
         die Erzeugung vollstaendig, so dass bei Erreichen der Speicherschwelle
         die erzeugten Patches brauchbar bleiben. */
    }
    if (len>0 || root1->code>1) { /* Patches mit einem Rand nicht verkleben */
      bordercode[len] = root1->code;    len++;
      bb_neu = False;           /* kann bei jedem Zweig verschieden sein */
      if (len>bordercode[0]+2) {              /* bei Randcodes angekommen */ 
        if (bordercode[len-1]==BB_KENNUNG) {bb_neu = True;}
        else if (root1->code > maxentry) {maxentry = root1->code;}
      }
      if (len>bordercode[0]+1 && len==bordercode[bordercode[0]+1] &&
         /* Codeende erreicht -- die erste Bedingung ist wichtig, weil sonst 
            die zweite nicht definiert ist */
          bordercode[0]>anz_bb+1) {   /* Patches mit max. einem BK-Rand
               nicht beruecksichtigen, da dieser nicht verklebt werden kann */
        generiere_bind_tabelle(bordercode,&expand,&typ89,False);
        if (!verknuepfe_patches(root1->weiter.firstpatch,bordercode,
            root1->weiter.firstpatch,bordercode,g,fl,expand,krit1,typ89,False))
           {return(bordercode[0]-1);}    /* Anzahl Raender in Zielpatches */
        for (i=2+(maxentry<<1); i>0; i--)
          {anz[0][i] = anz[1][i] = anz[2][i] = anz[3][i] = anz[4][i] =
           anz[5][i] = anz[6][i] = anz[7][i] = anz[8][i] = anz[9][i] = 0;}
        anz[4][0] = anz[5][0] = anz[6][0] = anz[7][0] = anz[8][0] = anz[9][0] =
                    0;    /* fuer Ein- und Zweiecke */
      }
      else {       /* root1->weiter.nextlevel verfolgen */
        if (erg = gehe_patchbaum_durch2(root1->weiter.nextlevel,bordercode,len,
            g,fl,krit1,anz_bb+(bb_neu==True),maxentry)) {return(erg);}
      }
      len--;
    }
    root1 = root1->next;
  }
  return(0);
}

/******************GEHE_PATCHBAUM_DURCH3************************************/
/*  Fuer einen Patch, der mit sich selbst verklebt wird, wobei sich das
    Genus nicht erhoeht (Fall 1).                                          */
/*  Vorgehensweise:  Patch 1 wird mit sich selbst verklebt. Die Einhaltung
    des Eulerkriteriums braucht nicht ueberprueft zu werden. Es wird immer 
    eingehalten (die Werteveraenderungen nach der Verklebung wiegen sich 
    gegeneinander auf). Das Genuskriterium muss ueberprueft werden.        */
/*   g = Genus jedes Ergebnispatches (= Genus von Patch 1 plus 1)          */
/*   fl = Flaechenzahl jedes Ergebnispatches                               */
/*   krit1 = Anzahl der kritischen Punkte                                  */
/*   anz_bb gibt die Anzahl der bislang gefundenen Bauchbindenraender an   */
/*   bb_neu = True   =>  im aktuellen Level Bauchbindenrand gefunden       */

KNOTENTYP gehe_patchbaum_durch3(TREENODE *root1,KNOTENTYP *bordercode,
     KNOTENTYP len,KNOTENTYP g,KNOTENTYP fl,KNOTENTYP krit1,KNOTENTYP anz_bb) {
  static BOOL bb_neu;
  static KNOTENTYP erg;

  while (root1) {                                 /* einen Level durchgehen */
    if (topdown && len==0) {
      if (krit1==cmax_g[g] && fl==fmax_g[g] && root1->code>=bmax_g[g]) 
         {return(0);}
      if (root1->code>1) {savemem = currmem;}      /* denn alle neuen Patches
         werden mindestens 3 Raender haben => bis zu root1->code Raendern ist
         die Erzeugung vollstaendig, so dass bei Erreichen der Speicherschwelle
         die erzeugten Patches brauchbar bleiben. */
    } 
    bordercode[len] = root1->code;  len++;
    bb_neu = False;           /* kann bei jedem Zweig verschieden sein */
    if (len>bordercode[0]+2) {              /* bei Randcodes angekommen */ 
      if (bordercode[len-1]==BB_KENNUNG) {bb_neu = True;}
    }
    if (len>bordercode[0]+1 && len==bordercode[bordercode[0]+1] &&
       /* Codeende erreicht -- die erste Bedingung ist wichtig, weil sonst 
          die zweite nicht definiert ist */
        g+bordercode[0]<=genus_end &&    /* Genuskriterium fuer Erg.-Patches */
        bordercode[0]>anz_bb) {   /* Patches mit nur BB-Raendern
                                     nicht beruecksichtigen */
      if (!verknuepfe_patch_fall1(root1->weiter.firstpatch,bordercode,g,fl,
          krit1)) {return(bordercode[0]+1);}  /*Anzahl Raender in Zielpatches*/
    }
    else {   /* root1->weiter.nextlevel weiterverfolgen */
      if (erg = gehe_patchbaum_durch3(root1->weiter.nextlevel,bordercode,len,
                g,fl,krit1,anz_bb+(bb_neu==True))) {return(erg);}
    }
    root1 = root1->next;  len--;
  }
  return(0);
}

/*********************LEGE_BOTTOM_UP_GRENZEN_FEST***************************/
/*  Falls Overflow aufgetreten ist:  Die Arrays "cmax_g", "fmax_g" und 
    "bmax_g" werden mit den hoechstmoeglichen Werten belegt, fuer die 
    garantiert ist, dass alle zugehoerigen Patches gespeichert wurden. 
    "krit", "fl", "g" und "b" sind die Werte, bei denen der Overflow auftrat.
    Derjenige Speicherbereich, der nur Patches enthaelt, die (weil nicht 
    alle Patches mit den zugehoerigen Werten "fl", "g" und "b" generiert 
    werden konnten) nicht mehr gebraucht werden, wird geloescht. Der 
    freigegebene Speicher kann zum Speichern der Flaechenstatistik genutzt
    werden.                                                                */

void lege_bottom_up_grenzen_fest(KNOTENTYP fl,KNOTENTYP g,KNOTENTYP b,
                                 KNOTENTYP krit) {
  static KNOTENTYP i;
  static MEMORY *mem,*mem2;

  /* eine Stufe herabsetzen: */
  if (b==1) {
    if (g==0) {
      if (fl==1) {krit--;  fl = f_max[genus_anf];  g = genus_end;  
                  b = genus_end+1;}
        /* Hier braucht nicht abgefragt zu werden, ob "krit==0", denn wenn
           das der Fall waere, so waeren nicht einmal die Ausgangsflaechen
           vollstaendig abgespeichert worden. */ 
      else {fl--;  g = genus_end;  b = genus_end+1;}
    }
    else {g--;  b = genus_end+1;}
  }
  else {b--;}
  /* bis "krit", "fl", "g" und "b" ist die Erzeugung komplett */

  /* Arrays anpassen: */
  for (i=0; i<=genus_end; i++) {
    if (i>g) {       /* komplett bis eine Flaeche weniger */
      cmax_g[i] = krit;   fmax_g[i] = fl-1;   /* "fl-1" kann 0 sein */
      bmax_g[i] = genus_end+1-i;
    }
    else if (i==g) {cmax_g[i] = krit;  fmax_g[i] = fl;  
                    bmax_g[i] = MIN(b,genus_end+1-i);} 
    else {           /* komplett bis zur Flaechenzahl "fl" */
      cmax_g[i] = krit;   fmax_g[i] = fl;
      bmax_g[i] = genus_end+1-i;
    }
  }

  /* Speicher freigeben: */ 
  mem = savemem->next;   /* im Block "savemem" sind (meistens) noch brauchbare
                            Patches, aber danach garantiert nicht mehr */
  while (mem) {
    mem2 = mem->next;
    free(mem->memory);
    free(mem);
    mem = mem2;
  }
}
 
/*********************GENERIERE_PATCHES*************************************/
/*  n:  Obergrenze an Knoten fuer resultierende Graphen                    */ 
/*  Reihenfolge, in der die Patches generiert werden:
    0.  kritische Punktzahl steigt monoton
    1.  Bei konstanter Punktzahl steigt Flaechenzahl monoton
    2.  Bei konstanter Flaechenzahl steigt das Genus monoton
    3.  Bei konstanter kritischer Punktzahl und konstanter Flaechenzahl
        wird das Genus aus 2. in zwei Summanden aufgeteilt oder es wird
        ein Patch mit einem um 1 geringeren Genus mit sich selbst verklebt.
    4.  Im ersteren Fall werden anschliessend die kritischen Punkte aus 0. 
        in zwei Summanden aufgeteilt
    5.  Anschliessend wird im ersteren Fall die Flaechenzahl aus 1. in zwei 
        Summanden aufgeteilt
    =>  Bei einer festen kritischen Punktzahl und einer bestimmten
        Flaechenzahl stehen alle Patches mit kleinerer Punktzahl
        oder gleicher Punktzahl und kleinerer Flaechenzahl
        fest (3.-5. koennten auch vertauscht werden).                      */
/*  Zur Groesse des Arrays "bordercode": Fuer jeden Eintrag im Bordercode
    geht mindestens 1 Knoten drauf. Zwar kommen Laengeneintraege hinzu, aber:
    Falls mehr als 1 Eintrag => mehr als 1 Rand => Raender sind durch 
    3-valente Randknoten miteinander verbunden => Kerben => an mindestens
    einer Stelle 3 Knoten fuer einen Bordercodeeintrag. Also ist der Fall,
    dass der Patch nur aus einer Flaeche besteht und Randcode 0,0,...,0 hat,
    der Worst Case. Also maximale Bordercodelaenge = N_MAX_P+3 (N_MAX_P Knoten
    + 2 Laengeneintraege + 1 Eintrag fuer Anzahl Raender).                 */
   
void generiere_patches(void) {
  static KNOTENTYP bordercode[N_MAX_P+3],i,j,fl1,fl2,fl,g;
  static EULERTYP krit1,krit2,g1,g2; 
  static KNOTENTYP *facearray,b;
  static TREENODE *t1,*t2;
  static ELEM e;
  static TREENODE *pfad1[N_MAX_P+3];
         /* fuer "gehe_patchbaum_durch":  fuer jeden Eintrag im Bordercode
            Zeiger auf zugehoerigen Knoten im Patchbaum */ 
  static BOOL ende;

  /* Ausgangsflaechen erzeugen: */
  e.prev1 = nil;  e.prev2 = nil;  e.art = 0;  e.j.nr = 0;  e.j.pos = 0;  
  e.ziellen = e.nahtlen = e.zielrand = 0;  
  e.aufteilung[0] = 0;
  (e.iso_rand)[0] = 255;    /* Rand 1 ist einzig und deshalb nicht isomorph */
  for (i=0; i<anz_face; i++) {
    if (facenum_max[i]) {     /* Flaeche erlaubt (nicht durch Gruenbaum-Satz
                                 gesperrt) */
      bordercode[0] = 1;             /* 1 Rand */
      bordercode[1] = 3;             /* Beginn des Randcodes */
      bordercode[2] = face[i] + 3;   /* Laenge des Bordercodes */
      for (j=0; j<face[i]; j++) {bordercode[j+3]=0;}   /* Randcode */
      if (facenumbers) {
        facearray = (KNOTENTYP *)hole_speicher((size_t)anz_face*
                     sizeof(KNOTENTYP),memory_used,True);
        for (j=0; j<anz_face; j++) {facearray[j] = 0;}
        facearray[i] = 1;    /* i-te Flaeche wurde erzeugt */
      }
      else {facearray = nil;}
      e.i.nr = face[i];  e.i.pos = 0;
      if (!ordne_patch_in_baum(&e,bordercode,0,1,facearray,(!alternative && 
          face[i]>6) ? face[i]-6 : 0)) {
        logfile_entry((char *)"Error: Not enough memory for storing the"
                      " allowed faces!\n",True,True,True);
        exit(36);
      }
    }
  }
  savemem = currmem;      /* bis hierhin dynamischen Speicher erhalten */
  /* Patches zusammennaehen: */
  ende = False;                     /* True => Abbruch wegen Speichermangels */
  for (j=0; !ende && j<=krit_max; j++) {      
               /* 0.) Patches mit j kritischen Punkten */
    for (fl=1; !ende && fl<=f_max[genus_anf]; fl++) { 
               /* 1.) Patches mit fl Flaechen */
      for (g=0; !ende && (g<genus_end || (g==genus_end && small_face<6)) &&
                fl<=f_max[MAX(g,genus_anf)]; g++) { 
        savemem = currmem;   /* alle bis hierhin erzeugten Patches bleiben
                                bei Erreichen der Speicherschwelle brauchbar */
        /* 2.) Patches mit Genus g, die aber nicht zu gross werden duerfen */
        if (!topdown || j<cmax_g[g] || (j==cmax_g[g] && fl<=fmax_g[g])) { 
            /* Einschraenkung einhalten */

          /* 3.1.) Zwei Patches zusammenkleben */
          /* 3.1 wird vor 3.2 ausgefuehrt, weil bei 3.1 erst sehr spaet 
             festgestellt werden kann, dass alle Patches mit einer bestimmten
             Randzahl erzeugt wurden (dadurch, dass es zu vorgegebenen "fl"
             und "g" viele Aufteilungen in 2 Teile gibt, bei denen jeweils
             zuerst Patches mit einem Rand erzeugt werden). Nach dem ersten
             Durchlauf von 3.2 kann jedoch mit Sicherheit gesagt werden, dass
             alle Patches mit einem Rand bereits erzeugt wurden, und diese
             Tatsache sollte man ausnutzen.
             Da bei Erreichen der Speicherschwelle
             b=1 gesetzt wird, braucht innerhalb von 3.1 die Variable "savemem"
             nicht aktualisiert zu werden. */
          for (g2=(EULERTYP)g/2; !ende && g2>=0; g2--) {     /* g aufteilen */
            g1 = g-g2;    /* wichtig: g1>=g2 */
            for (krit2=(EULERTYP)(g1==g2 ? j/2 : j); !ende && krit2>=0; 
                 krit2--) {       /*4.)*/
              krit1 = j-krit2;    /* wichtig: krit1>=krit2, falls g1==g2 */
              for (fl1=(g1==g2 && krit1==krit2 ? (fl+1)>>1 : 1); 
                   !ende && fl1<fl;  fl1++) {
                /* 5.)  fl1 = Flaechen in Patch 1 (>=fl2, wenn krit1==krit2 
                   und g1==g2, damit Patch 1 niemals kleiner als Patch 2 ist)*/
                fl2 = fl-fl1;                 /* fl2 = Flaechen in Patch 2 */
                t1 = tree[fl1];
                while (t1 && t1->code<g1) {t1 = t1->next;}
                if (t1 && t1->code==g1) {
                  t1 = t1->weiter.nextlevel;
                  while (t1 && t1->code<krit1) {t1 = t1->next;}
                  if (t1 && t1->code==krit1) {
                    t2 = tree[fl2];
                    while (t2 && t2->code<g2) {t2 = t2->next;}
                    if (t2 && t2->code==g2) {
                      t2 = t2->weiter.nextlevel;     
                      while (t2 && t2->code<krit2) {t2 = t2->next;}
                      if (t2 && t2->code==krit2) { 
                        /* es gibt Patches mit Genus g1, fl1 Flaechen und 
                           krit1 kritischen Punkten sowie Genus g2, fl2 
                           Flaechen und krit2 kritischen Punkten */
                        pfad1[0] = t1->weiter.nextlevel;
                        if (b = gehe_patchbaum_durch(pfad1,
                            t2->weiter.nextlevel,bordercode,0,g,fl,j,0,0)) 
                           {lege_bottom_up_grenzen_fest(fl,g,1,j); 
                            ende = True;}  /* b=1 uebergeben, weil bei 3.1
                            selbst und bei 3.2 evtl. noch Patches mit einem 
                            Rand generiert werden (bei 3.1, indem "fl" und
                            "g" neu verteilt werden auf "g1" und "g2" sowie
                            "fl1" und "fl2") */
                      }
                    }
                  }
                }
              }
            }
          }
        
          /* 3.2.) Einen Patch mit Genus g-1 mit sich selbst verkleben:
                   Flaechenzahl und kritische Punkte bleiben erhalten, also ist
                   die Verklebung an diesem Punkt vollstaendig, denn alle 
                   Patches mit Flaechenzahl fl, j kritischen Punkten und Genus
                   g-1 existieren bereits. */
          if (g>0 && !ende) {           /* sonst nicht moeglich */
            t1 = tree[fl];
            while (t1 && t1->code<g-1) {t1 = t1->next;}
            if (t1 && t1->code==g-1) {
              t1 = t1->weiter.nextlevel;
              while (t1 && t1->code<j) {t1 = t1->next;}
              if (t1 && t1->code==krit1) { /* es gibt Patches mit Genus g-1, 
                                        fl Flaechen und j kritischen Punkten */
                if (b = gehe_patchbaum_durch2(t1->weiter.nextlevel,bordercode,
                        0,g,fl,j,0,0)) 
                   {lege_bottom_up_grenzen_fest(fl,g,MIN(b,2),j); ende = True;}
                   /* b<=2 uebergeben, weil bei 3.3 evtl. noch Patches mit  
                      zwei Raendern generiert werden */
	      }
            }
          }
          else {savemem = currmem;}   /* weil alle Patches mit "fl" Flaechen,
             Geschlecht "g" und einem Rand endgueltig generiert worden sind */
  
          /* 3.3.) Einen Patch mit Genus g gemaess Fall 1 mit sich selbst 
                   verkleben: Genus, Flaechenzahl und kritische Punkte bleiben 
                   erhalten, Anzahl der Raender steigt um 1.
                   Da alle Werte aus den Punkten 0-2 erhalten bleiben, muss 
                   dieser Schritt als letzter vollzogen werden (es wird auf
                   gerade erzeugte Patches zugegriffen)! Die Reihenfolge der
                   Erzeugung ist dann aber wohldefiniert, da die Anzahl der
                   Raender monoton steigt, so dass ein neu erzeugter Patch in
                   einen hoeheren Zweig eingeordnet wird als den, aus dem der
                   alte Patch kommt. Die Erzeugung ist komplett, da die hier
                   erzeugten Patches nicht im selben Schleifendurchlauf von
                   den Punkten 3.1 oder 3.2 benoetigt werden. */
          t1 = tree[fl];
          while (t1 && t1->code<g) {t1 = t1->next;}
          if (!ende && t1 && t1->code==g) {
            t1 = t1->weiter.nextlevel;
            while (t1 && t1->code<j) {t1 = t1->next;}
            if (t1 && t1->code==j) {   /* es gibt Patches mit Genus g, 
                                        fl Flaechen und j kritischen Punkten */
              if (b = gehe_patchbaum_durch3(t1->weiter.nextlevel,bordercode,0,
                  g,fl,j,0)) 
                 {lege_bottom_up_grenzen_fest(fl,g,b,j);  ende=True;}
            }
          }
        }
      }
    }
  }
}


/*********************************************/
/* Funktionen fuer die Top-Down-Generierung: */
/*********************************************/

/*****************ERRECHNE_FLAECHENZAHLEN************************************/
/*  Aktualisiert die Flaechenzahlen von "von" bis "bis".                    */
/*  Nur fuer g==0 (planare Karten)                                          */

void errechne_flaechenzahlen(POSTYP von,POSTYP bis) {
  static KNOTENTYP i;
  static FLAECHENTYP f;
  for (i=bis; i>=von; i--) {    /* Flaechenzahlen aktualisieren */
    if (!history[i].stamm) {    /* fuer Stammpatches liegen die Daten vor */
       /* Da g==0, hat jeder Patch 2 Vorgaenger. Diese muessen allerdings
          noch nicht unbedingt feststehen, weil die Funktion ja auch innerhalb
          der "suche_patch"-Rekursion aufgerufen wird. Am Ende steht im 
          obersten Level aber auf jeden Fall die Gesamtzahl der bereits
          feststehenden Flaechen. */
      for (f=0; f<anz_face; f++) 
          {(history[i].flaechenzahl)[f] = 
           (history[i].prev1 ? ((history[i].prev1)->flaechenzahl)[f] : 0) + 
           (history[i].prev2 ? ((history[i].prev2)->flaechenzahl)[f] : 0);}
    } 
  }
}

/****************STARTE_PC_HISTORY_TD****************************************/
/* Diese Funktion stellt die history auf den ersten zu konstruierenden
   Patch. "von" und "bis" sind die Grenzen des Intervalls in der History,
   das von dem Patch belegt wird.                                           */
/* Wird nur bei Geschlecht 0 aufgerufen, deshalb gibt es nie Fall 1.        */
/* Wird nur bei "facenumbers==True" aufgerufen.                             */

void starte_pc_history_td(POSTYP von,POSTYP bis) {
  static POSTYP i,checkpos;
  static FLAECHENTYP f;
  static unsigned long pos;
  static ELEM *e;

  /* "hiscopy" belegen (insbesondere enthalten die "hiscopy"-Elemente die
     aktuellen "vater"-Werte */
  memcpy(&hiscopy[von],&history[von],sizeof(ELEM)*(size_t)(bis-von+1));

  checkpos = 0;                /* fuer obersten Level */ 
  for (i=bis; i>=von; i--) {   /* Rekursionslevel VON UNTEN durchgehen, denn
       eventuell muessen weiter oben einige AKZEPTIERTE Eintraege
       uebersprungen werden. Dies wiederum dann, wenn weiter unten auf die
       akzeptierten Eintraege keine akzeptierten Fortsetzungen folgen. Wie
       viele akzeptierte Eintraege dies sind, wird unten berechnet. */
    if (history[i].stamm) {         /* Stammpatch auswaehlen */
      pos = overflow[i] ? 0 : his_check[checkpos][i];   /* erste Position */
      his_check_pos[i] = checkpos;    /* wichtig, da ja von dieser Position
                             weitergeschaltet wird und nicht von der ersten */
      checkpos = 0;   /* schon fuer naechsttieferen Level */
      while (pos>0) {       /* weitersetzen */
        pos--;        /* bei jedem Schleifendurchlauf wird weitergesetzt */
        e = history[i].next;
        if (e) {history[i] = *e;  history[i].his_nr = i;}  /* weiterschalten */
        else {    /* naechsttieferen Level vorbereiten */
          if (i==von) {
            fprintf(stderr,"Dicker Fehler in starte_pc_history_td %d %d!\n",
                    von,bis);  exit(37);
          }
          history[i] = hiscopy[i];   /* wieder ersten Stammpatch setzen */
          checkpos = pos/anz_p[i]+1;   /* so viele AKZEPTIERTE Eintraege im
                                 naechsttieferen Level werden uebersprungen */
          pos = pos%anz_p[i];  /* denn alle "anz" Durchlaeufe wird derselbe 
                                  Stammpatch erreicht */
        }       
      }
    }
  }
 
  errechne_flaechenzahlen(von,bis);   /* zunaechst innerhalb der History */
  for (f=0; f<anz_face; f++)          /* von History uebernehmen */
      {pc_flaechenzahl[f] += (history[von].flaechenzahl)[f];}
  /* "his_rl2" und "his_rlg2" belegen entfaellt, da Fall 1 nicht auftritt */
}

/****************SETZE_PC_HISTORY_WEITER_TD**********************************/
/* Diese Funktion setzt die in der History gegebene implizite Liste der 
   Patches um einen gueltigen Patch weiter. Der niedrigste Level, in dem
   eine Veraenderung stattgefunden hat, wird zurueckgegeben. Falls das 
   virtuelle Listenende erreicht ist, wird "-1" zurueckgegeben.
   "top_level" und "bottom_level" sind die Grenzen des Patches in der History.
   "history" enthaelt die Originalhistory, in der die Zeiger manipuliert 
   werden, und "hiscopy" die Kopie der urspruenglichen Originalhistory, 
   so dass einzelne Eintraege wiederhergestellt werden koennen.             */
/* Die Reihenfolge, in der die Eintraege weitergesetzt werden, geht von unten
   nach oben (von kleinen Patches zu deren groesseren Nachfolgern).         */
/* "setze_pc_history_weiter_it_td" wird nur von "setze_pc_history_weiter_td" 
   aufgerufen. Die Funktionen sind nur fuer planare Karten ausgelegt.
   "anfang" gibt den Level an, bei dem weitergesetzt werden soll. Alle 
   Eintraege in den darueberliegenden Levels werden zurueckgesetzt.         */
/* VORSICHT:  Im Gegensatz zu "starte_pc_history_td" und auch
   "setze_history_weiter_td" werden nur die Flaechenzahlen in
   "pc_flaechenzahl" aktualisiert, aber NICHT die Flaechenzahlen in den
   History-Elementen selbst (ausser natuerlich bei den Stammpatches)!
   Dies muss bei Bedarf nachtraeglich geschehen (in "top_down_generierung") */
/* Die Funktion behandelt Overflows abhaengig vom Level. Nur in Levels, in
   denen ein Overflow besteht, wird jedes Element angesteuert. In den Levels,
   in denen kein Overflow aufgetreten ist, wird die "his_check"-Tabelle
   ausgenutzt, um Zeit zu sparen.                                           */

POSTYP setze_pc_history_weiter_td(POSTYP top_level,POSTYP bottom_level) {
  static ELEM *e;
  static POSTYP i;
  static FLAECHENTYP f;
  static unsigned long diff,anz,uebertraege;
  /* zunaechst in unterstmoeglichem Level vorsetzen (muss nicht "bottom_level"
     sein, zumindest nicht waehrend der Patchsuche): */
  i = bottom_level;
  while (i>=top_level && !history[i].stamm) {i--;}         /* Lazy-Eval. */
  if (i<top_level) {return(-1);}     /* weiterschalten geht nicht */
  for (f=0; f<anz_face; f++)   /* alte Flaechenzahlen abziehen */
      {pc_flaechenzahl[f] -= (history[i].flaechenzahl)[f];}       
  if (overflow[i]) {diff = 1;  uebertraege = 0;  anz = 1;} 
                   /* jeden Eintrag nehmen */
  else {
    his_check_pos[i]++;         /* naechsten brauchbaren Zweig ansteuern (auf
       Listenende braucht nicht geachtet zu werden - siehe "patch_check_td") */
    diff = his_check[his_check_pos[i]][i]-his_check[his_check_pos[i]-1][i]; 
           /* Anzahl der zu ueberspringenden Eintraege */
    uebertraege = diff/anz_p[i];            /* Anzahl der Uebertraege, die 
      nicht durchgefuehrt werden muessen, weil alle "anz_p[i]" Durchlaeufe
      sowieso derselbe Stammpatch erreicht wird. */
    anz = diff%anz_p[i];
  }
  if (anz) {              /* es verbleiben Spruenge */
    e = &history[i];
    while (anz) {
      e = e->next;   
      if (!e) {e = &hiscopy[i];  uebertraege++;}  /* wieder Listenanfang */
      anz--;  /* Anzahl der verbleibenden Spruenge */
    }
    history[i] = *e;    history[i].his_nr = i;    /* Daten uebernehmen */
  }
  for (f=0; f<anz_face; f++)   /* neue Flaechenzahlen addieren */
      {pc_flaechenzahl[f] += (history[i].flaechenzahl)[f];}       
  if (uebertraege==0) {return(i);}   /* Weiterschalten abgeschlossen */

  /* Uebertraege sind aufgetreten - tiefere Level durchgehen */
  while (i>top_level) {                       /* es geht noch weiter 'runter */
    do {i--;} while (i>=top_level && !history[i].stamm);       /* Lazy-eval. */
    if (i<top_level) {return(-1);}   /* weiterschalten geht nicht */
    for (f=0; f<anz_face; f++)   /* alte Flaechenzahlen abziehen */
        {pc_flaechenzahl[f] -= (history[i].flaechenzahl)[f];}       
    if (overflow[i]) {diff = 1;  uebertraege = 0;  anz = 1;}
    else {
      his_check_pos[i] += uebertraege;       /* weiterschalten */
      diff = his_check[his_check_pos[i]][i] - 
             his_check[his_check_pos[i]-uebertraege][i];
             /* Anzahl der zu ueberspringenden Eintraege */
      uebertraege = diff/anz_p[i];
      anz = diff%anz_p[i];
    }
    if (anz) {
      e = &history[i];
      while (anz) {
        e = e->next;   
        if (!e) {e = &hiscopy[i];  uebertraege++;}    /* wieder Listenanfang */
        anz--;     /* Anzahl der verbleibenden Spruenge */
      }
      history[i] = *e;    history[i].his_nr = i;    /* Daten uebernehmen */
    }
    for (f=0; f<anz_face; f++)   /* neue Flaechenzahlen addieren */
        {pc_flaechenzahl[f] += (history[i].flaechenzahl)[f];}       
    if (uebertraege==0) {return(i);}     /* Weiterschalten abgeschlossen */
  }
  return(-1);                 /* alles durch */    
}

/*********************PATCH_CHECK_TD****************************************/
/*  Diese Funktion prueft aus der History heraus JEDEN implizit gespeicherten
    Patch auf die Einhaltung der Flaechenzahlen. Diese Funktion wird nur dann
    aufgerufen, wenn "facerestrict==True" (also auch "facenumbers==True").
    Wenn KEINER der Patches akzeptiert werden kann, so wird "False" 
    zurueckgegeben, andernfalls "True". Die Funktion wird nur bei genus==0
    aufgerufen, so dass isomorphe Raender und so'n Zeug nicht beachtet zu
    werden brauchen.                                                       */
/*  Die laufenden Nummern der brauchbaren Patches in der Historyliste
    werden - getrennt fuer jeden Level - in "his_check" gespeichert. Dieses
    Array ist in seiner Groesse begrenzt. Wenn ein Ueberlauf auftritt, so
    wird der Patchcheck gestoppt.                                          */
/*  "top_level" gibt an, wo der aktuelle Patch beginnt. Sofern diesem Patch
    noch andere Patches uebergeordnet sind, werden deren Flaechenzahlen in
    "pc_flaechenzahl_sk" uebergeben.
    "bottom_level" enthaelt auf jeden Fall einen Stammpatch.               */
/*  Bei einem Overflow in frueheren Leveln wird die Funktion nicht 
    aufgerufen.                                                            */
   
BOOL patch_check_td(POSTYP top_level,POSTYP bottom_level) {
  static FLAECHENTYP f,ff;
  static POSTYP l,i;
  static KNOTENTYP ii,jj;
  static unsigned short anz;
  static unsigned long nr;     /* laufende Nummer der Verzweigung */
  static unsigned long anzp;   /* Anzahl Patches im "bottom_level" */
  static BOOL erlaubt;
  static ELEM *e;
  /* Patches durchlaufen: */
  anz = 0;  nr = 0L;  overflow[bottom_level] = False;
  for (f=0; f<anz_face; f++) {pc_flaechenzahl[f] = pc_flaechenzahl_sk[f];}
  if (bottom_level>top_level) {
    starte_pc_history_td(top_level,bottom_level-1);
    /* u.a. werden gueltige Flaechenzahlen "pc_flaechenzahl" errechnet
       (incl. "bottom_level"). Allerdings werden auch die Flaechen aus dem
       "bottom_level" addiert. Diese muessen wieder abgezogen werden, da sie
       spaeter noch einmal addiert werden. */
    for (f=0; f<anz_face; f++)    /* Flaechenzahlen wieder abziehen */
        {pc_flaechenzahl[f] -= (history[bottom_level].flaechenzahl)[f];}
  }
  do {                    /* alle Stammpatches in hoeheren Leveln durchgehen */
    e = &history[bottom_level];
    anzp = 0L;
    do {                  /* alle Stammpatches in "bottom_level" durchgehen */
      erlaubt = True;
      for (f=0; erlaubt && f<anz_face; f++) {    /* Flaechenzahlen addieren */
        pc_flaechenzahl[f] += (e->flaechenzahl)[f];
        if (pc_flaechenzahl[f] > facenum_max[f]) {   /* nicht erlaubt */
          for (ff=0; ff<=f; ff++)    /* Flaechenzahlen wieder abziehen */
              {pc_flaechenzahl[ff] -= (e->flaechenzahl)[ff];}
          erlaubt = False;
        }
      }
      if (erlaubt) {    /* Kombination speichern */
        his_check[anz][bottom_level] = nr;   anz++;
        for (f=0; f<anz_face; f++)    /* Flaechenzahlen wieder abziehen */
            {pc_flaechenzahl[f] -= (e->flaechenzahl)[f];}
      }
      nr++;
      anzp++;
      e = e->next;
    } while (e && anz<CHECKLISTLEN && nr<ULONG_MAX);
    l = 0;         /* !=-1, falls es gar nicht mehr zum Weitersetzen kommt */
  } while (anz<CHECKLISTLEN && nr<ULONG_MAX && top_level<bottom_level &&
          (l = setze_pc_history_weiter_td(top_level,bottom_level-1))!=-1);
  anz_p[bottom_level] = anzp;   /* bei Overflow u.U. kein korrekter Wert */
  if (anz>0 && anz<CHECKLISTLEN && nr<ULONG_MAX)
     {his_check[anz++][bottom_level] = nr;}
     /* Endemarke setzen, die nicht erreicht wird, so dass immer alle
        Moeglichkeiten durchlaufen werden, auch wenn die letzten nicht mehr
        brauchbar sind. Denn sonst wuerde das Erreichen des Listenendes
        zu Fehlern fuehren. Die Endemarke darf nicht zu gross gewaehlt werden,
        sondern muss genau "nr" betragen, weil anhand des Eintrags ja auch
        die Uebertraege in die uebergeordneten Level berechnet werden. */
  else if (anz==CHECKLISTLEN || nr==ULONG_MAX) 
          {overflow[bottom_level] = True;  
	  /*fprintf(stderr,"overflow %d %d ",top_level,bottom_level);*/}
                                        
  /* Arrays zuruecksetzen: (wird bei Overflow von "anz" gebraucht) */
  if (l!=-1 && top_level<bottom_level) {  
      /* d.h. Weitersetzen nicht bis zum Ende gefuehrt -
         sonst ist Zuruecksetzen bereits automatisch geschehen */
    memcpy(&history[top_level],&hiscopy[top_level],
           sizeof(ELEM)*(size_t)(bottom_level-top_level));
           /* "bottom_level" bleibt unberuehrt */
    errechne_flaechenzahlen(top_level,bottom_level);
  }
  return((his_check_anz[bottom_level] = anz) > 0  ||  nr==ULONG_MAX);
  /* Lazy-eval. -- nr==ULONG_MAX => overflow => keine negative Aussage mgl. */
} 

/****************STARTE_HISTORY_TD*******************************************/
/* Diese Funktion stellt die history auf den ersten zu konstruierenden
   Patch. "von" und "bis" sind die Grenzen des Intervalls in der History,
   das von dem Patch belegt wird.                                           */

void starte_history_td(POSTYP von,POSTYP bis) {
  static POSTYP i;
  static FLAECHENTYP f;
  static KNOTENTYP rand2,len;
  static KNOTENTYP *bordercode;
  
  if (facenumbers) {
    for (i=bis; i>=von; i--) {    /* Flaechenzahlen aktualisieren */
      if (!history[i].stamm) {    /* fuer Stammpatches liegen die Daten vor */
        if (history[i].prev2) {
          for (f=0; f<anz_face; f++) 
            {(history[i].flaechenzahl)[f] = 
             ((history[i].prev1)->flaechenzahl)[f] + 
             ((history[i].prev2)->flaechenzahl)[f];}
        }
        else {memcpy(history[i].flaechenzahl,(history[i].prev1)->flaechenzahl,
              sizeof(KNOTENTYP)*(size_t)anz_face);}
      }
    } 
  }

  /* "his_rl2" und "his_rlg2" belegen: */
  for (i=bis; i>=von; i--) {
    if (history[i].art==VERBINDUNG) {               /* sonst nicht definiert */
      bordercode = bc_td[vor[i]][vater_nr[i]];
      rand2 = history[i].zielrand;
      if ((len = bordercode[rand2+2]-bordercode[rand2+1])==2 &&
          bordercode[bordercode[rand2+1]]==BB_KENNUNG) {  /* Bauchbindenrand */
        his_rl2[i] = 2;
        his_rlg2[i] = bordercode[bordercode[rand2+1]+1]<<1;
      }
      else {    /* Bruchkantenrand */
        his_rl2[i] = per_td[vor[i]][rand2][vater_nr[i]];
        his_rlg2[i] = randlaenge(&bordercode[bordercode[rand2+1]],0,len-1);
      }
    }
  }

  /* "hiscopy" belegen (insbesondere enthalten die "hiscopy"-Elemente die
     aktuellen "vater"-Werte */
  memcpy(&hiscopy[von],&history[von],sizeof(ELEM)*(size_t)(bis-von+1));
}

/****************SETZE_HISTORY_WEITER_TD*************************************/
/* Diese Funktion setzt die in der History gegebene implizite Liste der 
   Patches um einen gueltigen Patch weiter. Der niedrigste Level, in dem
   eine Veraenderung stattgefunden hat, wird zurueckgegeben. Falls das 
   virtuelle Listenende erreicht ist, wird "-1" zurueckgegeben.
   "top_level" und "bottom_level" sind die Grenzen des Patches in der History.
   "history" enthaelt die Originalhistory, in der die Zeiger manipuliert 
   werden, und "hiscopy" die Kopie der urspruenglichen Originalhistory, 
   so dass einzelne Eintraege wiederhergestellt werden koennen.             */
/* In "hiscopy" darf nicht manipuliert werden bzw. es nuetzt nichts, 
   da "e2" in den aufrufenden
   Funktionen auf ein Element von "history" zeigt und nicht auf "hiscopy".  */
/* Die Reihenfolge, in der die Eintraege weitergesetzt werden, geht von oben
   nach unten (von grossen Patches zu deren kleineren Vorgaengern), 
   so dass in den unteren Ebenen die "Zwischenpatches" nicht
   veraendert werden und dort somit keine Ueberpruefungen durchgefuehrt
   werden muessen. Es gilt: Falls als letztes eine Erhoehung eines j.nr-Wertes
   stattgefunden hat, so muessten in demselben Level die Ueberpruefungen 
   auf Flaechenzahlen und Struktur nicht durchgefuehrt werden, denn das 
   Kantengeruest bleibt unveraendert, ebenso die Flaechenzahlen (allerdings
   wird die Ueberpruefung immer durchgefuehrt). Desweiteren
   DUERFEN NICHT die "his_acc"-Werte geloescht werden, sondern sie bleiben 
   fuer alle moeglichen j.nr-Werte gueltig. Deshalb ist es wichtig, dass 
   zuerst immer die j.nr-Werte veraendert werden und dann erst die 
   prev-Zeiger, denn sonst waere diese Argumentation ungueltig.      */
/* "setze_history_weiter_it_td" wird nur von "setze_history_weiter_td" 
   aufgerufen.
   "anfang" gibt den Level an, bei dem weitergesetzt werden soll. Alle 
   Eintraege in den darueberliegenden Levels werden zurueckgesetzt.
   Falls "vor0==False", so wird nicht als erstes der j.nr-Wert erhoeht. Dies
   ist dann der Fall, wenn als letztes ein Fehler bei der Konstruktion
   aufgetreten ist, an dem die Erhoehung des obersten j.nr-Wertes auch nichts 
   aendern wuerde (z.B. Doppelkante). ???? "vor0" wird zur Zeit nicht
   benutzt (immer "True").                                                  */
/* Ergaenzend zur Bottom-Up-Konstruktion muessen auch noch die Werte von
   i.nr und j.nr hochgesetzt werden, sofern die nachfolgenden Randcodes mit
   den vorliegenden Randcodes uebereinstimmen. Denn in der Funktion 
   "berechne_umrandungen" werden diese Werte immer auf eindeutige Werte,
   und zwar die niedrigstmoeglichen, gesetzt, auch dann, wenn es mehrere
   Moeglichkeiten gibt.                                                     */

POSTYP setze_history_weiter_it_td(POSTYP bottom_level,POSTYP index,BOOL vor0) {
  static POSTYP vater;
  static KNOTENTYP ii,jj,*bordercode;
  static ELEM *e;
  if (!vor0 && history[index].art==VERBINDUNG) 
     {history[index].j.nr = hiscopy[index].j.nr;
      history[index].i.nr = hiscopy[index].i.nr;  
      index++;}
     /* j.nr zuruecksetzen, denn falls vor0==False, so muss j.nr nicht
        unbedingt noch den minimalen Wert besitzen. Es ist moeglich, dass
        die Konstruktion eines rekursiven Patches mit minimalem Wert fuer
        j.nr nicht klappt, weil der zweite Rand besser ist als der erste.
        Mit groesserem Wert klappe sie dagegen (weil dann der zweite Rand
        nicht besser sei als der erste). Dann werde festgestellt, dass
        die Flaechenzahlen nicht passen. In diesem Fall braucht j.nr nicht
        hochgesetzt zu werden, weil das an den Flaechenzahlen sowieso nichts
        aendert, aber beim naechsten Patch muss j.nr wieder mit
        dem kleinstmoeglichen Wert beginnen. Also j.nr mit Blick auf den
        naechsten Patch (bei dem mehr als nur j.nr veraendert ist)
        zuruecksetzen. Dieselbe Argumentation gilt fuer i.nr. */
  while (index<=bottom_level) { 
    /* pro Schleifendurchlauf wird vorgesetzt oder Rueckschritt eingeleitet */
    e = &history[index];
    vater = vater_nr[index];
    if (e->stamm) {   /* Stamm weiterschalten */
      e = e->next;
      if (e) {
        bestimme_gute_basen(e);
        history[index] = *e; 
        history[index].his_nr = index;  
        return(index);
      }
      else {history[index] = hiscopy[index];}   /* zuruecksetzen */     
    }
    else if (e->art==VERBINDUNG) {                       /* Fall 1 */ 
      (e->j).nr += his_rl2[index];
      if ((e->j).nr >= his_rlg2[index]) {     /* einmal herum */ 
        (e->j).nr = hiscopy[index].j.nr;
        jj = ((his_rlg2[index]/his_rl2[index]-1)>>3)+1; 
             /* Anzahl wichtiger Elemente im akzeptiert-array */
        for (ii=0; ii<jj; ii++) {his_acc[index][ii] = 0;}   /* loeschen */
        bordercode = bc_td[0][index];   /* Code vom entstehenden Patch */ 
        if ((e->i).nr+1 < bordercode[0] &&
            vergleiche_codes(&bordercode[bordercode[(e->i).nr+1]],
            bordercode[(e->i).nr+2]-bordercode[(e->i).nr+1],
            &bordercode[bordercode[(e->i).nr+2]],
            bordercode[(e->i).nr+3]-bordercode[(e->i).nr+2])==0) 
	   {(e->i).nr++;  return(index);}   /* naechster Rand, der derjenige
            ist, der bei der Konstruktion mit sich selbst verklebt wird */
        else {(e->i).nr = hiscopy[index].i.nr;}  /* kleinstmoeglichen Wert
                                                    wiederherstellen */
      }
      else {return(index);}
    }
    else if (e->vorg==1) {      /* Durchschnitt oder Einschluss (1 Patch) */
      bordercode = bc_td[0][index];        /* Code vom entstehenden Patch */ 
      while ((e->j).nr+1 < bordercode[0] &&
             vergleiche_codes(&bordercode[bordercode[(e->j).nr+1]],
             bordercode[(e->j).nr+2]-bordercode[(e->j).nr+1],
             &bordercode[bordercode[(e->j).nr+2]],
             bordercode[(e->j).nr+3]-bordercode[(e->j).nr+2])==0) 
	    {(e->j).nr++;  if ((e->j).nr != (e->i).nr) {return(index);} }
             /* naechster Rand, der bei der Konstruktion tatsaechlich zum
                Verkleben verwendet wird */
             /* spaetestens beim zweiten erfolgreichen Vergleich wird die
                Funktion verlassen */
      (e->j).nr = vergleiche_codes(&bordercode[bordercode[(e->j).nr+1]],
            bordercode[(e->j).nr+2]-bordercode[(e->j).nr+1],
            &bordercode[bordercode[(e->i).nr+1]],
            bordercode[(e->i).nr+2]-bordercode[(e->i).nr+1])==0 ?
            hiscopy[index].i.nr : hiscopy[index].j.nr;   /* wenn die beiden
            beteiligten Raender denselben Randcode haben, so bekommt i.nr zu
            Beginn immer die kleinstmoegliche Nummer und j.nr die 
            naechstgroessere (vgl. "berechne_umrandungen"). Sobald i.nr 
            hoehergesetzt wird, muss deshalb j.nr auch die kleinstmoegliche 
            Nummer bekommen koennen. Diese steht in hiscopy[index].i.nr.
            Auf diese Weise werden beispielsweise die Paare fuer 4 gleiche
            Randcodes in der Reihenfolge (1 2), (1 3), (1 4), (2 1), (2 3),
            (2 4), (3 1), (3 2), (3 4), (4 1), (4 2), (4 3) gebildet.
            Wenn die beiden Raender nicht gleich sind, so wird j.nr ganz
            gewoehnlich wieder auf den kleinsten Wert gesetzt. */
      while ((e->i).nr+1 < bordercode[0] &&
             vergleiche_codes(&bordercode[bordercode[(e->i).nr+1]],
             bordercode[(e->i).nr+2]-bordercode[(e->i).nr+1],
             &bordercode[bordercode[(e->i).nr+2]],
             bordercode[(e->i).nr+3]-bordercode[(e->i).nr+2])==0)
            {(e->i).nr++;  if ((e->i).nr != (e->j).nr) {return(index);} }
      (e->i).nr = hiscopy[index].i.nr; /* zurueck auf kleinstmoeglichen Wert */
      (e->j).nr = hiscopy[index].j.nr; /* Wichtig, damit am Ende j.nr bei
         gleichen Randcodes wieder den zweitkleinsten Wert hat und nicht den
         kleinsten (im Beispiel wuerde ohne diesen Befehl das Paar (1 1)
         gebildet werden) */
    }
    else {       /* Durchschnitt oder Einschluss (2 Patches) */
      bordercode = bc_td[1][index];   /* Code vom 2. entstehenden Patch */ 
      if ((e->j).nr+1 < bordercode[0] &&
          vergleiche_codes(&bordercode[bordercode[(e->j).nr+1]],
          bordercode[(e->j).nr+2]-bordercode[(e->j).nr+1],
          &bordercode[bordercode[(e->j).nr+2]],
          bordercode[(e->j).nr+3]-bordercode[(e->j).nr+2])==0) 
         {(e->j).nr++;  return(index);}
      else {(e->j).nr = hiscopy[index].j.nr;}
      bordercode = bc_td[0][index];   /* Code vom 1. entstehenden Patch */ 
      if ((e->i).nr+1 < bordercode[0] &&
          vergleiche_codes(&bordercode[bordercode[(e->i).nr+1]],
          bordercode[(e->i).nr+2]-bordercode[(e->i).nr+1],
          &bordercode[bordercode[(e->i).nr+2]],
          bordercode[(e->i).nr+3]-bordercode[(e->i).nr+2])==0) 
         {(e->i).nr++;  return(index);}
      else {(e->i).nr = hiscopy[index].i.nr;}
    }
    index++;    /* nicht weitergeschaltet => naechsttieferen Level */
                /* in niedrigeren Leveln auf jeden Fall "j.nr" weitersetzen */
  }
  return(-1);   /* niedrigsten Level erreicht */
}

POSTYP setze_history_weiter_td(POSTYP top_level,POSTYP bottom_level,
                               POSTYP anfang,BOOL vor0) {
  static BOOL erg,neu;
  static POSTYP i,l;
  static FLAECHENTYP f;
  static KNOTENTYP ii,jj;

  l = setze_history_weiter_it_td(bottom_level,anfang,vor0);

  /* Folgende Schleifen nicht durchlaufen, wenn l==-1, weil in "starte_
     history" alles fuer den naechsten Durchlauf gesetzt wird: */
  if (facenumbers && l!=-1) {
    for (i = l; i>=top_level; i--) { 
      /* Flaechenzahlen aktualisieren */
      if (!history[i].stamm) {         /* sonst liegen Daten bereits vor */
        if (history[i].prev2) {
          for (f=0; f<anz_face; f++) 
            {(history[i].flaechenzahl)[f] = 
             ((history[i].prev1)->flaechenzahl)[f] + 
             ((history[i].prev2)->flaechenzahl)[f];}
        }
        else {memcpy(history[i].flaechenzahl,(history[i].prev1)->flaechenzahl,
              sizeof(KNOTENTYP)*(size_t)anz_face);}
      } 
    }
  }

  for (i = anfang-1; i>=top_level; i--) {   /* obere Level zuruecksetzen */
    if (history[i].art==VERBINDUNG) {    /* Fall 1 */
      jj = ((his_rlg2[i]/his_rl2[i]-1)>>3)+1;  /* Anzahl wichtiger Elemente im 
                                                  akzeptiert-array */
      for (ii=0; ii<jj; ii++) {his_acc[i][ii] = 0;}   /* loeschen */
    }
    history[i] = hiscopy[i];
  }       
  return(l);
}
   
/**********************FINDE_PATCH*******************************************/
/*  Diese Funktion sucht nach Stammpatches mit Geschlecht "g" und "fl"
    Flaechen sowie Bordercode "bordercode" und "krit" kritischen Punkten. 
    Falls erfolgreich, so gibt sie den Zeiger auf das erste Element der 
    zugehoerigen Liste zurueck.                                             */ 

ELEM *finde_patch(KNOTENTYP *bordercode,KNOTENTYP g,KNOTENTYP fl,KNOTENTYP
                  krit) {
  static int l,len;       /* l = Zeiger auf aktuelle Stelle im Bordercode */
  static TREENODE *t;
  static ELEM *e;
  
  /* erster Level: Genus */
  t = tree[fl];
  while (t && t->code<g) {t=t->next;}
  if (!t || t->code!=g) {return(nil);}

  /* zweiter Level: Anzahl der kritischen Punkte */
  t = t->weiter.nextlevel;
  while (t && t->code<krit) {t=t->next;}
  if (!t || t->code!=krit) {return(nil);}

  /* weitere Level: Bordercode */
  l = 0;   len = bordercode[bordercode[0]+1];
  while (l<len) {         /* noch nicht am Ende des Codes */
    t = t->weiter.nextlevel;
    while (t && t->code<bordercode[l]) {t=t->next;}
    if (!t || t->code!=bordercode[l]) {return(nil);}
    l++;
  }        /* while */
  return(t->weiter.firstpatch);
}  
   
/******************NAECHSTE_RANDAUFTEILUNG***********************************/
/*  Schaltet "aufteilung" weiter, wobei der Rand 0 nicht beruecksichtigt 
    wird. Falls das Ende erreicht ist, wird "False" zurueckgegeben und auf
    0 zurueckgesetzt. "r" = Anzahl Raender                                  */
/*  ??? kann wesentlich vereinfacht werden, falls G_MAX<=7 => r<=8          */

BOOL naechste_randaufteilung(KNOTENTYP *bordercode,unsigned char *aufteilung) {
  static KNOTENTYP i,j,r;
  static BOOL ok;
  r = bordercode[0];
  i = 0;
  while (True) {
    aufteilung[i] += 1+(i==0);   /* Rand 0 nicht mitzaehlen */
    if ((r<(i+1)<<3 && (aufteilung[i]&(1<<(r&7)))) ||
        (r==(i+1)<<3 && aufteilung[i]==0))
       {aufteilung[i]=0;  return(False);}
       /* alle weiteren Elemente stehen schon auf 0 */
    else if (r>(i+1)<<3 && aufteilung[i]==0) {i++;}
    else {    /* Aufteilung gefunden -> pruefen, ob isomorph zu kleinerer
                 Aufteilung (dann ist Rand fuer Patch 1 vor isomorphem Rand
                 fuer Patch 2 zugeteilt worden) */
      if (r<3) {return(True);}
      ok = True;
      for (j=2; j<r; j++) {  /* Raender j-1 und j miteinander vergleichen */
        if (vergleiche_codes(&bordercode[bordercode[j]],bordercode[j+1]-
            bordercode[j],&bordercode[bordercode[j+1]],
            bordercode[j+2]-bordercode[j+1])==0 && IS_PATCH1(aufteilung,j-1) &&
            IS_PATCH2(aufteilung,j))    /* Raender sind isomorph und schon
                                        einmal andersherum aufgeteilt worden */
           {i = 0;   j = r;   ok = False;}     /* nochmal */
      }
      if (ok) {return(True);}
    }
  }
}

/* fuer die folgenden Funktionen gilt:  Wenn "von_oben==False", so sind bereits
   alle Werte g_td, fl_td etc. belegt, denn es wird weitergeschaltet. Wenn
   "von_oben==True", so sind bereits die uebergeordneten Werte belegt, also
   z.B. g_td, wenn fl_td belegt werden soll. Es gilt also IMMER:
   - Wenn "krit_td" belegt werden soll, so sind alle anderen Werte bereits
     belegt
   - Wenn "g_td" belegt werden soll, so sind alle Werte bis auf "krit_td"
     und "n_td" bereits belegt, so dass insbesondere die Anzahl der 
     Bruchkanten der Patches bereits feststeht.
   Die untergeordneten Werte sind jedoch natuerlich noch nicht belegt bzw.
   wenn sie belegt sind, so werden sie ja auf jeden Fall neu belegt.        */

/*******************SCHALTE_KRITAUFTEILUNG_WEITER****************************/
/*  Schaltet die Verteilung der kritischen Punkte des Patches mit dem Index
    "index" auf die beiden Vorgaengerpatches weiter und ruft im Bedarfsfall 
    die naechste Flaechenaufteilung auf. Der Returnwert sagt, ob das 
    Weiterschalten geklappt hat.                                            */

BOOL schalte_kritaufteilung_weiter(ELEM *e,POSTYP index,BOOL von_oben) {
  static KNOTENTYP kp1,kp2;
  BOOL neu;
  KNOTENTYP fl1,fl2,bk1,bk2,kpv;
  neu = von_oben;
  fl1 = fl_td[0][index];       fl2 = fl_td[1][index];
  bk1 = anz_bk_td[0][index];   bk2 = anz_bk_td[1][index];
  kpv = krit_td[vor[index]][vater_nr[index]]; /* kritische Punkte des Vaters */

  do {
    if (neu) {
      if (kp_anz[fl1][bk1]) {kriti_td[index] = 0;}     /* erste Moeglichkeit */
      else {return(False);}                /* keine Moeglichkeiten vorhanden */
      neu = False;
    }
    else {
      if (++kriti_td[index] == kp_anz[fl1][bk1])  /*alle Moeglichkeiten durch*/
         {return(von_oben ? False : 
                 schalte_knotenaufteilung_weiter(e,index,False));}  
    }
    if ((kp1 = kp[fl1][bk1][kriti_td[index]]) > kpv) {return(von_oben ? False :
        schalte_knotenaufteilung_weiter(e,index,False));}
       /* zu viele kritische Punkte werden von Patch 1 verlangt, wird auch
          nicht mehr kleiner, da "kp" aufsteigend sortiert ist */
    kp2 = kpv - kp1;
          /* "kp2"-Zuweisung nicht in das folgende Makro, da dann einerseits
             die Makroauswertung zu lang wird und andererseits dabei der Wert
             "kp1" und "kp2" doppelt berechnet wird */
    if (IS_KP_MOEGLICH(fl2,bk2,kp2)) {
         /* Patches mit den gegebenen kritischen Punkten sind theoretisch
            moeglich - nun kritische Punkte zuweisen */
      krit_td[0][index] = kp1;
      krit_td[1][index] = kp2;
      return(True);
    }
  } while (True);       /* noch keine akzeptierte Aufteilung gefunden */
}

/*******************SCHALTE_KNOTENAUFTEILUNG_WEITER************************/
/*  Schaltet die Verteilung von "n" inneren Knoten aus dem Patch mit dem Index
    "index" auf die beiden Vorgaengerpatches weiter und ruft im Bedarfsfall 
    die naechste Genusverteilung auf. Der Returnwert sagt, ob das 
    Weiterschalten geklappt
    hat. "von_oben" ist True, wenn nicht weitergeschaltet, sondern nur
    initialisiert werden soll (Aufruf kommt von Genusaufteilung).           */

BOOL schalte_knotenaufteilung_weiter(ELEM *e,POSTYP index,BOOL von_oben) {
  static KNOTENTYP n,a1; /* n = innere Knoten, die aufgeteilt werden muessen */
  static KNOTENTYP n2;
  static char vorg;
  static POSTYP vater;
  BOOL neu; 
  neu = von_oben;

  do {
    if (neu) {       /* Grenzen fuer Knotenzahlen festlegen */
      vorg = vor[index];   vater = vater_nr[index];
      if (e->art==EINSCHLUSS) 
           {n = n_td[vorg][vater] + 1 - e->nahtlen - e->ziellen;}
      else {n = n_td[vorg][vater] + 1 - e->nahtlen;}
      /* n_td[0][index] festlegen: */
      if ((a1 = anz3_td[0][index])&1) {  
        /* => auch n_td[0][index] muss ungerade sein */
        if (n==0) {return(False);}     /* geht nicht */
        else {n_td[0][index] = n-1 | 1;    n_td[1][index] = 1-(n&1);}
             /* naechstkleinere ungerade Zahl */
      }
      else {n_td[0][index] = n&(~1);    n_td[1][index] = n&1;}
           /* auch n_td[0][index] muss gerade (und groesstmoeglich) sein */
      if ((anz3_td[1][index]&1) != (n_td[1][index]&1))  
	 {fprintf(stderr,"Logischer Fehler in "
                  "'schalte_knotenaufteilung_weiter'!");  exit(99);}
      /* Flaechenzahlen ausrechnen, ueberpruefen und "n_td" angleichen: */
      if ((fl_td[0][index] = (EULERTYP)((n_td[0][index] + a1)>>1) + 2 - 
                             bc_td[0][index][0] - (g_td[0][index]<<1)) < 1)
         {return(False);}  /* denn groesser geht's nicht mehr */
         /* tritt auf z.B. bei g==2, v==28, f==7 */ 
      if ((fl_td[1][index] = fl_td[vorg][vater] - fl_td[0][index]) < 1) {
         /* tritt selten auf, deshalb darf die folgende Auswertung ruhig
            etwas ausfuehrlicher sein 
            Ziel: fl_td[1][index] vergroessern - wenn's geht */
        fl_td[0][index] += fl_td[1][index]-1;   /* negativer Wert */
        if (fl_td[0][index] < 1) {return(False);} 
           /* Ausgleich nicht moeglich */
        if (n_td[0][index] >= (n2 = ((KNOTENTYP)(-fl_td[1][index])+1)<<1)) {
          n_td[0][index] -= n2;   n_td[1][index] += n2;
          fl_td[1][index] = 1;    /* kleinstmoeglocher Wert */
        }
        else {return(False);} /* Ausgleich wegen Knotenzahl nicht moeglich */
             /* tritt auf z.B. bei g==2, v==28, f==7 */
      }
      neu = False;
    }
    else {
      if (n_td[0][index]>1 && fl_td[0][index]>1) {
        n_td[0][index]-=2;  n_td[1][index]+=2;
        fl_td[0][index]--;  fl_td[1][index]++;
      }
      else {return(von_oben ? False : 
                   schalte_genusaufteilung_weiter(e,index,False));}  
    }
    if ((pv<5 || (bk_moeglich[fl_td[0][index]][anz_bk_td[0][index]] &&
                  bk_moeglich[fl_td[1][index]][anz_bk_td[1][index]])) &&
       (krit_max==0 || schalte_kritaufteilung_weiter(e,index,True))) {
        /* Anmerkung: Anzahl Bruchkanten uebersteigt nicht Maximum (denn 
           das wird bereits bei Genusaufteilung ueberprueft), so dass 
           existentes Element in "bk_moeglich" angesprochen wird */
      if (krit_max==0) {krit_td[0][index] = krit_td[1][index] = 0;}
         /* weil "schalte_kritaufteilung_weiter" nicht aufgerufen wird, so dass
            die Werte nicht automatisch gesetzt werden */
      return(True);
    }  
  } while (True);
}

/*******************SCHALTE_GENUSAUFTEILUNG_WEITER***************************/
/*  Schaltet die Verteilung des Geschlechts des Patches mit dem Index
    "index" auf die beiden Vorgaengerpatches weiter und ruft im Bedarfsfall 
    die naechste Randverteilung auf. Der Returnwert sagt, ob das
    Weiterschalten geklappt hat.                                            */

BOOL schalte_genusaufteilung_weiter(ELEM *e,POSTYP index,BOOL von_oben) {
  BOOL neu;
  neu = von_oben;
  do {
    if (neu) {
      g_td[0][index] = 0;   
      g_td[1][index] = g_td[vor[index]][vater_nr[index]]; 
      anz_bk_td[0][index] = ANZ_BK_BEREINIGT(ERMITTLE_ANZ_BK(bc_td[0][index]),
                            0,bc_td[0][index][0]);
      anz_bk_td[1][index] = ANZ_BK_BEREINIGT(ERMITTLE_ANZ_BK(bc_td[1][index]),
                            g_td[1][index],bc_td[1][index][0]);
      /* "bc_td" steht fest - siehe Kommentar vor 
         "schalte_kritverteilung_weiter" */
      neu = False;
    }
    else {
      if (g_td[1][index]) {
        g_td[1][index]--;            g_td[0][index]++;
        anz_bk_td[1][index] -= 12;   anz_bk_td[0][index] += 12;
      }
      else {return(von_oben ? False : schalte_randaufteilung_weiter(e,index,
                                      False));}
    }    
    if (anz_bk_td[0][index]<=bk_max && bk_moeglich[0][anz_bk_td[0][index]] &&
        anz_bk_td[1][index]<=bk_max && bk_moeglich[0][anz_bk_td[1][index]] &&
        /* Bruchkantenanzahlen passen */
        schalte_knotenaufteilung_weiter(e,index,True)) {return(True);}
  } while (True);
}

/*******************SCHALTE_RANDAUFTEILUNG_WEITER***************************/
/*  Schaltet die Verteilung der Raender des Patches "e"
    auf die beiden Vorgaengerpatches weiter und ruft im Bedarfsfall die 
    naechste Ziellen auf.                                                  */

BOOL schalte_randaufteilung_weiter(ELEM *e,POSTYP index,BOOL von_oben) {
  static KNOTENTYP i;
  BOOL neu;
  neu = von_oben;
  do {
    if (neu) {
      for (i=0; i<R_ARRAY; i++) {(e->aufteilung)[i] = 0;} 
      neu = False;
    }
    else if (!naechste_randaufteilung(bc_td[vor[index]][vater_nr[index]],
             e->aufteilung)) {
      return(von_oben ? False : (e->art==DURCHSCHNITT ? 
             schalte_ziellen_weiter(e,index,False) :
             schalte_ziellen_weiter2(e,index,False)));
    }
    if (berechne_umrandungen(index) &&       /* Bordercodes sind gueltig */
        schalte_genusaufteilung_weiter(e,index,True)) {return(True);}
  } while (True);
}

/*****************SCHALTE_ZIELLEN_WEITER*************************************/
/*  Schaltet die Ziellen im Patch mit dem Index "index" weiter und ruft im 
    Bedarfsfall die naechste Nahtlen auf.                                   */
/*  Nur fuer den Fall, dass 2 Patches entlang einer Durchschnittsnaht
    entstehen, geeignet.                                                    */

BOOL schalte_ziellen_weiter(ELEM *e,POSTYP index,BOOL von_oben) {
  POSTYP vater;
  char vorg;
  vorg = vor[index];    vater = vater_nr[index];
  if (von_oben) {
    ziellenrandcodepos_td[index] = bc_td[vorg][vater][bc_td[vorg][vater][1]]==
      BB_KENNUNG ? 1 : 0;   /* Position im betrachteten Randcode */
    ziellenposindex_td[index] = 0;   /* Anzahl der bei diesem Eintrag
                                        uebersprungenen Kerben */
    e->ziellen = 1;   /* ziellen-Wert (unbrauchbar, da hier die Naht beginnt
                                       -> wird weitergeschaltet) */
  }
  /* (erste) brauchbare Kerbe suchen: */
  do {
    ziellenposindex_td[index]++;      /* eine Kerbe weiter */
    e->ziellen += 2;                  /* eine Kerbe weiter */
    while (ziellenrandcodepos_td[index] < 
           bc_td[vorg][vater][2]-bc_td[vorg][vater][1] &&
           ziellenposindex_td[index] >= 
           bc_td[vorg][vater][bc_td[vorg][vater][1] + 
           ziellenrandcodepos_td[index]]) {
      /* zu weit - letzte Kerbe wurde uebersprungen */
      (e->ziellen)++;                    /* Bruchkante ueberspringen */
      ziellenrandcodepos_td[index]++;    /* naechster Randcodeeintrag */
      ziellenposindex_td[index] = 0;     /* erste Kerbe ansteuern */
    }
    if (ziellenrandcodepos_td[index] == 
        bc_td[vorg][vater][2]-bc_td[vorg][vater][1])
       /* alle Moeglichkeiten durch -> bei vorgegebener Nahtlaenge und
          Verteilung keine brauchbare Kerbe vorhanden */
       {return(von_oben ? False : schalte_nahtlen_weiter(e,index,False));} 
    else if (schalte_randaufteilung_weiter(e,index,True)) 
            {return(True);}
  } while (True);
} 

/*****************SCHALTE_ZIELLEN_WEITER2************************************/
/*  Wie "schalte_ziellen_weiter", aber fuer e->art==EINSCHLUSS anstelle
    von e->art==DURCHSCHNITT.                                               */

BOOL schalte_ziellen_weiter2(ELEM *e,POSTYP index,BOOL von_oben) {
  BOOL neu;
  neu = von_oben;              /* von oben => e->ziellen neu initialisieren */
  do {
    if (neu) {e->ziellen = MIN(3,small_face);   neu = False;}  
             /* e->ziellen <= n_td[vater] ->  n_td[index] bleibt >=0 */
    else {
      if (e->ziellen + e->nahtlen <= n_td[vor[index]][vater_nr[index]])
         {e->ziellen++;}             /* "<=" wegen Zaunprinzip */
      else {         /* alle neuen Knoten bereits in die Naht einbezogen */
        return(von_oben ? False : schalte_nahtlen_weiter(e,index,False));
      }
    }
    if (schalte_randaufteilung_weiter(e,index,True)) {return(True);}
  } while (True);
}

/*****************SCHALTE_NAHTLEN_WEITER*************************************/
/*  Schaltet die Nahtlen im Patch mit dem Index "index" weiter.             */
/*  Falls von_oben==True, so enthaelt e->nahtlen bereits den Wert, mit dem
    gearbeitet werden soll.                                                 */

BOOL schalte_nahtlen_weiter(ELEM *e,POSTYP index,BOOL von_oben) {
  do {
    if (!von_oben) {
      if (e->nahtlen>1) {e->nahtlen--;} else {return(False);}
    }
    if ((e->art==DURCHSCHNITT && schalte_ziellen_weiter(e,index,True)) ||
        (e->art==EINSCHLUSS && schalte_ziellen_weiter2(e,index,True)))
        {return(True);}
    von_oben = False;   /* falls Schleife zweites Mal durchlaufen wird, so
                           kommt die Rekursion aus der Funktion "schalte_
                           ziellen_weiter", also von unten */
  } while (True);
}  
  
/*****************SUCHE_PATCH************************************************/
/*  Diese Funktion sucht einen Patch, der die zum History-Eintrag "index"
    gehoerenden Anforderungen erfuellt, top-down.                           */
/*  Informationen ueber den Patch werden in der History gespeichert.
    "neu_vorX_artY" ist "True", wenn im aktuellen Level fuer die zugehoerige
    Anzahl Vorgaenger und die zugehoerige Art ganz neu gesucht werden soll,
    und "False", wenn nur weitergeschaltet werden soll.
    "e" ist das Element, das fuer die Aufnahme der Daten des Patches 
    gedacht ist. "hislen" enthaelt die Anzahl der bereits belegten Elemente
    in der History, wobei das aktuelle Element bereits mitgezaehlt ist.
    "top_level" enthaelt den obersten Level, ab dem die Informationen ueber
    den Patch gespeichert sind.                                             */
/*  Rueckgabewerte:  False = keinen passenden Patch gefunden.               */
/*  Die Funktion befindet sich immer auf der untersten Ebene, d.h. das  
    letzte Element enthaelt die Informationen ueber die Vorgaenger 
    des uebergebenen Elements und alle anderen Elemente sind frei. Das
    uebergebene Element besitzt die Nummer "index" in der History.          */
/*  Stammpatches werden nie weitergeschaltet. Dafuer gibt es eine andere
    Funktion.                                                               */
/*  "pc" erhaelt den Wert True, sobald der Patchcheck oder "class2"
    einen Patch aussortiert.
    In dem Fall darf die aufrufende Funktion nicht annehmen, dass es keinen
    passenden Patch GIBT. Es kann ja sein, dass er nur wegen der Flaechen
    nicht mit anderen Patches zusammengepasst hat. Bei "class2" kann das
    Ergebnis beim naechsten Durchlauf schon ganz anders aussehen. Deshalb 
    auch hier "pc = True".                                                  */

BOOL suche_patch(POSTYP top_level,POSTYP *hislen,BOOL neu_vor1_art0,BOOL *pc,
                 BOOL letzter_patch) {
  static ELEM *e2;           /* gefundener Stammpatch */
  static KNOTENTYP i;
  static FLAECHENTYP f;
  static POSTYP fd;
  static BOOL dummy;
  KNOTENTYP *bordercode;    /* Zeiger auf aktuellen Bordercode */
  ELEM *e;            /* Zeiger auf aktuelles Historyelement */
  char vorg;    /* Patch ist 1. oder 2. Vorgaenger seines Vaters */
  KNOTENTYP g,fl,krit;
  EULERTYP n_neu;
  KNOTENTYP *ziellenrandcodepos,*ziellenposindex;
  BOOL erg,weiter,nextrand,nextziel,nextziel2,neue_nahtlen; 
  POSTYP index;
  POSTYP vater;           /* Nummer des Vaters in der History */
  POSTYP ip1,ip2;         /* Indices auf die beiden Vorgaenger */
  BOOL neu_vor1_art1,neu_vor1_art2,neu_vor2_art0,neu_vor2_art1;
  BOOL pc_sub;            /* fuer "pc"-Werte in niedrigeren Leveln */

  /* abkuerzende Zeigerzuweisungen: */
  index = *hislen - 1;
  e = &history[index];  
  vater = vater_nr[index];
  vorg = vor[index]; 
  bordercode = bc_td[vorg][vater];
  g = g_td[vorg][vater];   fl = fl_td[vorg][vater];   
  krit = krit_td[vorg][vater];
  if (patchcheck && index>top_level) {overflow[index] = overflow[index-1];}

  if (krit<cmax_g[g] || (krit==cmax_g[g] &&
     (fl<fmax_g[g] || (fl==fmax_g[g] && bordercode[0]<=bmax_g[g]))) ||
     (fl==1 && g==0 && bordercode[0]==1)) {
    /* Stammpatch gesucht (insbesondere sind Einzelflaechen immer Stammpatches,
       unabhaengig von der Anzahl der kritischen Punkte) */
    if (!recover && letzter_patch) {
      if (mod2_used && index-top_level+1==level2) {
        count2++;  count2 = count2%mod2;
        if (count2!=class2) {*pc = True;  return(False);}  /* nichts finden */
      }
      else if (mod3_used && index-top_level+1==level3) {
        count3++;  count3 = count3%mod3;
        if (count3!=class3) {*pc = True;  return(False);}  /* nichts finden */
      }
      else if (mod4_used && index-top_level+1==level4) {
        count4++;  count4 = count4%mod4;
        if (count4!=class4) {*pc = True;  return(False);}  /* nichts finden */
      }
      else if (mod5_used && index-top_level+1==level5) {
        count5++;  count5 = count5%mod5;
        if (count5!=class5) {*pc = True;  return(False);}  /* nichts finden */
      }
      else if (mod6_used && index-top_level+1==level6) {
        count6++;  count6 = count6%mod6;
        if (count6!=class6) {*pc = True;  return(False);}  /* nichts finden */
      }
      /* die "modx_used"-Abfragen sind notwendig (falls ein nicht benutzter
         levelx zufaellig gleich eines benutzten levely ist) und macht das
         Programm sogar schneller, wenn modx nicht benutzt wird */
    }
    if (recover) {
      if (mod2_used && alias && letzter_patch && 
          index-top_level+1==level2 && recovercount2!=class2) {
        recover = False;     /* Recovering abbrechen, da nur bei einem der
                                neuen Zweige fortgesetzt werden soll. Bei den
                                anderen wird Misserfolg vorgetaeuscht. */
        count = recovercount;    count2 = recovercount2;
        count3 = recovercount3;  count4 = recovercount4;
        count5 = recovercount5;  count6 = recovercount6;
        *pc = True;  return(False);
      }
      if (mod3_used && alias2 && letzter_patch && 
         index-top_level+1==level3 && class3!=recovercount3) {
        recover = False;  
        count = recovercount;    count2 = recovercount2;
        count3 = recovercount3;  count4 = recovercount4;
        count5 = recovercount5;  count6 = recovercount6;
        *pc = True;  return(False);
      }
      if (mod4_used && alias3 && letzter_patch && 
         index-top_level+1==level4 && class4!=recovercount4) {
        recover = False;  
        count = recovercount;    count2 = recovercount2;
        count3 = recovercount3;  count4 = recovercount4;
        count5 = recovercount5;  count6 = recovercount6;
        *pc = True;  return(False);
      }
      if (mod5_used && alias4 && letzter_patch && 
         index-top_level+1==level5 && class5!=recovercount5) {
        recover = False;  
        count = recovercount;    count2 = recovercount2;
        count3 = recovercount3;  count4 = recovercount4;
        count5 = recovercount5;  count6 = recovercount6;
        *pc = True;  return(False);
      }
      if (mod6_used && alias5 && letzter_patch && 
         index-top_level+1==level6 && class6!=recovercount6) {
        recover = False;  
        count = recovercount;    count2 = recovercount2;
        count3 = recovercount3;  count4 = recovercount4;
        count5 = recovercount5;  count6 = recovercount6;
        *pc = True;  return(False);
      }
    }
    if (e2 = finde_patch(bordercode,g,fl,krit)) {    /* erfolgreich gefunden */
      bestimme_gute_basen(e2);
      *e = *e2;   /* Informationen muessen kopiert werden, denn
             fuer den Fall, dass ein Patch an zwei Stellen eingesetzt wird,
             werden mehrere "his_nr"-Eintraege gebraucht. Insbesondere wird 
             auch der Zeiger auf die Flaechenanzahlen kopiert, so dass die
             Zahlen selbst nicht kopiert zu werden brauchen. Stattdessen muss
             bei Bedarf der Zeiger "flaechenzahl" wieder auf den 
             Speicherbereich zurueckgesetzt werden, der fuer das vorliegende
             History-Element eigentlich gedacht ist (siehe 15 Zeilen weiter
             unten). */ 
      e->his_nr = index;            /* wurde durch Kopie geloescht */
      if (patchcheck && !overflow[index] && !patch_check_td(top_level,index)) 
         {*pc = True;  return(False);}
      return(True);      /* "zweig[index]" ist bei Stammpatches immer 0 */
    }         
    else {return(False);}        /* nichts gefunden */
  }
  /* ab hier gilt: kein Stammpatch gesucht */
  if (bordercode[bordercode[1]]==0) {return(False);}          /* keine Kerbe */

  e->stamm = False;           /* evtl. veralteten Eintrag ueberschreiben */
  if (facenumbers) {e->flaechenzahl = his_faces + index*anz_face;}
                   /* evtl. veralteten Eintrag ueberschreiben */

  /* abkuerzende Zeiger- und Wertzuweisungen: */
  ziellenrandcodepos = &ziellenrandcodepos_td[index];
  ziellenposindex = &ziellenposindex_td[index];
  n_neu = n_td[vorg][vater];
  neu_vor1_art1 = neu_vor1_art2 = neu_vor2_art0 = neu_vor2_art1 = 
                  neu_vor1_art0;   /* neu <=> alles neu */

  if (neu_vor1_art0) {                    /* erstmalige Zuweisungen */
    /* Anfang fuer "vorg" und "art" festlegen: */
    e->vorg = 1;
    e->art = g==0 ? VERBINDUNG : DURCHSCHNITT;
    if (e->art==VERBINDUNG && bordercode[0]==1) 
       {e->art = DURCHSCHNITT;  e->vorg = 2;}
    if (e->vorg==2 && fl==1) {return(False);}    /* g==0, fl==1, 1 Rand */

    /* nun Defaults fuer einen Vorgaenger festlegen: */
    if (e->art==DURCHSCHNITT) {g_td[0][index] = g-1;}   
       /* sonst spaeter festlegen */   
    fl_td[0][index] = fl;   
    krit_td[0][index] = krit;
    e->nahtlen = (KNOTENTYP)(n_neu+1);  /* hoechstmoegliche Nahtlaenge */
    n_td[0][index] = 0;        /* also kein innerer Knoten mehr uebrig */
    *ziellenrandcodepos = bordercode[1] + 
                          (bordercode[bordercode[1]]==BB_KENNUNG);
                          /* Bordercodeposition im betrachteten Randcode */
    *ziellenposindex = 0;  /* Anzahl der bei diesem Eintrag
                              uebersprungenen Kerben */
    e->ziellen = 1;   /* ziellen-Wert (unbrauchbar, falls art==DURCHSCHNITT,
                         da hier die Naht beginnt -> wird weitergeschaltet) */
  }

  if (e->vorg==1) {      /* zunaechst ein Vorgaenger */ 
    while (e->art==DURCHSCHNITT) {     /* Durchschnitt */    
      do {                  /* weiterschalten */
        (*ziellenposindex)++;    /* eine Kerbe weiter */
        e->ziellen += 2;         /* eine Kerbe weiter */
        while (*ziellenrandcodepos < bordercode[2] &&
               *ziellenposindex >= bordercode[*ziellenrandcodepos]) {
          /* zu weit - letzte Kerbe wurde uebersprungen */
          (e->ziellen)++;                   /* Bruchkante ueberspringen */
          (*ziellenrandcodepos)++;  /* naechster Randcodeeintrag */
          *ziellenposindex = 0;     /* erste Kerbe ansteuern */
        }
        if (*ziellenrandcodepos == bordercode[2]) { 
           /* alle Moeglichkeiten durch -> naechste Nahtlaenge */
          e->nahtlen--;    n_td[0][index]++;
          *ziellenrandcodepos = bordercode[1] + 
                                (bordercode[bordercode[1]]==BB_KENNUNG);
          *ziellenposindex = 0; 
          e->ziellen = 1;   /* ziellen-Wert (in diesem Falle unbrauchbar,
                               da hier die Naht beginnt -> weiterschalten) */
        }   
      } while (e->nahtlen && e->ziellen==1);
        /* noch nicht alle Moeglichkeiten durch */

      if (e->nahtlen) {
        if (berechne_umrandungen(index)) {   /* Patch suchen */
          /* die Anzahl der Bruchkanten ("bk_max" und "bk_moeglich") braucht 
             nicht ueberprueft zu werden, da sich eine korrekte Anzahl auf 
             einen einzelnen Vorgaenger vererbt */
          /* n_td[0][index] = INNERE_KNOTEN(g-1,fl,bc_td[0][index][0],
             anz3_td[0][index]);   wird nun automatisch mitgezaehlt */
          /* if ((n_td[0][index]>0 || (n_td[0][index]==0 &&
                (anz3_td[0][index]&1)==0)) &&  
                    stimmt immer -> siehe 24.7.99 
                 e->nahtlen-1 + n_td[0][index] == n_neu  
                    stimmt immer, denn so ist n_td gerade gewaehlt) { */
            /* theoretisch moeglich */
          zweig[index]++;
          if (zweig[index]==ULONG_MAX) {zweig_error(index);}
          if (!recover || zweig[index]==recoverzweig[index]) { /* tiefer */
            if (recover) {
              if (*hislen==recover_hislen) {   /* Recovern abschliessen */
                /* An dieser Stelle ist klar:  das Recovering ist abgeschlos-
                   sen, denn wir befinden uns im untersten gespeicherten Level,
                   und da kommt man nicht hin, wenn bis dorthin nicht alle 
                   Recover-Zweige exakt getroffen werden. Deshalb Flag loeschen
                   und "count"-Wert wiederherstellen. */
                recover = False;   
                count = recovercount;    count2 = recovercount2;
                count3 = recovercount3;  count4 = recovercount4;
                count5 = recovercount5;  count6 = recovercount6;
              }
              else if (mod2_used && alias && letzter_patch && 
                       index-top_level+1==level2 && recovercount2!=class2) {
                recover = False;  /* Recovering abbrechen, da nur bei einem der
                                  neuen Zweige fortgesetzt werden soll. Bei den
                                  anderen wird spaeter Misserfolg 
                                  vorgetaeuscht. */
                count = recovercount;    count2 = recovercount2;
                count3 = recovercount3;  count4 = recovercount4;
                count5 = recovercount5;  count6 = recovercount6;
              }
              else if (mod3_used && alias2 && letzter_patch && 
                       index-top_level+1==level3 && class3!=recovercount3) {
                recover = False; 
                count = recovercount;    count2 = recovercount2;
                count3 = recovercount3;  count4 = recovercount4;
                count5 = recovercount5;  count6 = recovercount6;
              }
              else if (mod4_used && alias3 && letzter_patch && 
                       index-top_level+1==level4 && class4!=recovercount4) {
                recover = False; 
                count = recovercount;    count2 = recovercount2;
                count3 = recovercount3;  count4 = recovercount4;
                count5 = recovercount5;  count6 = recovercount6;
              }
              else if (mod5_used && alias4 && letzter_patch && 
                       index-top_level+1==level5 && class5!=recovercount5) {
                recover = False; 
                count = recovercount;    count2 = recovercount2;
                count3 = recovercount3;  count4 = recovercount4;
                count5 = recovercount5;  count6 = recovercount6;
              }
              else if (mod6_used && alias5 && letzter_patch && 
                       index-top_level+1==level6 && class6!=recovercount6) {
                recover = False; 
                count = recovercount;    count2 = recovercount2;
                count3 = recovercount3;  count4 = recovercount4;
                count5 = recovercount5;  count6 = recovercount6;
              }
            }
            else {
              if (letzter_patch) {
                if (mod2_used && index-top_level+1==level2) 
                   {count2++;  count2 = count2%mod2;}
                else if (mod3_used && index-top_level+1==level3) 
                   {count3++;  count3 = count3%mod3;}
                else if (mod4_used && index-top_level+1==level4) 
                   {count4++;  count4 = count4%mod4;}
                else if (mod5_used && index-top_level+1==level5) 
                   {count5++;  count5 = count5%mod5;}
                else if (mod6_used && index-top_level+1==level6) 
                   {count6++;  count6 = count6%mod6;}
              }
              if (save_flag) {     /* zwischenspeichern */
                /* dieses Zwischenspeichern ist besonders wichtig bei
                   Delaney-Aufrufen, wo kaum einmal Patches gefunden werden,
                   die zusammenpassen. "!recover" ist wichtig, falls der Re-
                   covervorgang laenger dauert als das Sicherungsintervall */
                /* die erforderlichen Details aus den oberen Levels muessen in
                   "p1"-"p15" vorliegen */
                speichere_graphen_aus_outputliste_in_files(*hislen,p1,p2,p3,p4,
                  p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15);
	      }
            }
            /* Falls unmittelbar zuvor das Recovering abgeschlossen wurde, so
               kommt "count2" mit genau dem Wert hier an, der in 
               "recovercount2" abgespeichert worden war. */
            if (!recover && letzter_patch &&
                ((mod2_used && index-top_level+1==level2 && count2!=class2) ||
                 (mod3_used && index-top_level+1==level3 && count3!=class3) ||
                 (mod4_used && index-top_level+1==level4 && count4!=class4) ||
                 (mod5_used && index-top_level+1==level5 && count5!=class5) ||
                 (mod6_used && index-top_level+1==level6 && count6!=class6)))
                 {*pc = True;}
            else {
              ip1 = *hislen;  (*hislen)++;
              e->prev1 = &history[ip1];    e->prev2 = nil;
              vater_nr[ip1] = index;       zweig[ip1] = 0L;
              vor1[ip1] = vor2[ip1] = False;   vor[ip1] = 0;
              if (suche_patch(top_level,hislen,True,pc,letzter_patch)) 
                 {return(True);}
              else {(*hislen)--;}  
            }
          }
          /*}*/    
        }
      }
      else {      /* alle Nahtlaengen durch */
        e->art = EINSCHLUSS;             /* weiterleiten */  
        neu_vor1_art1 = True;   /* initialisieren */
      }
    }             /* while e->art==DURCHSCHNITT */
 
    while (e->art==EINSCHLUSS) {         /* Einschluss */
      if (neu_vor1_art1) {    /* initialisieren */
        neu_vor1_art1 = False;
        e->ziellen = MIN(3,small_face);
        if (n_neu >= e->ziellen) {      /* sonst unmoeglich */
            e->nahtlen = (KNOTENTYP)(n_neu+1-e->ziellen);
            /* maximale Laenge der Naht bis zum Treffpunkt */
            n_td[0][index] = 0;
        }
        else {             /* art==VERBINDUNG einleiten */
          e->art = VERBINDUNG;
          neu_vor1_art2 = True;
        }
      }
      else {                   /* weiterschalten */
        if (e->nahtlen==1) {
          (e->ziellen)++;
          if (e->ziellen <= n_neu) {
            e->nahtlen = (KNOTENTYP)(n_neu+1-e->ziellen);  
            n_td[0][index] = 0;
          }
          else {e->art = VERBINDUNG;  neu_vor1_art2 = True;}  
               /* art==VERBINDUNG einleiten */
        }
        else {e->nahtlen--;  n_td[0][index]++;}
      }

      if (e->art==EINSCHLUSS && berechne_umrandungen(index)) {  
        /* Patch suchen */
        /* n_td[0][index] = INNERE_KNOTEN(g-1,fl,bc_td[0][index][0],
           anz3_td[0][index]);   wird automatisch mitgezaehlt */
        /* if ((n_td[0][index]>0 || (n_td[0][index]==0 &&
              (anz3_td[0][index]&1)==0)) &&  e->nahtlen-1 + e->ziellen +
            n_td[0][index] == n_neu) {   immer wahr - siehe oben */
          /* theoretisch moeglich */
        zweig[index]++;
        if (zweig[index]==ULONG_MAX) {zweig_error(index);}
        if (!recover || zweig[index]==recoverzweig[index]) { /* tiefer */
          if (recover) {
            if (*hislen==recover_hislen) {   /* Recovern abschliessen */
              recover = False;   
              count = recovercount;    count2 = recovercount2;
              count3 = recovercount3;  count4 = recovercount4;
              count5 = recovercount5;  count6 = recovercount6;
            }
            else if (mod2_used && alias && letzter_patch && 
                     index-top_level+1==level2 && recovercount2!=class2) {
              recover = False; 
              count = recovercount;    count2 = recovercount2;
              count3 = recovercount3;  count4 = recovercount4;
              count5 = recovercount5;  count6 = recovercount6;
            }
            else if (mod3_used && alias2 && letzter_patch && 
                     index-top_level+1==level3 && class3!=recovercount3) {
              recover = False; 
              count = recovercount;    count2 = recovercount2;
              count3 = recovercount3;  count4 = recovercount4;
              count5 = recovercount5;  count6 = recovercount6;
            }
            else if (mod4_used && alias3 && letzter_patch && 
                     index-top_level+1==level4 && class4!=recovercount4) {
              recover = False; 
              count = recovercount;    count2 = recovercount2;
              count3 = recovercount3;  count4 = recovercount4;
              count5 = recovercount5;  count6 = recovercount6;
            }
            else if (mod5_used && alias4 && letzter_patch && 
                     index-top_level+1==level5 && class5!=recovercount5) {
              recover = False; 
              count = recovercount;    count2 = recovercount2;
              count3 = recovercount3;  count4 = recovercount4;
              count5 = recovercount5;  count6 = recovercount6;
            }
            else if (mod6_used && alias5 && letzter_patch && 
                     index-top_level+1==level6 && class6!=recovercount6) {
              recover = False; 
              count = recovercount;    count2 = recovercount2;
              count3 = recovercount3;  count4 = recovercount4;
              count5 = recovercount5;  count6 = recovercount6;
            }
          }
          else {
            if (letzter_patch) {
              if (mod2_used && index-top_level+1==level2) 
               {count2++;  count2 = count2%mod2;}
              else if (mod3_used && index-top_level+1==level3) 
               {count3++;  count3 = count3%mod3;}
              else if (mod4_used && index-top_level+1==level4) 
               {count4++;  count4 = count4%mod4;}
              else if (mod5_used && index-top_level+1==level5) 
               {count5++;  count5 = count5%mod5;}
              else if (mod6_used && index-top_level+1==level6) 
               {count6++;  count6 = count6%mod6;}
            }
            if (save_flag) {     /* zwischenspeichern */
              speichere_graphen_aus_outputliste_in_files(*hislen,p1,p2,p3,p4,
                    p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15);
            }
          }
          if (!recover && letzter_patch && 
              ((mod2_used && index-top_level+1==level2 && count2!=class2) ||
               (mod3_used && index-top_level+1==level3 && count3!=class3) ||
               (mod4_used && index-top_level+1==level4 && count4!=class4) ||
               (mod5_used && index-top_level+1==level5 && count5!=class5) ||
               (mod6_used && index-top_level+1==level6 && count6!=class6)))
               {*pc = True;}
          else {
            ip1 = *hislen;  (*hislen)++;
            e->prev1 = &history[ip1];    e->prev2 = nil;
            vater_nr[ip1] = index;       zweig[ip1] = 0L;
            vor1[ip1] = vor2[ip1] = False;   vor[ip1] = 0;
            if (suche_patch(top_level,hislen,True,pc,letzter_patch)) 
               {return(True);}
            else {(*hislen)--;} 
          }
        }
        /*}*/    
      }
    }     /* while e->art==EINSCHLUSS */

    while (e->art==VERBINDUNG) {              /* Fall 1 */
      if (neu_vor1_art2) {           /* initialisieren */
        neu_vor1_art2 = False;
        if (bordercode[0]>1) {
          g_td[0][index] = g;  e->zielrand = 1;  e->ziellen = 1;
          e->nahtlen = (KNOTENTYP)(n_neu+1);  /* hoechstmoegliche Nahtlaenge */
          n_td[0][index] = 0;            /* deshalb kein innerer Knoten mehr */
          *ziellenposindex = 0;
          *ziellenrandcodepos = bordercode[e->zielrand+1] +
             (bordercode[bordercode[e->zielrand+1]]==BB_KENNUNG);
        }
        else {neu_vor2_art0 = True;  e->vorg = 2;  e->art = DURCHSCHNITT;}
      }
      else {           /* weiterschalten */
        (*ziellenposindex)++;    /* eine Kerbe weiter */
        e->ziellen += 2;         /* eine Kerbe weiter */
        while (e->ziellen <= per_td[vorg][e->zielrand][vater]  && 
              /* => *ziellenrandcodepos < bordercode[e->zielrand+2] && */
              (*ziellenposindex >= bordercode[*ziellenrandcodepos] /*||
              (bordercode[bordercode[e->zielrand+1]]==BB_KENNUNG && 
               *ziellenposindex > 0)*/  /* 2.Bedingung ist unwichtig, denn
               bei Bauchbinden gilt immer per_td==2 */)) {
          /* zu weit - letzte Kerbe wurde uebersprungen */
          (e->ziellen)++;                   /* Bruchkante ueberspringen */
          (*ziellenrandcodepos)++;  /* naechster Randcodeeintrag */
           *ziellenposindex = 0;     /* erste Kerbe ansteuern */
        }
        if (e->ziellen > per_td[vorg][e->zielrand][vater]) {
            /* alle Moeglichkeiten durch -> naechste Nahtlaenge */
          e->nahtlen--;          n_td[0][index]++;
          *ziellenposindex = 0; 
          *ziellenrandcodepos = bordercode[e->zielrand+1] +
             (bordercode[bordercode[e->zielrand+1]]==BB_KENNUNG);
          e->ziellen = 1;
        }
        if (e->nahtlen==0) {
          do {e->zielrand++;}
          while (e->zielrand < bordercode[0] &&
                 vergleiche_codes(&bordercode[bordercode[e->zielrand+1]],
                   bordercode[e->zielrand+2]-bordercode[e->zielrand+1],
                   &bordercode[bordercode[e->zielrand]],
                   bordercode[e->zielrand+1]-bordercode[e->zielrand])==0);
                   /* gleiche Randcodes => Rand ueberspringen */
          if (e->zielrand < bordercode[0]) {
            *ziellenrandcodepos = bordercode[e->zielrand+1] +
               (bordercode[bordercode[e->zielrand+1]]==BB_KENNUNG);
            e->nahtlen = (KNOTENTYP)(n_neu+1);   n_td[0][index] = 0;
                         /* hoechstmoegliche Nahtlaenge */
          }
        }
      }

      if (e->vorg==1 /* wegen Init. */ && e->zielrand < bordercode[0]) {
        if (berechne_umrandungen(index)) {   /* Patch suchen */
          /* n_td[0][index] = INNERE_KNOTEN(g,fl,bc_td[0][index][0],
             anz3_td[0][index]);   wird automatisch mitgezaehlt */
          /* if ((n_td[0][index]>0 || (n_td[0][index]==0 &&
              (anz3_td[0][index]&1)==0)) &&  e->nahtlen-1 + n_td[0][index] 
              == n_neu) {*/   /* immer wahr - siehe oben */
          zweig[index]++;
          if (zweig[index]==ULONG_MAX) {zweig_error(index);}
          if (!recover || zweig[index]==recoverzweig[index]) { /* tiefer */
            if (recover) {
              if (*hislen==recover_hislen) {   /* Recovern abschliessen */
                recover = False;   
                count = recovercount;    count2 = recovercount2;
                count3 = recovercount3;  count4 = recovercount4;
                count5 = recovercount5;  count6 = recovercount6;
              }
              else if (mod2_used && alias && letzter_patch && 
                       index-top_level+1==level2 && recovercount2!=class2) {
                recover = False; 
                count = recovercount;    count2 = recovercount2;
                count3 = recovercount3;  count4 = recovercount4;
                count5 = recovercount5;  count6 = recovercount6;
              }
              else if (mod3_used && alias2 && letzter_patch && 
                       index-top_level+1==level3 && class3!=recovercount3) {
                recover = False; 
                count = recovercount;    count2 = recovercount2;
                count3 = recovercount3;  count4 = recovercount4;
                count5 = recovercount5;  count6 = recovercount6;
              }
              else if (mod4_used && alias3 && letzter_patch && 
                       index-top_level+1==level4 && class4!=recovercount4) {
                recover = False; 
                count = recovercount;    count2 = recovercount2;
                count3 = recovercount3;  count4 = recovercount4;
                count5 = recovercount5;  count6 = recovercount6;
              }
              else if (mod5_used && alias4 && letzter_patch && 
                       index-top_level+1==level5 && class5!=recovercount5) {
                recover = False; 
                count = recovercount;    count2 = recovercount2;
                count3 = recovercount3;  count4 = recovercount4;
                count5 = recovercount5;  count6 = recovercount6;
              }
              else if (mod6_used && alias5 && letzter_patch && 
                       index-top_level+1==level6 && class6!=recovercount6) {
                recover = False; 
                count = recovercount;    count2 = recovercount2;
                count3 = recovercount3;  count4 = recovercount4;
                count5 = recovercount5;  count6 = recovercount6;
              }
            }
            else {
              if (letzter_patch) {
                if (mod2_used && index-top_level+1==level2) 
                   {count2++;  count2 = count2%mod2;}
                else if (mod3_used && index-top_level+1==level3) 
                   {count3++;  count3 = count3%mod3;}
                else if (mod4_used && index-top_level+1==level4) 
                   {count4++;  count4 = count4%mod4;}
                else if (mod5_used && index-top_level+1==level5) 
                   {count5++;  count5 = count5%mod5;}
                else if (mod6_used && index-top_level+1==level6) 
                   {count6++;  count6 = count6%mod6;}
              }
              if (save_flag) {     /* zwischenspeichern */
                speichere_graphen_aus_outputliste_in_files(*hislen,p1,p2,p3,p4,
                   p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15);
              }
            }
            if (!recover && letzter_patch &&
               ((mod2_used && index-top_level+1==level2 && count2!=class2) ||
                (mod3_used && index-top_level+1==level3 && count3!=class3) ||
                (mod4_used && index-top_level+1==level4 && count4!=class4) ||
                (mod5_used && index-top_level+1==level5 && count5!=class5) ||
                (mod6_used && index-top_level+1==level6 && count6!=class6))) 
                {*pc = True;}
            else {
              ip1 = *hislen;  (*hislen)++;
              e->prev1 = &history[ip1];    e->prev2 = nil;
              vater_nr[ip1] = index;       zweig[ip1] = 0L;
              vor1[ip1] = vor2[ip1] = False;   vor[ip1] = 0;
              if (suche_patch(top_level,hislen,True,pc,letzter_patch)) 
                 {return(True);}
              else {(*hislen)--;} 
            }
          }
          /*}*/
        }    
      }
      else {            /* alle Nahtlaengen und Raender durch */
        e->art = DURCHSCHNITT;   e->vorg = 2;       /* weiterleiten */  
        neu_vor2_art0 = True;            /* initialisieren */
      }
    }             /* while e->art==VERBINDUNG */
  }               /* if e->vorg==1 */

  /* Weiterschalten:  1.Flaechenzahl, 2.Geschecht, 3.Randaufteilung,
                      4.Ziellen,      5.Nahtlen
     Zuweisen in umgekehrter Reihenfolge */
  if (neu_vor2_art0) {      /* initialisieren */
    if (fl>1) {             /* sonst unmoeglich */
      if (anz3_td[vorg][vater]>1) {   /* mehr als eine Kerbe */
        /* Neues Element einweihen: */
        e->nahtlen = (KNOTENTYP)(n_neu+1);   /* 5. (Nahtlen) */
                     /* hoechstmoegliche Nahtlaenge */
        /* erste Wertebelegung suchen: */
        if (!schalte_nahtlen_weiter(e,index,True)) 
           {e->art = EINSCHLUSS;  neu_vor2_art1 = True;}
      }     
      else {e->art = EINSCHLUSS;  neu_vor2_art1 = True;}   /* nur eine Kerbe */
    }
    else {return(False);}    /* nichts mehr zu finden */
  }

  if (e->vorg==2) {     /* nun zwei Vorgaenger */

    while (e->art==DURCHSCHNITT) {     /* Durchschnitt */    
      if (neu_vor2_art0) {neu_vor2_art0 = False;  erg = True;}
      else {erg = krit_max ? schalte_kritaufteilung_weiter(e,index,False) : 
                  schalte_knotenaufteilung_weiter(e,index,False);}
            /* diese Unterscheidung dient nur der Beschleunigung, man koennte
               auch dann "kritaufteilung" aufrufen, wenn "krit_max==0" gilt. */
      if (erg) {        /* gueltige Wertebelegung gefunden */
        zweig[index]++;
        if (zweig[index]==ULONG_MAX) {zweig_error(index);}
        if (!recover || zweig[index]==recoverzweig[index]) { /* tiefer */
          if (recover) {
            if (*hislen==recover_hislen) {   /* Recovern abschliessen */
              recover = False;   
              count = recovercount;    count2 = recovercount2;
              count3 = recovercount3;  count4 = recovercount4;
              count5 = recovercount5;  count6 = recovercount6;
            }
            else if (mod2_used && alias && letzter_patch && 
                     index-top_level+1==level2 && recovercount2!=class2) {
              recover = False; 
              count = recovercount;    count2 = recovercount2;
              count3 = recovercount3;  count4 = recovercount4;
              count5 = recovercount5;  count6 = recovercount6;
            }
            else if (mod3_used && alias2 && letzter_patch && 
                     index-top_level+1==level3 && class3!=recovercount3) {
              recover = False; 
              count = recovercount;    count2 = recovercount2;
              count3 = recovercount3;  count4 = recovercount4;
              count5 = recovercount5;  count6 = recovercount6;
            }
            else if (mod4_used && alias3 && letzter_patch && 
                     index-top_level+1==level4 && class4!=recovercount4) {
              recover = False; 
              count = recovercount;    count2 = recovercount2;
              count3 = recovercount3;  count4 = recovercount4;
              count5 = recovercount5;  count6 = recovercount6;
            }
            else if (mod5_used && alias4 && letzter_patch && 
                     index-top_level+1==level5 && class5!=recovercount5) {
              recover = False; 
              count = recovercount;    count2 = recovercount2;
              count3 = recovercount3;  count4 = recovercount4;
              count5 = recovercount5;  count6 = recovercount6;
            }
            else if (mod6_used && alias5 && letzter_patch && 
                     index-top_level+1==level6 && class6!=recovercount6) {
              recover = False; 
              count = recovercount;    count2 = recovercount2;
              count3 = recovercount3;  count4 = recovercount4;
              count5 = recovercount5;  count6 = recovercount6;
            }
          }
          else {
            if (letzter_patch) {
              if (mod2_used && index-top_level+1==level2) 
                 {count2++;  count2 = count2%mod2;}
              else if (mod3_used && index-top_level+1==level3) 
                 {count3++;  count3 = count3%mod3;}
              else if (mod4_used && index-top_level+1==level4) 
                 {count4++;  count4 = count4%mod4;}
              else if (mod5_used && index-top_level+1==level5) 
                 {count5++;  count5 = count5%mod5;}
              else if (mod6_used && index-top_level+1==level6) 
                 {count6++;  count6 = count6%mod6;}
            }
            if (save_flag) {     /* zwischenspeichern */
              speichere_graphen_aus_outputliste_in_files(*hislen,p1,p2,p3,p4,
                 p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15);
            }
          }
          if (!recover && letzter_patch &&
              ((mod2_used && index-top_level+1==level2 && count2!=class2) ||
               (mod3_used && index-top_level+1==level3 && count3!=class3) ||
               (mod4_used && index-top_level+1==level4 && count4!=class4) ||
               (mod5_used && index-top_level+1==level5 && count5!=class5) ||
               (mod6_used && index-top_level+1==level6 && count6!=class6)))
              {*pc = True;}
          else if (krit_td[0][index]<krit_td[1][index] || 
             (krit_td[0][index]==krit_td[1][index] &&
             (fl_td[0][index]<fl_td[1][index] || (fl_td[0][index]==
              fl_td[1][index] && (g_td[0][index]<g_td[1][index] || 
              (g_td[0][index]==g_td[1][index] && 
              bc_td[0][index][0]<=bc_td[1][index][0])))))) {
            ip1 = *hislen;  (*hislen)++;
            e->prev1 = &history[ip1];
            e->prev2 = nil;   /* vorerst;  der Zeiger muss explizit geloescht
               werden, damit "patch_check_td" nicht versucht, Flaechenzahlen
               aus den (veralteten) Vorgaengern auszulesen */
            vor1[ip1] = True;  vor2[ip1] = False;   vor[ip1] = 0;
            vater_nr[ip1] = index;      zweig[ip1] = 0L;
            if (suche_patch(top_level,hislen,True,pc,letzter_patch)) {
              do {
                ip2 = *hislen;   (*hislen)++;   /* in die Schleife, da sich
                    "hislen" beim Weiterschalten von Patch 1 aendern kann */
                e->prev2 = &history[ip2];
                vor1[ip2] = False;  vor2[ip2] = True;   vor[ip2] = 1;
                vater_nr[ip2] = index;    zweig[ip2] = 0L;
                pc_sub = False;   /* es ist sinnvoll, dieses Kommando in die
                  Schleife zu packen, denn es ist durchaus moeglich, dass
                  beim ersten Durchlauf "pc_sub==True" gesetzt wird, spaeter
                  aber nicht mehr, naemlich dann, wenn es tatsaechlich 
                  konstruktionsbedingt keinen passenden Patch 2 gibt, dies
                  aber beim ersten Durchlauf nicht festgestellt wird, weil
                  zwischendurch (d.h. vor der Komplettierung des Baumes)
                  schon die Flaechenzahlen ueberschritten werden (das ist ja
                  das Grundproblem, weshalb es sein kann, dass der Patchcheck
                  sogar zu einer Verlangsamung fuehrt). */ 
                if (suche_patch(top_level,hislen,True,&pc_sub,
                    letzter_patch)) 
                   {return(True);}  /* An dieser Stelle braucht nicht 
                   geprueft zu werden, ob "pc_sub==True" gilt (das wuerde 
                   bedeuten, dass zwar Patch 2 gefunden wurde, aber 
                   zwischendurch ein frueherer Fundort verworfen wurde, weil
                   die Flaechenzahlen nicht passten), denn wenn im weiteren 
                   Verlauf der Konstruktion ein anderer Patch nur deshalb 
                   nicht gefunden wird, weil die Flaechenzahlen versagen, so
                   wird an der dortigen Stelle der Wert "pc_sub" immer noch 
                   rechtzeitig gesetzt werden. */  
                else {e->prev2 = nil;  *hislen = ip2;}
                   /* der Zeiger muss explizit geloescht
                      werden, damit "patch_check_td" nicht versucht, 
                      Flaechenzahlen aus den (veralteten) Vorgaengern 
                      auszulesen */
              } while ((pc_sub || mod2_used || mod3_used || mod4_used ||
                        mod5_used || mod6_used) && 
                       schalte_weiter_td(hislen,ip1,top_level,&dummy,
                       letzter_patch));
                /* - Lazy-Evaluation ist wichtig: Solange wie "pc_sub==True"
                     gilt, wird versucht, Patch 1 weiterzuschalten, damit  
                     danach vielleicht die Flaechenzahlen stimmen. 
                   - "Dummy" kann genommen werden, denn wenn die Funktion
                     wegen der Flaechenzahlen nicht mehr weiterschalten kann,
                     so wird die Schleife abgebrochen, "pc_sub" ist immer
                     noch "True" und "pc" wird in der folgenden Zeile 
                     gesetzt. */
              if (pc_sub || mod2_used || mod3_used || mod4_used || mod5_used ||
                  mod6_used) {*pc = True;}
               /* falls an dieser Stelle
                 "pc_sub==False" gilt, so wurde Patch 2 konstruktionsbedingt
                 nicht gefunden (entweder sofort oder nach einem Weiterschal-
                 ten von Patch 1, das das komplette Erstellen des Konstruk-
                 tionsbaums erst ermoeglichte; in beiden Faellen ist es nicht
                 notwendig, "pc" zu setzen) */
            }
            /* Wenn das Programm hierher kommt, so gilt:  einer der beiden
               Patches wurde nicht gefunden */
            *hislen = ip1;     /* d.h. auch wenn einer der beiden Patches 
              erfolgreich gefunden wurde, so werden die zu ihm gehoerigen 
              Daten geloescht */ 
          }
          else {
            ip1 = *hislen;  (*hislen)++;
            e->prev2 = &history[ip1];   e->prev1 = nil;
            vor1[ip1] = False;  vor2[ip1] = True;   vor[ip1] = 1;
            vater_nr[ip1] = index;     zweig[ip1] = 0L;
            if (suche_patch(top_level,hislen,True,pc,letzter_patch)) {
              do {
                ip2 = *hislen;   (*hislen)++;
                e->prev1 = &history[ip2];
                vor1[ip2] = True;  vor2[ip2] = False;   vor[ip2] = 0;
                vater_nr[ip2] = index;   zweig[ip2] = 0L;
                pc_sub = False;
                if (suche_patch(top_level,hislen,True,&pc_sub,
                    letzter_patch)) {return(True);}
                else {e->prev1 = nil;  *hislen = ip2;}
              } while ((pc_sub || mod2_used || mod3_used || mod4_used ||
                        mod5_used || mod6_used) && 
                       schalte_weiter_td(hislen,ip1,top_level,&dummy,
                                         letzter_patch));
              if (pc_sub || mod2_used || mod3_used || mod4_used || mod5_used ||
                  mod6_used) {*pc = True;}
            }
            *hislen = ip1;
          }
        }
      }
      else {      /* alle Wertebelegungen durch */
        e->art = EINSCHLUSS;             /* weiterleiten */  
        neu_vor2_art1 = True;   /* initialisieren */
      }
    }

    while (e->art==EINSCHLUSS) {             /* Einschluss */
      if (neu_vor2_art1) {      /* initialisieren */ 
        /* es gilt fl>1 */
        neu_vor2_art1 = False;
        if (n_neu>=MIN(3,small_face)) {
          /* neue Knoten mindestens so viele wie kleinstmoegliche Schleife */
          e->nahtlen = (KNOTENTYP)(n_neu+1-MIN(3,small_face));
                       /* hoechstmoegliche Nahtlaenge */
          /* erste Wertebelegung suchen: */
          if (!schalte_nahtlen_weiter(e,index,True)) {return(False);}
        }
        else {return(False);}   /* nichts geht mehr */
        erg = True;   neu_vor2_art1 = False;
      }
      else {erg = krit_max ? schalte_kritaufteilung_weiter(e,index,False) :
                  schalte_knotenaufteilung_weiter(e,index,False);}
      if (erg) {        /* gueltige Wertebelegung gefunden */
        zweig[index]++;
        if (zweig[index]==ULONG_MAX) {zweig_error(index);}
        if (!recover || zweig[index]==recoverzweig[index]) { /* tiefer */
          if (recover) {
            if (*hislen==recover_hislen) {   /* Recovern abschliessen */
              recover = False;   
              count = recovercount;    count2 = recovercount2;
              count3 = recovercount3;  count4 = recovercount4;
              count5 = recovercount5;  count6 = recovercount6;
            }
            else if (mod2_used && alias && letzter_patch && 
                     index-top_level+1==level2 && recovercount2!=class2) {
              recover = False; 
              count = recovercount;    count2 = recovercount2;
              count3 = recovercount3;  count4 = recovercount4;
              count5 = recovercount5;  count6 = recovercount6;
            }
            else if (mod3_used && alias2 && letzter_patch && 
                     index-top_level+1==level3 && class3!=recovercount3) {
              recover = False; 
              count = recovercount;    count2 = recovercount2;
              count3 = recovercount3;  count4 = recovercount4;
              count5 = recovercount5;  count6 = recovercount6;
            }
            else if (mod4_used && alias3 && letzter_patch && 
                     index-top_level+1==level4 && class4!=recovercount4) {
              recover = False; 
              count = recovercount;    count2 = recovercount2;
              count3 = recovercount3;  count4 = recovercount4;
              count5 = recovercount5;  count6 = recovercount6;
            }
            else if (mod5_used && alias4 && letzter_patch && 
                     index-top_level+1==level5 && class5!=recovercount5) {
              recover = False; 
              count = recovercount;    count2 = recovercount2;
              count3 = recovercount3;  count4 = recovercount4;
              count5 = recovercount5;  count6 = recovercount6;
            }
            else if (mod6_used && alias5 && letzter_patch && 
                     index-top_level+1==level6 && class6!=recovercount6) {
              recover = False; 
              count = recovercount;    count2 = recovercount2;
              count3 = recovercount3;  count4 = recovercount4;
              count5 = recovercount5;  count6 = recovercount6;
            }
          }
          else {
            if (letzter_patch) {
              if (mod2_used && index-top_level+1==level2) 
                 {count2++;  count2 = count2%mod2;}
              else if (mod3_used && index-top_level+1==level3) 
                 {count3++;  count3 = count3%mod3;}
              else if (mod4_used && index-top_level+1==level4) 
                 {count4++;  count4 = count4%mod4;}
              else if (mod5_used && index-top_level+1==level5) 
                 {count5++;  count5 = count5%mod5;}
              else if (mod6_used && index-top_level+1==level6) 
                 {count6++;  count6 = count6%mod6;}
            }
            if (save_flag) {     /* zwischenspeichern */
              speichere_graphen_aus_outputliste_in_files(*hislen,p1,p2,p3,p4,
                 p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15);
            }
          }
          if (!recover && letzter_patch && 
              ((mod2_used && index-top_level+1==level2 && count2!=class2) ||
               (mod3_used && index-top_level+1==level3 && count3!=class3) ||
               (mod4_used && index-top_level+1==level4 && count4!=class4) ||
               (mod5_used && index-top_level+1==level5 && count5!=class5) ||
               (mod6_used && index-top_level+1==level6 && count6!=class6)))
               {*pc = True;}
          else if (krit_td[0][index]<krit_td[1][index] || 
             (krit_td[0][index]==krit_td[1][index] &&
             (fl_td[0][index]<fl_td[1][index] || 
             (fl_td[0][index]==fl_td[1][index] && 
              (g_td[0][index]<g_td[1][index] || 
              (g_td[0][index]==g_td[1][index] && 
               bc_td[0][index][0]<=bc_td[1][index][0])))))) {
            ip1 = *hislen;  (*hislen)++;
            e->prev1 = &history[ip1];   e->prev2 = nil;
            vor1[ip1] = True;  vor2[ip1] = False;   vor[ip1] = 0;
            vater_nr[ip1] = index;    zweig[ip1] = 0L;
            if (suche_patch(top_level,hislen,True,pc,letzter_patch)) {
              do {
                ip2 = *hislen;   (*hislen)++;
                e->prev2 = &history[ip2];
                vor1[ip2] = False;  vor2[ip2] = True;   vor[ip2] = 1;
                vater_nr[ip2] = index;   zweig[ip2] = 0L;
                pc_sub = False;
                if (suche_patch(top_level,hislen,True,&pc_sub,letzter_patch)) 
                   {return(True);}
                else {e->prev2 = nil;  *hislen = ip2;}
              } while ((pc_sub || mod2_used || mod3_used || mod4_used ||
                        mod5_used || mod6_used) && 
                       schalte_weiter_td(hislen,ip1,top_level,&dummy,
                                         letzter_patch));
              if (pc_sub || mod2_used || mod3_used || mod4_used || mod5_used ||
                  mod6_used) {*pc = True;}
            }
            *hislen = ip1;
          }
          else {
            ip1 = *hislen;  (*hislen)++;
            e->prev2 = &history[ip1];    e->prev1 = nil;
            vor1[ip1] = False;  vor2[ip1] = True;   vor[ip1] = 1;
            vater_nr[ip1] = index;    zweig[ip1] = 0L;
            if (suche_patch(top_level,hislen,True,pc,letzter_patch)) {
              do {
                ip2 = *hislen;   (*hislen)++;
                e->prev1 = &history[ip2];
                vor1[ip2] = True;  vor2[ip2] = False;   vor[ip2] = 0;
                vater_nr[ip2] = index;   zweig[ip2] = 0L;
                pc_sub = False;
                if (suche_patch(top_level,hislen,True,&pc_sub,letzter_patch)) 
                   {return(True);}
                else {e->prev1 = nil;  *hislen = ip2;}
              } while ((pc_sub || mod2_used || mod3_used || mod4_used ||
                        mod5_used || mod6_used) && 
                       schalte_weiter_td(hislen,ip1,top_level,&dummy,
                                         letzter_patch));
              if (pc_sub || mod2_used || mod3_used || mod4_used || mod5_used ||
                  mod6_used) {*pc = True;}
            }
            *hislen = ip1;   
          }
        }
      }
      else {return(False);}    /* alle Wertebelegungen durch */
    }
  }
}  

/*******************SCHALTE_WEITER_TD****************************************/
/*  Diese Funktion schaltet in einem top-down-Konstruktionsbaum zur
    naechsten moeglichen Konstruktion weiter. Falls es keine mehr gibt, wird
    "False" zurueckgegeben.                                                 */
/*  "top_index" ist der Index des obersten Patches, der noch
    weitergeschaltet werden darf, d.h. sobald 
    dieser nicht mehr weitergeschaltet werden kann, ist das Weiterschalten 
    zu Ende. "top_level" ist dagegen die absolute Wurzel (die beiden Werte
    koennen sich unterscheiden, wenn die Funktion von der Funktion
    "suche_patch" aus aufgerufen wird).                                      */
/*  "index" ist der Index des Patches, bei dem weitergeschaltet werden soll.
    Dies ist zunaechst die letzte Position im history-Array.                */
/*  Bei 2 Vorgaengern wird zunaechst derjenige weitergeschaltet, der weiter
    hinten in der Liste steht. Das kann aber auch der Vorgaenger Nr.1 sein, 
    wenn dieser kleiner ist als Vorgaenger Nr.2.                            */
/*  "schalte_weiter_td" wird im Recover-Modus nicht aufgerufen.             */
  
BOOL schalte_weiter_td(POSTYP *hislen,POSTYP top_index,POSTYP top_level,
     BOOL *pc,BOOL letzter_patch) {
  ELEM *e;     /* alles nicht static wegen Rekursion bei "patchcheck" */
  POSTYP index,vater,ip,i,top_change;   /* "top_change" = hoechste
         Position, an der eventuell ein neuer Vorgaenger 2 gesucht werden
         muss. */
  BOOL weiter;     /* False => Suchen nach uebergeordneten Knoten ist
                      unterbrochen worden */ 
  top_change = index = *hislen-1;
  do { 
    if (!history[index].stamm) {
      if (suche_patch(top_level,hislen,False,pc,letzter_patch)) {
        /* gefunden */
        weiter = True;
        for (i = index-1; weiter && i>=top_change; i--) {
            /* uebergeordnete Knoten absuchen -> fehlen noch Vorgaenger? */
          if ((e = &history[i])->vorg==2) {
            if (e->prev2==nil) {     
              ip = *hislen;   (*hislen)++;
              vor1[ip] = False;   vor2[ip] = True;   vor[ip] = 1;
              e->prev2 = &history[ip];
              vater_nr[ip] = i;  
              zweig[ip] = 0L;
              if (!suche_patch(top_level,hislen,True,pc,letzter_patch)) {
                if (!pc) {fprintf(stderr,"Logischer Fehler in"
                                  " schalte_weiter_td\n"); exit(38);} 
                /* denn die Werte von Patch 1 haben sich nicht geaendert und 
                   es wurde schon einmal ein passender Patch 2 gefunden */  
                /* Der Grund ist also klar: Die Flaechenzahlen oder "class2"
                   oder "class3" passen nicht mehr */
                index = ip;   weiter = False;   *hislen = ip+1; 
                e->prev2 = nil;     /* nochmal das Ganze */
                /* "top_change" braucht nicht angepasst zu werden, weil "i"
                   der Vater von "ip" ist und "i>=top_change" gilt */
              }
            }
            else if (e->prev1==nil) {  
              ip = *hislen;   (*hislen)++;
              vor1[ip] = True;   vor2[ip] = False;   vor[ip] = 0;
              e->prev1 = &history[ip];
              vater_nr[ip] = i;
              zweig[ip] = 0L;
              if (!suche_patch(top_level,hislen,True,pc,letzter_patch)) {
                if (!pc) {fprintf(stderr,"Logischer Fehler 2 in "
                                  "schalte_weiter_td\n");  exit(39);} 
                index = ip;   weiter = False;   *hislen = ip+1;
                e->prev1 = nil;
              }
            }
          }
        }
        if (weiter) {return(True);} 
           /* alle passenden Gegenstuecke zugeordnet */
      }
      else {      /* Patch wurde nicht gefunden */
        vater = vater_nr[index];
        top_change = MIN(top_change,vater); 
        if (vor2[index])      {history[vater].prev2 = nil;}  /* neu suchen */
        else if (vor1[index]) {history[vater].prev1 = nil;}  /* neu suchen */
      }
    }
    else {    /* auch hier neu zuordnen */
      vater = vater_nr[index];
      top_change = MIN(top_change,vater); 
      if (vor2[index])      {history[vater].prev2 = nil;}  /* neu suchen */
      else if (vor1[index]) {history[vater].prev1 = nil;}  /* neu suchen */
    }
    (*hislen)--;  index--;
  } while(index >= top_index);
  return(False);     /* nichts mehr gefunden */
}
 
/*****************BILDE_SW2_CODE********************************************/
/*  Diese Funktion ermittelt fuer die Sandwichverklebung mit gerader Laenge
    "l2"  den Bordercode.                                                  */

void bilde_sw2_code(KNOTENTYP l1,KNOTENTYP l2,KNOTENTYP l3,
  KNOTENTYP *bordercode) {
  static unsigned char fall;
  fall = ((l3&1)<<1) + (l1&1) + 1;
  switch (fall) {  
    /* Faelle 1-4:  Code vorbereiten */
    case 1: {
      bordercode[3] = (l1+l2+l3)>>1;
      bordercode[4] = (l1>>1)-1;
      bordercode[5] = bordercode[7] = 0;
      bordercode[6] = (l2>>1)-1;
      bordercode[8] = (l3>>1)-1;
      break;
    }
    case 2: {
      bordercode[3] = (l1+l2+l3)>>1;
      bordercode[4] = l1>>1;
      bordercode[5] = (l2>>1)-1;
      bordercode[6] = bordercode[8] = 0;
      bordercode[7] = (l3>>1)-1;
      break;
    }
    case 3: {
      bordercode[3] = (l1+l2+l3)>>1;
      bordercode[4] = bordercode[6] = 0;
      bordercode[5] = (l1>>1)-1;
      bordercode[7] = (l2>>1)-1;
      bordercode[8] = l3>>1;
      break;
    }
    case 4: {
      bordercode[3] = ((l1+l2+l3)>>1)-1;
      bordercode[4] = bordercode[8] = 0;
      bordercode[5] = l1>>1;
      bordercode[6] = (l2>>1)-1;
      bordercode[7] = l3>>1;
      break;
    }  
  }
}

/************BILDE_SANDWICH_RANDCODES****************************************/
/*  Errechnet aus den Laengen l1,l2 und l3 die Randcodes der beteiligten
    Raender. Es wird vorausgesetzt, dass code1[1]==0 und code2[1]==0 bereits
    gesetzt sind fuer den Fall, dass die Nebenrandcodes die Laenge 2 haben. */
/*  "code3" wird zweimal hintereinander geschrieben, "i" zeigt auf den 
    ersten gueltigen Eintrag.                                               */

unsigned char bilde_sandwich_randcodes(KNOTENTYP l1,KNOTENTYP l2,KNOTENTYP l3,
     KNOTENTYP *code1,KNOTENTYP *codelen1,KNOTENTYP *code2,KNOTENTYP *codelen2,
     KNOTENTYP *code3,KNOTENTYP *codelen3,KNOTENTYP *i) {
  static unsigned char fall;
  static unsigned char dummy;
  code1[0] = (l1+l2-1)>>1;   /* Nebenrand 1 */
  code2[0] = (l2+l3-1)>>1;   /* Nebenrand 2 */
  *codelen1 = 2-((l1+l2)&1);
  *codelen2 = 2-((l2+l3)&1);
  *codelen3 = 6 - *codelen1 - *codelen2; 
  fall = 4 + *codelen2 - (*codelen1 << 1);
  bereite_sandwichcodes_vor(fall,l1,l3,code3,&dummy,i);
  return(fall);
}

/************BILDE_BRILLEN_RANDCODES*****************************************/
/*  Errechnet aus den Laengen l1,l2 und l3 die Randcodes der beteiligten
    Raender. Es wird vorausgesetzt, dass code1[1]==0 und code2[1]==0 bereits
    gesetzt sind fuer den Fall, dass die Nebenrandcodes die Laenge 2 haben. */
/*  "code3" wird zweimal hintereinander geschrieben, "i" zeigt auf den 
    ersten gueltigen Eintrag.                                               */

unsigned char bilde_brillen_randcodes(KNOTENTYP l1,KNOTENTYP l2,KNOTENTYP l3,
     KNOTENTYP *code1,KNOTENTYP *codelen1,KNOTENTYP *code2,KNOTENTYP *codelen2,
     KNOTENTYP *code3,KNOTENTYP *codelen3,KNOTENTYP *i) {
  static unsigned char fall;
  static unsigned char dummy;
  code1[0] = (l1-1)>>1;   /* Nebenrand 1 */
  code2[0] = (l2-1)>>1;   /* Nebenrand 2 */
  *codelen1 = 2-(l1&1);
  *codelen2 = 2-(l2&1);
  *codelen3 = 6 - *codelen1 - *codelen2; 
  fall = 11 - *codelen2 - (*codelen1 << 1) - ((l3&1)<<2);
  bereite_brillencodes_vor(fall,code1,code2,code3,&dummy,i,l3);
  return(fall);
}
 
/**************SORTIERE_PATCHES3*********************************************/
/*  Sortiert 3 Patches in aufsteigender Reihenfolge. "perm1" bekommt die
    Nummer des kleinsten Patches usw. "krit", "fl" und "g" sind die Arrays 
    mit den Patchinformationen.                                             */

void sortiere_patches3(KNOTENTYP *krit,EULERTYP *fl,EULERTYP *g,unsigned char 
     *perm1,unsigned char *perm2,unsigned char *perm3) {
  if (krit[0]<krit[1] || (krit[0]==krit[1] && (fl[0]<fl[1] || (fl[0]==fl[1] &&
      g[0]<=g[1])))) {*perm1 = 0;  *perm2 = 1;}
  else {*perm1 = 1;  *perm2 = 0;}
  if (krit[2]>krit[*perm2] || (krit[2]==krit[*perm2] && (fl[2]>fl[*perm2] || 
      (fl[2]==fl[*perm2] && g[2]>=g[*perm2])))) {*perm3 = 2;}
  else {
    *perm3 = *perm2;
    if (krit[2]>krit[*perm1] || (krit[2]==krit[*perm1] &&
        (fl[2]>fl[*perm1] || (fl[2]==fl[*perm1] && g[2]>=g[*perm1]))))
       {*perm2 = 2;}
    else {*perm2 = *perm1;  *perm1 = 2;}
  }
}

/***************BILDE_BORDERCODE3********************************************/
/*  Bildet aus 3 Randcodes einen Bordercode, indem es die Randcodes passend
    einsortiert. "perm1" bekommt die Stelle, an die der erste Randcode
    einsortiert wird, "perm2" und "perm3" entsprechend fuer die Randcodes
    2 und 3.                                                               */

void bilde_bordercode3(KNOTENTYP *randcode1,KNOTENTYP codelen1,
     KNOTENTYP *randcode2,KNOTENTYP codelen2,KNOTENTYP *randcode3,
     KNOTENTYP codelen3,KNOTENTYP *bordercode,unsigned char *perm1,unsigned 
     char *perm2,unsigned char *perm3) {
  static char c1,c2,c3;  /*Indizes des besten, zweitbesten, drittbesten Codes*/
  static KNOTENTYP *code[3];    /* Sortierung */
  static KNOTENTYP l[3];
  static signed char erg;

  /* Reihenfolge festlegen: */
  if (erg = vergleiche_codes(randcode1,codelen1,randcode2,codelen2)<0) 
       {c1 = 2;  c2 = 1;}   
  else {c1 = 1;  c2 = 2;}
  if (vergleiche_codes(randcode1,codelen1,randcode3,codelen3)<0) {
    if (c1==1) {c1 = 3;  c2 = 1;  c3 = 2;}
    else if (vergleiche_codes(randcode2,codelen2,randcode3,codelen3)<0)
            {c1 = 3;  c2 = 2;  c3 = 1;}
    else {c2 = 3;  c3 = 1;}   /* "c1" bleibt erhalten */
  }
  else {
    if (c1==2) {c3 = 3;}      /* "c1" und "c2" bleiben erhalten */
    else if (vergleiche_codes(randcode2,codelen2,randcode3,codelen3)<0)
            {c2 = 3;  c3 = 2;}    /* "c1" bleibt erhalten */
    else {c3 = 3;}                /* "c1" und "c2" bleiben erhalten */
  } 
  
  /* Bordercode bilden: */
  code[0] = (c1==1) ? randcode1 : ((c1==2) ? randcode2 : randcode3);
  code[1] = (c2==1) ? randcode1 : ((c2==2) ? randcode2 : randcode3);
  code[2] = (c3==1) ? randcode1 : ((c3==2) ? randcode2 : randcode3);
  l[0] = (c1==1) ? codelen1 : ((c1==2) ? codelen2 : codelen3);
  l[1] = (c2==1) ? codelen1 : ((c2==2) ? codelen2 : codelen3);
  l[2] = (c3==1) ? codelen1 : ((c3==2) ? codelen2 : codelen3);
  bordercode[0] = 3;   bordercode[1] = 5;
  bordercode[2] = 5 + l[0];
  bordercode[3] = bordercode[2] + l[1];
  bordercode[4] = 11;
  memcpy(&bordercode[5],code[0],sizeof(KNOTENTYP)*l[0]);
  memcpy(&bordercode[bordercode[2]],code[1],sizeof(KNOTENTYP)*l[1]);
  memcpy(&bordercode[bordercode[3]],code[2],sizeof(KNOTENTYP)*l[2]);
  *perm1 = (c1==1) ? 0 : (c2==1 ? 1 : 2);
  *perm2 = (c1==2) ? 0 : (c2==2 ? 1 : 2);
  *perm3 = (c1==3) ? 0 : (c2==3 ? 1 : 2);
}
 
/***************BILDE_BORDERCODE2********************************************/
/*  Bildet aus 2 Randcodes einen Bordercode, indem es die Randcodes passend
    einsortiert. Rueckgabewert True <=> Reihenfolge vertauscht              */

BOOL bilde_bordercode2(KNOTENTYP *randcode1,KNOTENTYP codelen1,KNOTENTYP per1,
     KNOTENTYP *randcode2,KNOTENTYP codelen2,KNOTENTYP per2,
     KNOTENTYP *bordercode,KNOTENTYP *pererg) {
  bordercode[0] = 2;   bordercode[1] = 4;
  if (vergleiche_codes(randcode1,codelen1,randcode2,codelen2)<0) {
    bordercode[2] = 4 + codelen2;
    bordercode[3] = bordercode[2] + codelen1;
    memcpy(&bordercode[4],randcode2,sizeof(KNOTENTYP)*codelen2);
    memcpy(&bordercode[bordercode[2]],randcode1,sizeof(KNOTENTYP)*codelen1);
    pererg[0] = per2;   pererg[1] = per1;
    return(True);
  }  
  else {
    bordercode[2] = 4 + codelen1;
    bordercode[3] = bordercode[2] + codelen2;
    memcpy(&bordercode[4],randcode1,sizeof(KNOTENTYP)*codelen1);
    memcpy(&bordercode[bordercode[2]],randcode2,sizeof(KNOTENTYP)*codelen2);
    pererg[0] = per1;   pererg[1] = per2;
    return(False);
  }  
}

/********************TOP_DOWN_GENERIERUNG************************************/
/*  Produziert den Top-Down-Generierungsstammbaum fuer Karten mit Geschlecht
    "g" und "n" Knoten.                                                     */
/*  Im Gegensatz zum Bottom-Up-Ansatz sollte die Funktion "konstruiere_
    patch_top_down" gegenueber der Funktion "konstruiere_patch" auch dann
    bevorzugt werden, wenn der Patch bereits einmal konstruiert worden ist und
    somit Tests entfallen. Denn die Top-Down-Funktion ist in dem Fall 
    schneller als die klassische Funktion, weil das Errechnen der neuen 
    Randcodes und das Sortieren derselben entfaellt. Deshalb wird innerhalb
    der vorliegenden Funktion immer die Funktion "konstruiere_patch_top_down"
    aufgerufen.                                                             */
/*  Das Aufspalten eines Prozesses wird immer im obersten Level vorgenommen.
    Denn dort gibt es bereits ausreichend Aufspaltungsmoeglichkeiten.       */
/*  Beim Recovering wird zielgerichtet der richtige Zweig angesteuert.      */

void top_down_generierung(KNOTENTYP g,KNOTENTYP n) {
  static KNOTENTYP l1,l2,l3;               /* Laengen der drei Pfadteile */
  static KNOTENTYP kp_[3];                 /* kritische Punkte */
  static KNOTENTYP kriti_[3],krit;         /* Index-Aufteilung von "krit" */
  static EULERTYP kriti;                   /* Index ueber "kpk" */
  static KNOTENTYP arraypos;               /* als Abkuerzung */
  static EULERTYP fl_[3],fl;               /* Aufteilung von "fl" */
  static EULERTYP g_[3];                   /* Aufteilung von "g" */
  static KNOTENTYP bkb_[3];                /* Bruchkantenanzahl (bereinigt) */
  static KNOTENTYP innere,i;       /* "innere" = restliche innere Knoten */
  static KNOTENTYP randcode[3][12];  /* Randcodes */
         /* Randcode 3 wird zweimal hintereinander geschrieben */
  static KNOTENTYP offset3;   /* randcode[2][offset3] ist erster Codeeintrag */
  static KNOTENTYP codelen[3];
  static unsigned char rand[3];   /* rand[i] gibt an, zu welchem Patch Rand "i"
                                     gehoert (rand[i]=1,2,3,  i=0,1,2) */
  static KNOTENTYP bordercode[3][11];
         /* Bordercodes fuer die Patches, die spaeter erzeugt werden, so dass
            ihre Position in der History nicht von Anfang an feststeht */
  static POSTYP hislen;
  static POSTYP hislen1,hislen2;   /* Laenge der History, nachdem Patch 1 bzw.
    2 generiert wurde. Gleichzeitig Anfangsposition fuer den naechsten Patch */
  static KNOTENTYP per[3];      /* Periodenlaengen in Randkanten fuer Patches
                                   mit einem Rand */
  static KNOTENTYP per2[3][2];  /* Periodenlaengen fuer Patches mit maximal 
                                   2 Raendern */ 
  static KNOTENTYP per3[3];     /* Periodenlaengen fuer einen Patch mit 
                                   3 Raendern */ 
  static EULERTYP n_[3],j;        /* innere Knoten in den Patches 1,2 und 3 */
  static EULERTYP anz3[3]; /* 3-valente Randknoten in den Patches 1, 2 und 3 */
  static BOOL weiter,weiter2;  /* "True" => Weiterschalten macht Sinn. Hierfuer
     gibt es zwei Anlaesse:  1. Alle beteiligten Patches wurden gefunden und
     konstruiert; 2. Der vorliegende Patch wurde gefunden, aber nicht anstands-
     los konstruiert, so dass gar nicht nach weiteren Patches gesucht wird,
     also auch nicht festgestellt werden kann, dass es keine passenden Patches
     gibt. */
  static KANTENARRAY map;
  static POSTYP ii,start;
  static KNOTENTYP connfl;
  static KANTE *k;
#ifndef NOTIMES
  static clock_t dummy_ct,buffertime;
#endif //NOTIMES
  static unsigned char fall,perm1,perm2,perm3;
  static char iso;    /* kennzeichnet isomorphe Raender (-1 = unbestimmt) */
  static BOOL dummy,vertauscht;     /* Randcodes im Bordercode vertauscht */
  static POSTYP erg1,erg2,erg3,dummypos;  /* Patchkonstruktionsergebnisse */
  static BOOL wh1,wh2;                /* True => die 1-2 oberen Patches sind
         seit der letzten Verklebung nicht wieder konstruiert worden, so dass
         sie bei Bedarf noch einmal konstruiert werden muessen. 
         Dabei koennen aber Tests entfallen.              */
  static POSTYP lev1,lev2,lev3;     /* fuer Level, in denen zuletzt eine
                                       Veraenderung stattgefunden hat */
  static POSTYP start2,start3;   /* Beginn des freien Speicherplatzes fuer
                                    die Konstruktion von Patch 2 und 3 */
  static KNOTENTYP connfl2,connfl3;  /* hoechste bisher vergebene Nummer
         fuer Flaeche vor Konstruktion von Patch 2 und 3 */
  static FLAECHENTYP f;
  static BOOL pc,pc2;      /* True => "patch_check_td" oder "class2" oder
                              "class3" hat Patch aussortiert */
  static BOOL patchcheck_sk;   /* denn "patchcheck" muss bei Bauchbinden
                                  voruebergehend abgeschaltet werden */
  static BOOL bb_gleich;   /* True => Bauchbindenpatches koennen gleich sein */

  fl = (EULERTYP)((n>>1)+2-(g<<1));   arraypos = ARRAYPOS_N(g,n);
  p9 = n;  p12 = g;      /* Parameter, die im dumpfile gespeichert werden */ 

  if (do_bauchbinde && (!recover || pfadtyp_rec==1) &&
     (bauchbindenkennung<3 || g>0 || n%4==0)) {     /* Bauchbindenpfade */
    /* Moeglichkeit 1:  2 Patches mit je 1 Rand */
    p1 = 1;  p5 = p6 = 0;  p8 = p11 = p15 = 0;
    if ((!recover || mgl_rec==1) && fl>1 && bruchkantentest(0,1,0,g) &&
        (small_face<6 || g>1)) {
      /* Bruchkantentest spart viele Schleifen - nicht unterschaetzen */
      /* letzte Bedingung:  Wenn small_face>=6 ist, dann hat jeder planare
         Patch mindestens 6 Bruchkanten. Also muss jeder Patch mit 0 
         Bruchkanten mindestens Geschlecht 1 haben. 2 Patches liegen vor, also
         g>=2. */ 
      p2 = 1;  p3 = 0;
      patchcheck_sk = patchcheck;
      bc_td[0][0][0] = 1;  bc_td[0][0][1] = 3;  bc_td[0][0][2] = 5;
      bc_td[0][0][3] = BB_KENNUNG;         
      vor1[1] = vor2[1] = False;  vor[1] = 0;   vater_nr[1] = 0; 
      per_td[0][0][0] = 2;
      history[0].prev1 = &history[1];           history[0].vorg = 1;
      for (l1 = recover ? l1_rec : (doppelkanten ? 2 : 4); l1<=(n&~2); l1+=2) {
        /* Wenn l1>>1 ungerade ist, dann bekommt jeder der beiden beteiligten
           Patches ebenfalls eine ungerade Anzahl innerer Knoten. Also sind in
           diesem Falle mindestens 2 innere Knoten zu vergeben, so dass l1<=n-2
           gelten muss, wenn n nicht durch 4 teilbar ist (denn sonst waere
           bei l1==n der Term l1>>1 ungerade und es blieben keine Knoten mehr
           uebrig, die als innere Knoten dienen koennten). Durch "~2" werden 
           die 2 benoetigten Knoten im Bedarfsfall fuer l1 ausgeblendet. */  
        p4 = l1;
        innere = n-l1;     /* restliche innere Knoten */
        bc_td[0][0][4] = l1>>1;   /* individueller Codeteil */ 
        anz3[0] = anz3[1] = l1>>1;
        for (g_[0] = recover ? g1_rec : g>>1;  g_[0]>=(small_face>=6); 
             g_[0]--) {      /* small_face>=6 => g_[0]>=1 */
          p10 = (KNOTENTYP)g_[0];
          g_[1] = g-g_[0];   /* g_[0]<=g_[1] gilt auch bei small_face>=6 */
          bkb_[0] = ANZ_BK_BEREINIGT(0,g_[0],1);
          bkb_[1] = ANZ_BK_BEREINIGT(0,g_[1],1);
          for (n_[0] = recover ? fln1_rec : (g_[0]==g_[1] ? 
               (innere>>1)-((innere&2) != (l1&2)) : innere-(l1>>1&1));  
               n_[0]>=0; n_[0]-=2) {   /* durch die obigen 
               Wertzuweisungen haben n_[0] und l1>>1 (=:anz3[0]) die
               gleiche Paritaet (beide ungerade oder beide gerade) */
            /* Patch 2 wird groesser sein als Patch 1, wenn auch nicht nach
               der klassischen Definition, in der die Flaechenzahl hoehere
               Prioritaet hat als das Geschlecht, sondern andersherum. Das
               ist aber egal, da spaeter die beiden Patches nochmal nach dem 
               klassischen Kriterium sortiert werden und dann erst nach dem
               dann kleineren Patch gesucht wird. */
            p7 = (KNOTENTYP)n_[0];
            n_[1] = innere-n_[0];
            fl_[0] = FLAECHEN(g_[0],1,n_[0],l1>>1);   fl_[1] = fl-fl_[0];
            if (fl_[0]>0 && fl_[1]>0 &&
                (pv<5 || (bk_moeglich[fl_[0]][bkb_[0]] &&
                          bk_moeglich[fl_[1]][bkb_[1]]))) {
              /* Flaechenzahl passt - kritische Punkte durchgehen */
              for (kriti = recover ? (EULERTYP)krit1_rec : kpk_anz[arraypos]-1;
                   kriti>=0;  kriti--) {    /* diese Schleife kann kurz sein */
                p13 = (KNOTENTYP)kriti;
                krit = kpk[arraypos][kriti];    /* kritische Punkte */
                for (kriti_[0] = recover ? krit2_rec : 0;
                     kriti_[0]<kp_anz[fl_[0]][bkb_[0]] && 
                     (kp_[0] = kp[fl_[0]][bkb_[0]][kriti_[0]])<=krit; 
                     /* wichtig: kp-Folge ist monoton steigend */
                     kriti_[0]++) {  /* auch diese Schleife kann kurz sein */
                  if (IS_KP_MOEGLICH(fl_[1],bkb_[1],kp_[1] = krit-kp_[0]) &&
                      (n_[0]!=n_[1] || g_[0]!=g_[1] || kp_[0]<=kp_[1])) {
                      /* 2.Bedingung => Patch 1 ist kleiner als Patch 2 */
                      /* Bedingungen nicht vertauschen, da "kp_[1]" erst in der
                         ersten Bedingung ermittelt wird */

              /* folgenden Text um 6 Stellen einruecken: */
              p14 = kriti_[0];
              if (kp_[0]<kp_[1] || (kp_[0]==kp_[1] && (fl_[0]<fl_[1] || 
                  (fl_[0]==fl_[1] && g_[0]<g_[1])))) {perm1 = 0;  perm2 = 1;}
              else {perm1 = 1;  perm2 = 0;}
              fl_td[0][0] = fl_[perm1];     g_td[0][0] = g_[perm1]; 
              krit_td[0][0] = kp_[perm1];   n_td[0][0] = n_[perm1];
              anz3_td[0][0] = anz3[perm1];  
              hislen = 2;   zweig[1] = 0L;
              count++;
              count = count%mod;
              bb_gleich = (g_[0]==g_[1] && n_[0]==n_[1] && kp_[0]==kp_[1]);
                          /* zugehoerige Patches koennen gleich sein */
              if (recover && bb_gleich && 
                  ((mod2_used && class2!=0) || 
                   (mod3_used && class3!=0) ||
                   (mod4_used && class4!=0) ||
                   (mod5_used && class5!=0) ||
                   (mod6_used && class6!=0))) {
                recover = False;  
                count = recovercount;    count2 = recovercount2;
                count3 = recovercount3;  count4 = recovercount4;
                count5 = recovercount5;  count6 = recovercount6;
              }
              /* Wenn classx!=0 (zusaetzlich zu den anderen Bedingungen), 
                 dann soll nicht mehr bis in die tieferen
                 Level vorgedrungen werden. Stattdessen soll gleich die
                 naechste Aufteilung in Angriff genommen werden. Dies geht
                 problemlos, da in den tieferen Leveln bei "bb_gleich"
                 weder "count" noch "countx" weitergeschaltet werden.
                 Allerdings muss der Recovermodus aufgehoben werden, da ja
                 sonst dessen Ende niemals erreicht wird.
                 Die Bedingung (modx_used && classx!=0) kann nur auftreten,
                 wenn old_modx benutzt wurde, denn wie waere der Algorithmus
                 vor dem Absturz sonst durch die folgende Abfrage gekommen? */ 
              if (!bb_gleich ||
                  ((!mod2_used || class2==0) &&
                   (!mod3_used || class3==0) &&
                   (!mod4_used || class4==0) &&
                   (!mod5_used || class5==0) &&
                   (!mod6_used || class6==0))) {
                 /* Wenn beide Patches gleich gross sind, so fuehrt "modx"
                    zu Verwirrungen, weil die Funktion "vergleiche_patches" 
                    uebergangen werden koennte. Deshalb wird "modx" nicht
                    beruecksichtigt und stattdessen alles gemacht, wenn
                    "classx==0" (fuer alle x), und gar nichts, 
                    wenn "classx>0". */
                if (bb_gleich) {patchcheck = False;} 
                else           {patchcheck = patchcheck_sk;}
                /* Wenn beide Patches gleich gross sind, so darf 
                   Patchcheck nicht angewendet werden, weil dabei die
                   Funktion "vergleiche_patches" uebergangen werden koennte
                   (uebrigens gilt ja beim Patchcheck g_[0]==0 und g_[1]==0).*/
                if (patchcheck) {
                  overflow[1] = False;
                  for (f=0; f<anz_face; f++)  {pc_flaechenzahl_sk[f] = 0;}
                }
                /* Parameter, die wichtig sind, falls in "suche_patch" das
                   dumpfile gespeichert wird */
                if (!recover) {gefunden1 = False;} 
                if ((recover || !mod_used || count==class) &&
                    suche_patch(1,&hislen,True,&dummy,False)) {
                  /* gefunden */
                  /* Im Recovermodus ist auch gleichzeitig dafuer gesorgt, dass
                     auch ohne Aufruf der Funktion "schalte_weiter_td" alle
                     Verzweigungen an der richtigen Stelle sind. */
                  /* Falls "patchcheck" einen Patch aussortiert, so braucht
                     dies nicht notiert zu werden, da wir uns in der 
                     aeussersten Schleife befinden. */
                  if (recover) {
                    if (hislen==recover_hislen) {   /* Recovern abschliessen */
                      /* An dieser Stelle ist klar:  das Recovering ist 
                         abgeschlossen, denn wir befinden uns im untersten
                         gespeicherten Level, und da kommt man nicht hin, wenn 
                         bis dorthin nicht alle Recover-Zweige exakt getroffen 
                         werden. Deshalb Flag loeschen und "count"-Wert 
                         wiederherstellen. */
                      recover = False;   
                      count = recovercount;    count2 = recovercount2;
                      count3 = recovercount3;  count4 = recovercount4;
                      count5 = recovercount5;  count6 = recovercount6;
                    }
                  }
                  else if (save_flag || save_flag2) {   /* zwischenspeichern */
                    /* dieses Zwischenspeichern ist besonders wichtig bei
                       Delaney-Aufrufen, wo kaum einmal Patches gefunden
                       werden, die zusammenpassen. 
                       "!recover" ist wichtig, falls der Re-
                       covervorgang laenger dauert als das 
                       Sicherungsintervall */
                    speichere_graphen_aus_outputliste_in_files(hislen,1,1,
                    0,l1,0,0,(KNOTENTYP)n_[0],0,n,(KNOTENTYP)g_[0],0,g,
                    (KNOTENTYP)kriti,kriti_[0],0);
                  }
                  do {
                    hislen1 = hislen;   /* Zwischenspeichern */
                    lev1 = hislen1-1;
                    nebenzweig[0] = 0L;
                    if (patchcheck) {starte_pc_history_td(1,hislen1-1);}
                    else {starte_history_td(1,hislen1-1);}
                    pc = False;   /* wichtig (siehe Schleifenende) */
                    do {
                      start = 0;  connfl = 0;
                      if (patchcheck) {lev1 = hislen;
                                       errechne_flaechenzahlen(1,hislen1-1);}
                         /* "lev1=hislen", da bei "patchcheck" von unten 
                            weitergeschaltet wird, und Flaechenzahlen in 
                            History
                            uebernehmen, da dies nicht automatisch geschieht */
                      if ((erg1 = konstruiere_patch_top_down(map,&start,1,
                           lev1,1,&connfl))==1 &&
                          (!recover || nebenzweig[0]==recovernebenzweig[0])) {
                          /* Patch 1 geht klar */
                          /* auch im Recovermodus und bei Patchcheck muss 
                             durchkonstruiert werden, weil davon die Werte 
                             "erg1", "lev1" und so weiter abhaengen, die den 
                             gesamten Vorgang beeinflussen */
    
                        /* Patch 2 suchen: */
                        /* zweig[hislen] enthaelt keine wichtige Information, 
                           da in diesem Level nicht weitergeschaltet wird. Alle
                           Variationen passieren vor dem Befehl "zweig[1]=0L" 
                           und sind deshalb auch schon in den Zaehlern l1,l2,
                           l3,fl_[0],g_[0] usw. beruecksichtigt. Darum braucht 
                           "zweig[hislen]" nicht hochgezaehlt zu werden. */
                        gefunden1 = True;
                        pc = False;   
                        start2 = start;   connfl2 = connfl;
                                        /* falls wiederholt konstruiert wird */
                        fl_td[0][hislen] = fl_[perm2];
                        g_td[0][hislen] = g_[perm2];
                        krit_td[0][hislen] = kp_[perm2];
                        n_td[0][hislen] = n_[perm2]; 
                        memcpy(bc_td[0][hislen],bc_td[0][0],
                               sizeof(KNOTENTYP)*5);
                        per_td[0][0][hislen] = 2;
                        anz3_td[0][hislen] = anz3[perm2];
                        history[hislen].prev1 = &history[hislen+1];       
                        history[hislen].vorg = 1;  
                        hislen++;
                        vor1[hislen] = vor2[hislen] = False;  vor[hislen] = 0;
                        vater_nr[hislen] = hislen-1;
                        hislen++;
                        wh1 = False;  /*noch wurde der Patch 1 nicht verklebt*/
                        weiter = False;    /* noch nichts Sinnvolles konstr. */
                        zweig[hislen1+1] = 0L;
                        if (patchcheck) {
                          overflow[hislen1+1] = False;
                          for (f=0; f<anz_face; f++) {pc_flaechenzahl_sk[f] = 
                                               (history[1].flaechenzahl)[f];}
                        }
                        if (!recover) {gefunden2 = False;} 
                        if (suche_patch(hislen1+1,&hislen,True,&pc,
                            !bb_gleich || !(mod2_used || mod3_used || mod4_used
                            || mod5_used || mod6_used))) {
                           /* "modx_used && bb_gleich" => "countx" soll nicht
                              abgefragt werden (siehe oben) */
    
    /* folgenden Teil um 28 Stellen einruecken: */ 
    do {
      lev2 = hislen-1;  
      nebenzweig[1] = 0L;
      if (patchcheck) {starte_pc_history_td(hislen1+1,hislen-1);}
      else {starte_history_td(hislen1+1,hislen-1);}
      do {
        start = start2;  connfl = connfl2;
        if (patchcheck) {lev2 = hislen;
                         errechne_flaechenzahlen(hislen1+1,hislen-1);} 
        if ((erg2 = konstruiere_patch_top_down(map,&start,hislen1+1,
                    lev2,hislen1+1,&connfl))==hislen1+1) {
          gefunden2 = True;
          weiter = True;    /* sinnvoller Patch 2 wurde konstruiert (dieses
            Flag muss insbesondere auch dann gesetzt werden, wenn das 
            Recovering
            noch nicht abgeschlossen ist. Deshalb erfolgt dessen Abfrage erst
            in der naechsten Zeile.)  Der Unterschied zwischen "weiter" und
            "gefunden2" ist, dass "gefunden2" beim Recovern nicht geloescht 
            wird, sondern einen alten Wert behaelt, und dass "gefunden2" nicht
            regelt,
            was passiert, wenn Patch 1 zwar gefunden wird, aber nicht regelge-
            recht (z.B. bezueglich der Flaechenzahlen) ist. */
          if (!recover || nebenzweig[1]==recovernebenzweig[1]) {
            if (!recover) {
              /* falls "recover==True": hier nicht hinein, da die Karte bereits
                 mitgezaehlt wurde (als letzte vor der Dumpfile-Speicherung) */
              if ((level2<hislen-hislen1 || class2==0) &&
                  (level3<hislen-hislen1 || class3==0) && 
                  (level4<hislen-hislen1 || class4==0) && 
                  (level5<hislen-hislen1 || class5==0) && 
                  (level6<hislen-hislen1 || class6==0) && 
                  /* falls Level zu weit unten => nur bei Class 0 verwerten */ 
                  (!facerestrict || flaechenzahlen3_ok(&history[1],
                   &history[hislen1+1],nil))) {
                /* falls wh1==True: Abfrage nach Flaechenzahlen auch ohne 
                   Kantengeruest von Patch 1 moeglich, da History noch die 
                   aktuellen Flaechenwerte enthaelt */
                if (wh1) {start = 0;   connfl = 0;
                          dummypos = konstruiere_patch_top_down(map,&start,1,
                          0,1,&connfl);} /* Patch 1 wieder konstruieren - 
                  keine Tests mehr notwendig und "erg1" bleibt erhalten */
                graphenzahl[ARRAYPOS_LN(g,n,1)]++;
                verknuepfe_bauchbindenpatches(gk_td[1][0],gk_td[hislen1+1][0],
                                              l1>>1);
                wh1 = True;   /* Patch 1 ist verklebt worden -> unbrauchbar, 
                                 falls noch ein Durchgang erfolgt */
                bauchbinden_minimalitaetstest(gk_td[1][0],True,n,g,
                            &history[1],&history[hislen1+1],1,True,hislen);
              }
              if (save_flag || save_flag2) 
                 {speichere_graphen_aus_outputliste_in_files(hislen,1,1,
                  0,l1,0,0,(KNOTENTYP)n_[0],0,n,(KNOTENTYP)g_[0],0,g,
                  (KNOTENTYP)kriti,kriti_[0],0);}
               /* zwischenspeichern, auch wenn der Minimalitaetstest oder der
                  Flaechentest nicht bestanden wurde, damit keine zu grossen
                  Luecken zwischen 2 Speicherzeitpunkten auftreten.
                  "!recover" ist wichtig, falls der Recovervorgang laenger 
                  dauert als das Sicherungsintervall. */  
  	    }
            else {recover = False;   
                  count = recovercount;    count2 = recovercount2;
                  count3 = recovercount3;  count4 = recovercount4;
                  count5 = recovercount5;  count6 = recovercount6;}
            /* An dieser Stelle ist klar:  das Recovering ist abgeschlossen,
               denn wir befinden uns im untersten Level, und da kommt man nicht
               hin, wenn nicht alle Recover-Zweige exakt getroffen werden. Des-
               halb Flag loeschen und "count"-Wert wiederherstellen, falls
               noch recover-Modus vorliegt. */
          }
        }
        nebenzweig[1]++; 
        if (nebenzweig[1]==ULONG_MAX) {zweig_error(-2);}
      } while ((weiter2 = !vergleiche_patches(&history[1],&history[hislen1+1]))
               && ((lev2 = patchcheck ? 
                  setze_pc_history_weiter_td(hislen1+1,hislen-1) : 
                  setze_history_weiter_td(hislen1+1,hislen-1,
                  MAX(erg2-1,hislen1+1),True))!=-1));
      if (patchcheck) {
        overflow[hislen1+1] = False;
        for (f=0; f<anz_face; f++) {pc_flaechenzahl_sk[f] = 
                                    (history[1].flaechenzahl)[f];}
      }
      nebenzweig[1] = 0L;   /* wichtig, falls waehrend des Weiterschaltens ein
                               dumpfile erzeugt wird */
    } while (weiter2 && 
             schalte_weiter_td(&hislen,hislen1+1,hislen1+1,&pc,
                               !bb_gleich || !(mod2_used || mod3_used ||
                               mod4_used || mod5_used || mod6_used)));
    /* Ende des um 28 Stellen eingerueckten Textes */
   
                        }   /* Patch 2 gefunden */  
                        hislen = hislen1;
                        /* wiederherstellen, 1. falls durch den Einfluss von
                           "vergleiche_patches" der Wert nicht korrekt 
                           wiederhergestellt wurde, 2. weil nach dem letzten 
                           Patch der Wert nicht korrekt wiederhergestellt 
                           wird */
                      }      /* if Patch 1 konstruiert */         
                      else {weiter = True;}   /* Patch 1 weiterschalten, denn 
                                              an Patch 2 hat's nicht gelegen */
                      nebenzweig[0]++;
                      if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
                    } while (((!bb_gleich && (mod2_used || mod3_used ||
                      mod4_used || mod5_used || mod6_used)) || pc || weiter || 
                              gefunden2) && 
                      ((lev1 = patchcheck ?
                      setze_pc_history_weiter_td(1,hislen-1) :
                      setze_history_weiter_td(1,hislen-1,MAX(erg1-1,1),True))
                      !=-1));  /* Wenn "modx" benutzt wird, muss die "count"-
                                  Numerierung in jedem Teil gleich sein. 
                                  Deshalb
                                  immer durchschalten. Macht aber nichts, denn
                                  "modx" wird ja nur fuer die Delaney-Faelle
                                  gebraucht, bei denen die beiden ersten 
                                  Patches
                                  nur aus Zweiecken bestehen und somit nicht
                                  weiterzuschalten sind. */
                    if (patchcheck) {
                      overflow[1] = False;
                      for (f=0; f<anz_face; f++)  {pc_flaechenzahl_sk[f] = 0;}
                    }
                    nebenzweig[0] = 0L;
                  } while (((!bb_gleich && (mod2_used || mod3_used ||
                    mod4_used || mod5_used || mod6_used)) || pc || weiter) && 
                           schalte_weiter_td(&hislen,1,1,&dummy,False));
                }   /* if suche_patch */
                /* Ende des um 6 Stellen eingerueckten Textes */
  
	            }    /* if */
  	          }    /* if */
		}    /* for */
  	      }    /* for */
            }     /* if passt n */
          }       /* for g_td[0] */
        }         /* for fl_td[0] */  
      }           /* for l1 */
      patchcheck = patchcheck_sk;
    }             /* if */

    /* Moeglichkeit 2:  1 Patch mit 2 Raendern */
    if (g>0 && (!recover || mgl_rec==2) &&
       (pv<5 || bk_moeglich[fl][bkb_[0] = ANZ_BK_BEREINIGT(0,g-1,2)])) {  
       /* sonst nicht moeglich */
      p2 = 2;  p3 = 0;  p7 = (KNOTENTYP)fl;  p10 = g-1;  p14 = 0;
      /* Gemeinsamer Codeanteil aller gesuchten Patches: */      
      bc_td[0][0][0] = 2;  bc_td[0][0][1] = 4;  bc_td[0][0][2] = 6;
      bc_td[0][0][3] = 8;  bc_td[0][0][4] = bc_td[0][0][6] = BB_KENNUNG;
      g_td[0][0] = g-1;   fl_td[0][0] = fl;
      vor1[1] = vor2[1] = False;  vor[1] = 0;   vater_nr[1] = 0; 
      per_td[0][0][0] = per_td[0][1][0] = 2;
      history[0].prev1 = &history[1];           history[0].vorg = 1;
      /* moegliche Pfadlaengen durchgehen: */
      for (l1 = recover ? l1_rec : (doppelkanten ? 2 : 4); l1<=n; l1+=2) {
          /* l1 = Pfadlaenge */
        p4 = l1;
        n_td[0][0] = n-l1;   anz3_td[0][0] = l1;
        bc_td[0][0][5] = bc_td[0][0][7] = l1>>1;    /* individueller Teil */
        for (kriti = (EULERTYP)(recover ? (EULERTYP)krit1_rec : 0);  
             kriti < kp_anz[fl][bkb_[0]];  kriti++) {
          p13 = (KNOTENTYP)kriti;
          zweig[1] = 0L;
          krit_td[0][0] = kp[fl][bkb_[0]][kriti];
          hislen = 2;  
          count++;
          count = count%mod;
          if ((recover || !mod_used || count==class) &&
              suche_patch(1,&hislen,True,&dummy,True)) {        
              /* Patch gefunden */
            do {
              lev1 = hislen-1;
              nebenzweig[0] = 0L;
              starte_history_td(1,hislen-1);
              do {
                start = 0;  connfl = 0; 
                if ((erg1 = konstruiere_patch_top_down(map,&start,1,
                     lev1,1,&connfl))==1 && 
                    (!recover || nebenzweig[0]==recovernebenzweig[0])) {
                  if (!recover && (level2<hislen || class2==0) &&
                     (level3<hislen || class3==0) && 
                     (level4<hislen || class4==0) && 
                     (level5<hislen || class5==0) && 
                     (level6<hislen || class6==0) && 
                     (!facerestrict || flaechenzahlen_ok(&history[1]))) { 
                    /* untere Flaechenzahlengrenzen werden NICHT innerhalb der 
                       Konstruktion geprueft */
                    graphenzahl[ARRAYPOS_LN(g,n,1)]++;
                    verknuepfe_bauchbindenpatches(gk_td[1][0],gk_td[1][1],
                                                  l1>>1);
                    bauchbinden_minimalitaetstest(gk_td[1][0],True,n,g,
                                                &history[1],nil,2,True,hislen);
                  }
                  if (!recover && (save_flag || save_flag2)) 
                     {speichere_graphen_aus_outputliste_in_files(hislen,
                      1,2,0,l1,0,0,(KNOTENTYP)fl,0,n,g-1,0,g,
                      (KNOTENTYP)kriti,0,0);}
                  if (recover) {recover = False;   
                             count = recovercount;    count2 = recovercount2;
                             count3 = recovercount3;  count4 = recovercount4;
                             count5 = recovercount5;  count6 = recovercount6;}
                }
                nebenzweig[0]++;
                if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
              } while ((lev1 = setze_history_weiter_td(1,hislen-1,
                       MAX(erg1-1,1),True))!=-1);
              nebenzweig[0] = 0L;
            } while (schalte_weiter_td(&hislen,1,1,&dummy,True));
          }
        }         
      }
    }    /* if g>0 */
    if (graphstat) {
#ifndef NOTIMES
      dummy_ct = times(&TMS);
      buffertime = TMS.tms_utime;
      sprintf(strpuf,"\nConstructed %d map%s with genus %d and"
                     " %d vertices along type-1 Petrie paths in"
                     " %.1f seconds, accepted %d.",
                     graphenzahl[ARRAYPOS_LN(g,n,1)],
                     graphenzahl[ARRAYPOS_LN(g,n,1)]==1 ? (char *)"" :
                     (char *)"s",g,n,
                     (double)(buffertime-savetime)/time_factor,
                     non_iso_graphenzahl[ARRAYPOS_LN(g,n,1)]);
      logfile_entry(strpuf,True,True,False);
      savetime = buffertime;
#else
      sprintf(strpuf,"\nConstructed %d map%s with genus %d and"
                     " %d vertices along type-1 Petrie paths,"
                     "accepted %d.",
                     graphenzahl[ARRAYPOS_LN(g,n,1)],
                     graphenzahl[ARRAYPOS_LN(g,n,1)]==1 ? (char *)"" :
                     (char *)"s",g,n,
                     non_iso_graphenzahl[ARRAYPOS_LN(g,n,1)]);
      logfile_entry(strpuf,True,True,False);
#endif //NOTIMES
    }
  }   /* if do_bauchbinde */

  if (do_sandwich && (!recover || pfadtyp_rec==2)) {       /* Sandwichpfade */
    p1 = 2;

    /* Fall a: "l2" ist ungerade */
    randcode[0][1] = randcode[1][1] = 0;   /* fuer Nebenraender, falls 2 BKs */
    vor1[1] = vor2[1] = False;   vor[1] = 0;
    history[0].prev1 = &history[1];   vater_nr[1] = 0;
    history[0].vorg = 1;    
    /* diese Daten bleiben waehrend des gesamten folgenden Vorgangs erhalten */

    /* moegliche Pfadlaengen durchgehen: */
    for (l1 = recover ? l1_rec : 1; 
      l1 <= (l1_sandwich || digon_path ? 1 : n>>1); l1++) {
      /* l1 = Pfadteil 1 (bei "l1_sandwich" und "digon_path" immer ==1) */
      p4 = l1;
      for (l3=recover ? l3_rec : (l1>1 || zweiecke ? l1 : 2); l1+l3<=n; l3++) {
        /* l1 <= l3 = Pfadteil 3  (insbesondere: l1>1 => l3>1) */
        p6 = l3;
        for (l2 = recover ? l2_rec : (l1>1 || zweiecke ? 1 : 3); 
            (l1_sandwich || digon_path) ? l2<=1 : l1+l2+l3<=n+1; l2+=2) {
          /* l2 ist ungerade und bei "l1_sandwich" und "digon_path" immer 1 */
          p5 = l2;
          innere = n - (l1+l2+l3-1);      /* restliche innere Knoten */
          fall = bilde_sandwich_randcodes(l1,l2,l3,randcode[0],&codelen[0],
                 randcode[1],&codelen[1],randcode[2],&codelen[2],&offset3);
          per[0]  = randlaenge(randcode[0],0,codelen[0]-1);
          per[1]  = randlaenge(randcode[1],0,codelen[1]-1);
          per[2]  = randlaenge(&randcode[2][offset3],0,
                               codelen[2]/(1+(l1==l3))-1);
          /* "per[]" wird bei allen Faellen gebraucht */

          /* Moeglichkeit 1:  3 Patches mit je 1 Rand */
          if (fl>2 && (!recover || mgl_rec==1) && 
              bruchkantentest(codelen[0],1,0,g) &&
              bruchkantentest(codelen[1],1,0,g) && 
              bruchkantentest(codelen[2],1,0,g) &&
              (small_face<6 || (g>2 && randcode[0][0]>0 && randcode[1][0]>0
               && randcode[2][offset3]>0))) {
            /* sonst nicht moeglich */
            /* letzte Bedingung: Falls small_face>=6 gilt, so muss jeder der
               drei Patches mindestens Geschlecht 1 haben (s. Bauchbinde).
               Deshalb insgesamt g>2 und keine Einzelflaechen moeglich (denn 
               die haben Geschlecht 0). */ 
            p2 = 1;  p3 = 0;
            bordercode[0][0] = bordercode[1][0] = bordercode[2][0] = 1;
            bordercode[0][1] = bordercode[1][1] = bordercode[2][1] = 3;
            bordercode[0][2] = 3 + codelen[0];
            bordercode[1][2] = 3 + codelen[1];
            bordercode[2][2] = 3 + codelen[2];
            memcpy(&bordercode[0][3],randcode[0],
                   sizeof(KNOTENTYP)*codelen[0]);
            memcpy(&bordercode[1][3],randcode[1],
                   sizeof(KNOTENTYP)*codelen[1]);
            memcpy(&bordercode[2][3],&randcode[2][offset3],
                   sizeof(KNOTENTYP)*codelen[2]);
            anz3[0] = anzahl_3_val_randknoten(bordercode[0]);
            anz3[1] = anzahl_3_val_randknoten(bordercode[1]);
            anz3[2] = anzahl_3_val_randknoten(bordercode[2]);
            if (innere >= (anz3[0]&1)+(anz3[1]&1)+(anz3[2]&1)) {
               /* denn fuer jede ungerade Anzahl 3-valenter Randknoten muss
                  die Anzahl der inneren Knoten auch ungerade sein =>
                  mindestens 1 innerer Knoten pro ungerader 3-val-Anzahl */ 
              for (g_[0] = recover ? g1_rec : (randcode[0][0]==0 ? 0 : 
                   g-2*(small_face>=6)); /* damit 2 Henkel fuer die beiden
                    anderen Patches uebrig bleiben */
                   g_[0]>=(small_face>=6); g_[0]--) { 
                p10 = (KNOTENTYP)g_[0];
                for (g_[1] = recover ? g2_rec : 
                     (l1==l3 ? MIN(g-g_[0]-(small_face>=6),g_[0]) : 
                     (/*randcode[1][0]==0 ? 0 : */g-g_[0]-(small_face>=6))); 
                     g_[1]>=(small_face>=6); g_[1]--) {
                  /* => Nebenpatch 1 wird groesser sein als Patch 2, falls
                        gleicher Bordercode, wenn auch nicht nach der 
                        klassischen Definition, in der die Flaechenzahl eine 
                        hoehere Prioritaet besitzt als das Geschlecht 
                        (aber egal - siehe Bauchbinde) */
                  /* randcode[1][0]==0 => l3==1 => l1==1 => randcode[0][0]==0 
                     => g_[0]==0 => g_[1]=0 wegen l1==l3 */ 
                  p11 = (KNOTENTYP)g_[1];
                  g_[2] = g-g_[0]-g_[1];   /* aus g_[0],g_[1] folgt: g_[2]>0,
                                              falls small_face>=6 */
                  bkb_[0] = ANZ_BK_BEREINIGT(codelen[0],g_[0],1);
                  bkb_[1] = ANZ_BK_BEREINIGT(codelen[1],g_[1],1);
                  bkb_[2] = ANZ_BK_BEREINIGT(codelen[2],g_[2],1);
                  for (n_[0] = recover ? fln1_rec : (randcode[0][0]==0 ? 0 :
                       innere-(anz3[2]&1) - ((innere-(anz3[2]&1)^anz3[0])&1));
                       /* wird nie negativ */
                       n_[0]>=0; n_[0]-=2) {     /* Paritaet passt */
                    /* die XOR-Verknuepfung ergibt 1 auf Bit 0, wenn die
                       Paritaeten der beteiligten Operanden ungleich ist.
                       In dem Fall muss also noch ein Knoten abgezogen 
                       werden. */
                    p7 = (KNOTENTYP)n_[0];
                    j = l1==l3 && g_[0]==g_[1] ? 
                        MIN(n_[0],innere-(anz3[2]&1)-n_[0]) : 
                        innere-(anz3[2]&1)-n_[0];
                    /* randcode[1][0]==0 => l3==1 => l1==1 => 
                       randcode[0][0]==0 => n_[0]==0 => n_[1]=0 wegen l1==l3
                       und g_[0]==g_[1] */
                    for (n_[1] = recover ? fln2_rec : j-((j^anz3[1])&1); 
                         n_[1]>=0; n_[1]-=2) {      /* Paritaet passt */
                      p8 = (KNOTENTYP)n_[1];
                      n_[2] = innere-n_[0]-n_[1];
                      if ((n_[2]^anz3[2])&1) {fprintf(stderr,
                          "Logischer Fehler 1 in top_down_generierung!\n");
                          exit(101);}
                      fl_[0] = FLAECHEN(g_[0],1,n_[0],anz3[0]);
                      fl_[1] = FLAECHEN(g_[1],1,n_[1],anz3[1]);
                      fl_[2] = fl-fl_[0]-fl_[1];
                      if (fl_[0]>0 && fl_[1]>0 && fl_[2]>0 &&
                         /* (randcode[0][0]>0 || fl_[0]==1) &&
                            (randcode[1][0]>0 || fl_[1]==1) &&
                            passt automatisch */
                         (randcode[2][offset3]>0 || (fl_[2]==1 && g_[2]==0)) &&
                         /* keine Kerbe => 1 Flaeche, Geschlecht 0 */
                         (pv<5 || (bk_moeglich[fl_[0]][bkb_[0]] &&
                                   bk_moeglich[fl_[1]][bkb_[1]] &&
			           bk_moeglich[fl_[2]][bkb_[2]]))) {

      /* Flaechenzahl passt - kritische Punkte durchgehen */
      /* den folgenden Teil um 18 Stellen einruecken: */
      for (kriti = recover ? (EULERTYP)krit1_rec : kpk_anz[arraypos]-1;  
           kriti>=0;  kriti--) {    /* diese Schleife kann kurz sein */
        p13 = (KNOTENTYP)kriti;
        krit = kpk[arraypos][kriti];    /* kritische Punkte */
        for (kriti_[0] = recover ? krit2_rec : 0;
             kriti_[0]<kp_anz[fl_[0]][bkb_[0]] && 
            (kp_[0] = kp[fl_[0]][bkb_[0]][kriti_[0]])<=krit; 
             kriti_[0]++) {  /* auch diese Schleife kann kurz sein */
          p14 = kriti_[0];
          for (kriti_[1] = recover ? krit3_rec : (l1==l3 && n_[0]==n_[1] &&
               g_[0]==g_[1] ? kriti_[0] : 0);  /* => Patch 2 groesser als 1 */
               kriti_[1]<kp_anz[fl_[1]][bkb_[1]] && 
               kp_[0]+(kp_[1] = kp[fl_[1]][bkb_[1]][kriti_[1]])<=krit; 
               kriti_[1]++) {  /* auch diese Schleife kann kurz sein */
            if (IS_KP_MOEGLICH(fl_[2],bkb_[2],kp_[2] = krit-kp_[0]-kp_[1])) {

    /* den folgenden Teil um 28 Stellen einruecken: */
    p15 = kriti_[1];
    zweig[1] = 0L;
    sortiere_patches3(kp_,fl_,g_,&perm1,&perm2,&perm3);
    hislen = 2;
    fl_td[0][0] = fl_[perm1];    g_td[0][0] = g_[perm1]; 
    krit_td[0][0] = kp_[perm1];  n_td[0][0] = n_[perm1];
    anz3_td[0][0] = anz3[perm1];  
    per_td[0][0][0] = per[perm1];
    memcpy(bc_td[0][0],bordercode[perm1],sizeof(KNOTENTYP)*(3+codelen[perm1]));
    count++;
    count = count%mod;
    if (patchcheck) {
      overflow[1] = False;
      for (f=0; f<anz_face; f++)  {pc_flaechenzahl_sk[f] = 0;}
    }
    if (!recover) {gefunden1 = False;} 
    if ((recover || !mod_used || count==class) &&
        suche_patch(1,&hislen,True,&dummy,False)) {     /* gefunden */
      if (recover) {
        if (hislen==recover_hislen)   /* Recovern abschliessen */ 
           {recover = False;  
            count = recovercount;    count2 = recovercount2;
            count3 = recovercount3;  count4 = recovercount4;
            count5 = recovercount5;  count6 = recovercount6;}
      }
      else if (save_flag || save_flag2) {          /* zwischenspeichern */
        speichere_graphen_aus_outputliste_in_files(hislen,
           2,1,0,l1,l2,l3,(KNOTENTYP)n_[0],(KNOTENTYP)n_[1],n,(KNOTENTYP)g_[0],
           (KNOTENTYP)g_[1],g,(KNOTENTYP)kriti,kriti_[0],kriti_[1]);
      }
      do {
        hislen1 = hislen;         /* Zwischenspeichern */
        /* "hislen1" kann sich von Durchlauf zu Durchlauf aendern, deshalb
           innerhalb der Schleife zwischenspeichern */
        lev1 = hislen1-1;
        nebenzweig[0] = 0L;
        if (patchcheck) {starte_pc_history_td(1,hislen1-1);}
        else {starte_history_td(1,hislen1-1);}
        pc = pc2 = False;
        do {
          start = 0;  connfl = 0;
          if (patchcheck) {lev1 = hislen; 
                           errechne_flaechenzahlen(1,hislen1-1);}
          if ((erg1 = konstruiere_patch_top_down(map,&start,1,
                      lev1,1,&connfl))==1 &&
             (!recover || nebenzweig[0]==recovernebenzweig[0])) {
                          /* Patch 1 geht klar */

            /* Daten fuer Patch 2: */
            gefunden1 = True;
            pc = False;
            start2 = start;   connfl2 = connfl;     
                              /* falls wiederholt konstruiert wird */
            fl_td[0][hislen] = fl_[perm2];  g_td[0][hislen] = g_[perm2];
            krit_td[0][hislen] = kp_[perm2];
            n_td[0][hislen] = n_[perm2];
            anz3_td[0][hislen] = anz3[perm2];  
            per_td[0][0][hislen] = per[perm2];
            history[hislen].prev1 = &history[hislen+1];
            history[hislen].vorg = 1;
            memcpy(bc_td[0][hislen],bordercode[perm2],
                   sizeof(KNOTENTYP)*(3+codelen[perm2]));
            hislen++;
            vor1[hislen] = vor2[hislen] = False;  vor[hislen] = 0;
            vater_nr[hislen] = hislen-1;
            hislen++;         
            wh1 = False;           /* Patch 1 wurde noch nicht verklebt */
            weiter = False;        /* noch nichts Sinnvolles konstr. */
            zweig[hislen1+1] = 0L;
            if (patchcheck) {
              overflow[hislen1+1] = False;
              for (f=0; f<anz_face; f++) {pc_flaechenzahl_sk[f] = 
                                          (history[1].flaechenzahl)[f];}
            }
            if (!recover) {gefunden2 = False;} 
            if (suche_patch(hislen1+1,&hislen,True,&pc,False)) {
              if (recover) {
                if (hislen==recover_hislen)   /* Recovern abschliessen */ 
                   {recover = False;  
                    count = recovercount;    count2 = recovercount2;
                    count3 = recovercount3;  count4 = recovercount4;
                    count5 = recovercount5;  count6 = recovercount6;}
              }
              else if (save_flag || save_flag2) {    /* zwischenspeichern */
                speichere_graphen_aus_outputliste_in_files(hislen,
                  2,1,0,l1,l2,l3,(KNOTENTYP)n_[0],(KNOTENTYP)n_[1],n,
                  (KNOTENTYP)g_[0],(KNOTENTYP)g_[1],g,(KNOTENTYP)kriti,
                  kriti_[0],kriti_[1]);
              }
              do {
                hislen2 = hislen;  
                lev2 = hislen2-1;
                nebenzweig[1] = 0L;
                if (patchcheck) {starte_pc_history_td(hislen1+1,hislen2-1);}
                else {starte_history_td(hislen1+1,hislen2-1);}
                do {
                  start = start2;   connfl = connfl2; 
                  if (patchcheck) {lev2 = hislen; 
                      errechne_flaechenzahlen(hislen1+1,hislen2-1);}
                  if ((erg2 = konstruiere_patch_top_down(map,&start,
                      hislen1+1,lev2,hislen1+1,&connfl))==hislen1+1 &&
                     (!recover || nebenzweig[1]==recovernebenzweig[1])) {
                     /* Daten fuer Patch 3: */
                    gefunden2 = True;
                    pc2 = False;
                    start3 = start;   connfl3 = connfl;  
                    fl_td[0][hislen] = fl_[perm3];
                    krit_td[0][hislen] = kp_[perm3];
                    g_td[0][hislen] = g_[perm3];
                    n_td[0][hislen] = n_[perm3];
                    anz3_td[0][hislen] = anz3[perm3];  
                    per_td[0][0][hislen] = per[perm3];
                    history[hislen].prev1 = &history[hislen+1];
                    history[hislen].vorg = 1;
                    memcpy(bc_td[0][hislen],bordercode[perm3],
                           sizeof(KNOTENTYP)*(3+codelen[perm3]));
                    hislen++;
                    vor1[hislen] = vor2[hislen] = False;  vor[hislen] = 0;
                    vater_nr[hislen] = hislen-1;
                    hislen++;
                    wh2 = False;   /* noch wurde Patch 2 nicht verklebt */
                    weiter2 = False;
                    zweig[hislen2+1] = 0L;
                    if (patchcheck) {
                      overflow[hislen2+1] = False;
                      for (f=0; f<anz_face; f++) {pc_flaechenzahl_sk[f] = 
                        (history[1].flaechenzahl)[f] +
                        (history[hislen1+1].flaechenzahl)[f];}
                    }
                    if (!recover) {gefunden3 = False;} 
                    if (suche_patch(hislen2+1,&hislen,True,&pc2,True)) {

  /* folgenden Text um 48 Stellen einruecken: */
  do {
    lev3 = hislen-1;  
    nebenzweig[2] = 0L;
    if (patchcheck) {starte_pc_history_td(hislen2+1,hislen-1);}
    else {starte_history_td(hislen2+1,hislen-1);}
    do {
      start = start3;   connfl = connfl3;
      if (patchcheck) {lev3 = hislen; 
                       errechne_flaechenzahlen(hislen2+1,hislen-1);}
      if ((erg3 = konstruiere_patch_top_down(map,&start,hislen2+1,
                  lev3,hislen2+1,&connfl))==hislen2+1) {
        gefunden3 = weiter = weiter2 = True;  
                    /* sinnvoller Patch 3 wurde konstruiert */
        if (!recover || nebenzweig[2]==recovernebenzweig[2]) {
          if (!recover) {
            if ((level2<hislen-hislen2 || class2==0) &&
                (level3<hislen-hislen2 || class3==0) &&
                (level4<hislen-hislen2 || class4==0) &&
                (level5<hislen-hislen2 || class5==0) &&
                (level6<hislen-hislen2 || class6==0) &&
                (!facerestrict || flaechenzahlen3_ok(&history[1],
                 &history[hislen1+1],&history[hislen2+1]))) {
              if (wh1) {   /* Patch 1 nochmal konstruieren */
                start = 0;   connfl = 0;
                dummypos = konstruiere_patch_top_down(map,&start,1,
                           0,1,&connfl);
              }
              if (wh2) {
                start = start2;   connfl = connfl2;  
                dummypos = konstruiere_patch_top_down(map,&start,
                           hislen1+1,0,hislen1+1,&connfl);
	      }
              graphenzahl[ARRAYPOS_LN(g,n,2)]++;
              k = verknuepfe_sandwichpatches(
                  gk_td[1+hislen1*(perm2==0)+hislen2*(perm3==0)][0],
                  gk_td[1+hislen1*(perm2==1)+hislen2*(perm3==1)][0],
                  gk_td[1+hislen1*(perm2==2)+hislen2*(perm3==2)][0],l1,l2,l3,
                  &randcode[2][offset3],offset3 ? 1+(fall>2) : 0,fall);
              wh1 = wh2 = True;    /* Patches wurden verklebt => unbrauchbar im
                                      Wiederholungsfalle */
              sandwich_minimalitaetstest(k->next,l1!=l3 || g_[0]!=g_[1] || 
                 fl_[0]!=fl_[1] || kp_[0]!=kp_[1],n,g,&history[1],
                 &history[hislen1+1],&history[hislen2+1],fall>2,1,True,hislen);
            }
            if (save_flag || save_flag2) 
               {speichere_graphen_aus_outputliste_in_files(hislen,
                2,1,0,l1,l2,l3,(KNOTENTYP)n_[0],(KNOTENTYP)n_[1],n,
                (KNOTENTYP)g_[0],(KNOTENTYP)g_[1],g,(KNOTENTYP)kriti,
                kriti_[0],kriti_[1]);}
          }
          else {recover = False;   
                count = recovercount;    count2 = recovercount2;
                count3 = recovercount3;  count4 = recovercount4;
                count5 = recovercount5;  count6 = recovercount6;}
        }
      }
      nebenzweig[2]++;
      if (nebenzweig[2]==ULONG_MAX) {zweig_error(-3);}
    } while ((lev3 = patchcheck ?
             setze_pc_history_weiter_td(hislen2+1,hislen-1) :
             setze_history_weiter_td(hislen2+1,hislen-1,
              MAX(erg3-1,hislen2+1),True))!=-1);
    if (patchcheck) {
      overflow[hislen2+1] = False;
      for (f=0; f<anz_face; f++) {pc_flaechenzahl_sk[f] = 
          (history[1].flaechenzahl)[f] +
          (history[hislen1+1].flaechenzahl)[f];}
    }
    nebenzweig[2] = 0L;
  } while (schalte_weiter_td(&hislen,hislen2+1,hislen2+1,&pc2,True));
  /* Ende des um 48 Stellen eingerueckten Textes */

                    }   /* if suche_patch 3 */
                    hislen = hislen2;
                  }    /* if Patch 2 konstruiert */ 
                  else {weiter2 = True;}   /* an Patch 3 scheitert's nicht */
                  nebenzweig[1]++;
                  if (nebenzweig[1]==ULONG_MAX) {zweig_error(-2);}
	        } while ((mod2_used || mod3_used || mod4_used || mod5_used ||
                          mod6_used || pc2 || weiter2 || gefunden3) && 
                  (lev2 = patchcheck ?
                  setze_pc_history_weiter_td(hislen1+1,hislen-1) :
                  setze_history_weiter_td(hislen1+1,
                  hislen-1,MAX(erg2-1,hislen1+1),True))!=-1);
                if (patchcheck) {
                  overflow[hislen1+1] = False;
                  for (f=0; f<anz_face; f++) {pc_flaechenzahl_sk[f] = 
                                     (history[1].flaechenzahl)[f];}
                }
                nebenzweig[1] = 0L;
              } while ((mod2_used || mod3_used || mod4_used || mod5_used || 
                        mod6_used || pc2 || weiter2 || gefunden3) && 
                schalte_weiter_td(&hislen,hislen1+1,hislen1+1,&pc,False));
            }     /* if suche_patch 2 */
            hislen = hislen1;
          }      /* if Patch 1 konstruiert */
          else {weiter = True;}   /* naechster Versuch, denn an Patch 2 und 3
                                     scheitert's (noch) nicht */
          nebenzweig[0]++;
          if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
        } while ((mod2_used || mod3_used || mod4_used || mod5_used || mod6_used
                  || pc || pc2 || weiter || gefunden2) &&
                 ((lev1 = patchcheck ? 
                 setze_pc_history_weiter_td(1,hislen-1) :
                 setze_history_weiter_td(1,hislen-1,MAX(erg1-1,1),True))!=-1));
        if (patchcheck) {
          overflow[1] = False;
          for (f=0; f<anz_face; f++)  {pc_flaechenzahl_sk[f] = 0;}
        }
        nebenzweig[0] = 0L;
      } while ((mod2_used || mod3_used || mod4_used || mod5_used || mod6_used 
                || pc || pc2 || weiter || gefunden2) &&
                schalte_weiter_td(&hislen,1,1,&dummy,False));
    }   /* if */
    /* Ende des um 28 Stellen eingerueckten Textes */
 
              }  /* if */
            }    /* for */
          }      /* for */
        }        /* for */        
        /* Ende des um 18 Stellen eingerueckten Textes */

                      }     /* if */
                    }       /* for n_[1] */
                  }         /* for n_[0] */  
                }           /* for g_[1] */
              }             /* for g_[0] */
            }             /* if innere */
          }               /* if fl>2 && ... */

          if (g>0 && fl>1) { 
            /* "per"-Werte bleiben bestehen */
            /* Moeglichkeit 2:  2 Patches, einer mit 2 Nebenraendern */
            /* Bei "l1_sandwich==True" oder "digon_path==True" besitzt ein 
               Nebenrand keine Kerbe, so dass es keinen Patch mit den 2 
               erforderlichen Nebenraendern geben kann. "pruefe_bordercode" 
               wird dies feststellen. */
            if ((!recover || mgl_rec==2) && 
                bruchkantentest(codelen[0]+codelen[1],2,0,g) && 
                bruchkantentest(codelen[2],1,0,g) &&
                (small_face<6 || (g>1 && randcode[2][offset3]>0))) {
               /* letzte Bedingung:  der Patch mit einem Rand (Patch 2) hat 
                  Geschlecht>=1 (und somit mindestens eine Kerbe)
                  und es wird ein Henkel zerschnitten => g>=2 */
              p2 = 2;  p3 = 0;  p8 = p11 = p15 = 0;
              vertauscht = bilde_bordercode2(randcode[0],codelen[0],per[0],
                           randcode[1],codelen[1],per[1],bordercode[0],
                           per2[0]);  /* Nebenpatch */
              if (pruefe_bordercode(bordercode[0])) {
                bordercode[2][0] = 1;  bordercode[2][1] = 3;
                bordercode[2][2] = 3+codelen[2];     /* Hauptpatch */
                memcpy(&bordercode[2][3],&randcode[2][offset3],
                       sizeof(KNOTENTYP)*codelen[2]);
                anz3[0] = anzahl_3_val_randknoten(bordercode[0]);
                anz3[2] = anzahl_3_val_randknoten(bordercode[2]);
                per2[2][0] = per[2];
                if (innere >= (anz3[0]&1)+(anz3[2]&1)) {
                  for (g_[0] = recover ? g1_rec : g-1-(small_face>=6); 
                       g_[0]>=0;  g_[0]--) {
                    p10 = (KNOTENTYP)g_[0];
                    g_[2] = g-1-g_[0];       /* >=1, falls small_face>=6 */
                    bkb_[0] = ANZ_BK_BEREINIGT(codelen[0]+codelen[1],g_[0],2);
                    bkb_[2] = ANZ_BK_BEREINIGT(codelen[2],g_[2],1);
                    for (n_[0] = recover ? fln1_rec : innere-(anz3[2]&1)-
                        ((innere-(anz3[2]&1)^anz3[0])&1); n_[0]>=0; n_[0]-=2) {
                      p7 = (KNOTENTYP)n_[0];
                      n_[2] = innere-n_[0];
                      if ((n_[2]^anz3[2])&1) {fprintf(stderr,
                          "Logischer Fehler 2 in top_down_generierung!\n");
                          exit(102);}
                      fl_[0] = FLAECHEN(g_[0],2,n_[0],anz3[0]);
                      fl_[2] = fl-fl_[0];
                      if (fl_[0]>0 && fl_[2]>0 &&
                         (randcode[2][offset3]>0 || (fl_[2]==1 && g_[2]==0)) &&
                         /* keine Kerbe => 1 Flaeche, Geschlecht 0 */
                         (pv<5 || (bk_moeglich[fl_[0]][bkb_[0]] &&
			           bk_moeglich[fl_[2]][bkb_[2]]))) {

      /* den folgenden Teil um 18 Stellen einruecken: */
      for (kriti = recover ? (EULERTYP)krit1_rec : kpk_anz[arraypos]-1;  
           kriti>=0;  kriti--) {    /* diese Schleife kann kurz sein */
        p13 = (KNOTENTYP)kriti;
        krit = kpk[arraypos][kriti];    /* kritische Punkte */
        for (kriti_[0] = recover ? krit2_rec : 0;
             kriti_[0]<kp_anz[fl_[0]][bkb_[0]] && 
             (kp_[0] = kp[fl_[0]][bkb_[0]][kriti_[0]])<=krit; kriti_[0]++) {
          if (IS_KP_MOEGLICH(fl_[2],bkb_[2],kp_[2] = krit-kp_[0])) {

    /* den folgenden Teil um 28 Stellen einruecken: */
    p14 = kriti_[0];
    zweig[1] = 0L;
    if (kp_[0]<kp_[2] || (kp_[0]==kp_[2] && (fl_[0]<fl_[2] || 
        (fl_[0]==fl_[2] && g_[0]<g_[2])))) 
         {perm1 = 0;  perm2 = 2;}
    else {perm1 = 2;  perm2 = 0;}
    hislen = 2;
    fl_td[0][0] = fl_[perm1];    g_td[0][0] = g_[perm1]; 
    krit_td[0][0] = kp_[perm1];  n_td[0][0] = n_[perm1];
    anz3_td[0][0] = anz3[perm1];  
    per_td[0][0][0] = per2[perm1][0];   per_td[0][1][0] = per2[perm1][1];
    memcpy(bc_td[0][0],bordercode[perm1],sizeof(KNOTENTYP)*
           bordercode[perm1][bordercode[perm1][0]+1]);
    count++;
    count = count%mod;
    if (!recover) {gefunden1 = False;} 
    if ((recover || !mod_used || count==class) &&
        suche_patch(1,&hislen,True,&dummy,False)) {
      if (recover) {
        if (hislen==recover_hislen)   /* Recovern abschliessen */ 
           {recover = False; 
            count = recovercount;    count2 = recovercount2;
            count3 = recovercount3;  count4 = recovercount4;
            count5 = recovercount5;  count6 = recovercount6;}
      }
      else if (save_flag || save_flag2) {          /* zwischenspeichern */
        speichere_graphen_aus_outputliste_in_files(hislen,2,2,0,l1,l2,l3,
           (KNOTENTYP)n_[0],0,n,(KNOTENTYP)g_[0],0,
           g,(KNOTENTYP)kriti,kriti_[0],0);
      }
      do {
        hislen1 = hislen;  /* Zwischenspeichern */
        lev1 = hislen1-1;
        nebenzweig[0] = 0L;
        starte_history_td(1,hislen1-1);
        do {
          start = 0;  connfl = 0;
          if ((erg1 = konstruiere_patch_top_down(map,&start,1,
                      lev1,1,&connfl))==1 &&
             (!recover || nebenzweig[0]==recovernebenzweig[0])) {

            /* Daten fuer Patch 2: */
            gefunden1 = True;
            start2 = start;   connfl2 = connfl;
            fl_td[0][hislen] = fl_[perm2];  g_td[0][hislen] = g_[perm2];
            krit_td[0][hislen] = kp_[perm2];
            n_td[0][hislen] = n_[perm2];
            anz3_td[0][hislen] = anz3[perm2];   
            per_td[0][0][hislen] = per2[perm2][0]; 
            per_td[0][1][hislen] = per2[perm2][1];
            history[hislen].prev1 = &history[hislen+1];
            history[hislen].vorg = 1;
            memcpy(bc_td[0][hislen],bordercode[perm2],
                  sizeof(KNOTENTYP)*bordercode[perm2][bordercode[perm2][0]+1]);
            hislen++;
            vor1[hislen] = vor2[hislen] = False;  vor[hislen] = 0;
            vater_nr[hislen] = hislen-1;
            hislen++;
            iso = -1;         /* falls Patch 1 die Nebenraender enthaelt */
            wh1 = False;
            weiter = False;        /* noch nichts Sinnvolles konstr. */
            zweig[hislen1+1] = 0L;
            if (!recover) {gefunden2 = False;} 
            if (suche_patch(hislen1+1,&hislen,True,&dummy,True)) {

  /* den folgenden Teil um 40 Stellen einruecken: */
  do {
    lev2 = hislen-1;  
    nebenzweig[1] = 0L;
    starte_history_td(hislen1+1,hislen-1);
    do {
      start = start2;  connfl = connfl2;
      if ((erg2 = konstruiere_patch_top_down(map,&start,hislen1+1,
                  lev2,hislen1+1,&connfl))==hislen1+1) {
        gefunden2 = True;
        weiter = True;    /* sinnvoller Patch 2 wurde konstruiert */
        if (!recover || nebenzweig[1]==recovernebenzweig[1]) {
          if (!recover && (level2<hislen-hislen1 || class2==0) &&
             (level3<hislen-hislen1 || class3==0) && 
             (level4<hislen-hislen1 || class4==0) && 
             (level5<hislen-hislen1 || class5==0) && 
             (level6<hislen-hislen1 || class6==0) && 
             (!facerestrict || flaechenzahlen3_ok(&history[1],
             &history[hislen1+1],nil))) {
            if (wh1) {start = 0;   connfl = 0;
                      dummypos = konstruiere_patch_top_down(map,&start,1,
                      0,1,&connfl);}
            graphenzahl[ARRAYPOS_LN(g,n,2)]++;
            if (iso==-1 || perm2==0) {iso = l1==l3 ? 
               (char)iso_raender(&history[1+hislen1*(perm2==0)],0,1) : 0;} 
              /* falls Nebenraender in Patch 1 => "iso" nur einmal berechnen */
            k = verknuepfe_sandwichpatches(
                gk_td[1+hislen1*(perm2==0)][vertauscht ? 1 : 0],
                gk_td[1+hislen1*(perm2==0)][vertauscht ? 0 : 1],
                gk_td[1+hislen1*(perm2==2)][0],l1,l2,l3,
                &randcode[2][offset3],offset3 ? 1+(fall>2) : 0,fall);
            wh1 = True;
            sandwich_minimalitaetstest(k->next,l1!=l3,n,g,&history[1],
                     &history[hislen1+1],nil,fall>2,21,True,hislen);
            /* Falls Randcodes von Patch 1 gleich, aber Raender nicht
               isomorph sind: noch ein Durchgang mit vertauschten
               Raendern (fall bleibt erhalten) */
            if (l1==l3 && iso==0) {
              start = 0;  connfl = 0;
              dummypos = konstruiere_patch_top_down(map,&start,1,0,1,&connfl);
              start = start2;  connfl = connfl2;
              dummypos = konstruiere_patch_top_down(map,&start,hislen1+1,
                                      0,hislen1+1,&connfl);
              graphenzahl[ARRAYPOS_LN(g,n,2)]++;
              k = verknuepfe_sandwichpatches(
                  gk_td[1+hislen1*(perm2==0)][vertauscht ? 0 : 1],
                  gk_td[1+hislen1*(perm2==0)][vertauscht ? 1 : 0],
                  gk_td[1+hislen1*(perm2==2)][0],l3,l2,l1,
                  &randcode[2][offset3],offset3 ? 1+(fall>2) : 0,fall);
              sandwich_minimalitaetstest(k->next,False,n,g,&history[1],
                       &history[hislen1+1],nil,fall>2,22,True,hislen);
            }
          }
          if (!recover && (save_flag || save_flag2)) 
             {speichere_graphen_aus_outputliste_in_files(hislen,2,2,0,l1,l2,l3,
              (KNOTENTYP)n_[0],0,n,(KNOTENTYP)g_[0],0,g,
              (KNOTENTYP)kriti,kriti_[0],0);}
          if (recover) {recover = False;  
              count = recovercount;    count2 = recovercount2;
              count3 = recovercount3;  count4 = recovercount4;
              count5 = recovercount5;  count6 = recovercount6;}
        }
      }
      nebenzweig[1]++;
      if (nebenzweig[1]==ULONG_MAX) {zweig_error(-2);}
    } while ((lev2 = setze_history_weiter_td(hislen1+1,hislen-1,
             MAX(erg2-1,hislen1+1),True))!=-1);
    nebenzweig[1] = 0L;
  } while (schalte_weiter_td(&hislen,hislen1+1,hislen1+1,&dummy,True));
  /* Ende des um 40 Stellen eingerueckten Textes */
 
            }   /* Patch 2 gefunden */  
            hislen = hislen1;
          }      /* if Patch 1 konstruiert */         
          else {weiter = True;}   /* Patch 1 weiterschalten, denn an
                                     Patch 2 hat's nicht gelegen */
          nebenzweig[0]++;
          if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
        } while ((mod2_used || mod3_used || mod4_used || mod5_used ||
                  mod6_used || weiter || gefunden2) 
           && ((lev1 = setze_history_weiter_td(1,
                hislen-1,MAX(erg1-1,1),True))!=-1));
        nebenzweig[0] = 0L;
      } while ((mod2_used || mod3_used || mod4_used || mod5_used || mod6_used
                || weiter || gefunden2) && 
               schalte_weiter_td(&hislen,1,1,&dummy,False));
    }   /* if suche_patch */
    /* Ende des um 28 Stellen eingerueckten Textes */
 
          }  /* if */
        }    /* for */
      }      /* for */
      /* Ende des um 18 Stellen eingerueckten Textes */

                      }     /* if */
                    }       /* for n_[0] */  
                  }         /* for g_[0] */
                }         /* if innere */
	      }           /* if pruefe_bordercode */
            }             /* if Bruchkantentest */

            /* Moeglichkeit 3.1:  2 Patches, einer mit HR und 1.NR */
            if ((!recover || mgl_rec==31) &&
                bruchkantentest(codelen[0]+codelen[2],2,0,g) && 
                bruchkantentest(codelen[1],1,0,g) &&
                (small_face<6 || (g>1 && randcode[1][0]>0))) {
              p2 = 31;  p3 = 0;  p8 = p11 = p15 = 0;
              vertauscht = bilde_bordercode2(randcode[0],codelen[0],per[0],
                           &randcode[2][offset3],codelen[2],per[2],
                           bordercode[0],per2[0]);
              if (pruefe_bordercode(bordercode[0])) {  
                bordercode[1][0] = 1;  bordercode[1][1] = 3;
                bordercode[1][2] = 3+codelen[1];
                memcpy(&bordercode[1][3],randcode[1],
                       sizeof(KNOTENTYP)*codelen[1]);
                anz3[0] = anzahl_3_val_randknoten(bordercode[0]);
                anz3[1] = anzahl_3_val_randknoten(bordercode[1]);
                per2[1][0] = per[1];
                if (innere >= (anz3[0]&1)+(anz3[1]&1)) {
                  for (g_[0] = recover ? g1_rec : g-1-(small_face>=6); 
                       g_[0]>=0;  g_[0]--) {
                    p10 = (KNOTENTYP)g_[0];
                    g_[1] = g-1-g_[0];       /* >=1, falls small_face>=6 */
                    bkb_[0] = ANZ_BK_BEREINIGT(codelen[0]+codelen[2],g_[0],2);
                    bkb_[1] = ANZ_BK_BEREINIGT(codelen[1],g_[1],1);
                    for (n_[0] = recover ? fln1_rec : innere-(anz3[1]&1)-
                        ((innere-(anz3[1]&1)^anz3[0])&1); n_[0]>=0; n_[0]-=2) {
                      p7 = (KNOTENTYP)n_[0];
                      n_[1] = innere-n_[0];
                      if ((n_[1]^anz3[1])&1) {fprintf(stderr,
                          "Logischer Fehler 3 in top_down_generierung!\n");
                          exit(103);}
                      fl_[0] = FLAECHEN(g_[0],2,n_[0],anz3[0]);
                      fl_[1] = fl-fl_[0];
                      if (fl_[0]>0 && fl_[1]>0 &&
                         (randcode[1][0]>0 || (fl_[1]==1 && g_[1]==0)) &&
                         /* keine Kerbe => 1 Flaeche, Geschlecht 0 */
                         (pv<5 || (bk_moeglich[fl_[0]][bkb_[0]] &&
			           bk_moeglich[fl_[1]][bkb_[1]]))) {

      /* den folgenden Teil um 18 Stellen einruecken: */
      for (kriti = recover ? (EULERTYP)krit1_rec : kpk_anz[arraypos]-1;  
           kriti>=0;  kriti--) {    /* diese Schleife kann kurz sein */
        p13 = (KNOTENTYP)kriti;
        krit = kpk[arraypos][kriti];    /* kritische Punkte */
        for (kriti_[0] = recover ? krit2_rec : 0;
             kriti_[0]<kp_anz[fl_[0]][bkb_[0]] && 
             (kp_[0] = kp[fl_[0]][bkb_[0]][kriti_[0]])<=krit; kriti_[0]++) {
          if (IS_KP_MOEGLICH(fl_[1],bkb_[1],kp_[1] = krit-kp_[0])) {

    /* den folgenden Teil um 28 Stellen einruecken: */
    p14 = kriti_[0];
    zweig[1] = 0L;
    if (kp_[0]<kp_[1] || (kp_[0]==kp_[1] && (fl_[0]<fl_[1] || 
        (fl_[0]==fl_[1] && g_[0]<g_[1])))) 
         {perm1 = 0;  perm2 = 1;}
    else {perm1 = 1;  perm2 = 0;}
    hislen = 2;
    fl_td[0][0] = fl_[perm1];    g_td[0][0] = g_[perm1]; 
    krit_td[0][0] = kp_[perm1];  n_td[0][0] = n_[perm1];
    anz3_td[0][0] = anz3[perm1];  
    per_td[0][0][0] = per2[perm1][0]; 
    per_td[0][1][0] = per2[perm1][1];
    memcpy(bc_td[0][0],bordercode[perm1],sizeof(KNOTENTYP)*
           bordercode[perm1][bordercode[perm1][0]+1]);
    count++;
    count = count%mod;
    if (!recover) {gefunden1 = False;} 
    if ((recover || !mod_used || count==class) &&
        suche_patch(1,&hislen,True,&dummy,False)) {
      if (recover) {
        if (hislen==recover_hislen)   /* Recovern abschliessen */ 
           {recover = False; 
            count = recovercount;    count2 = recovercount2;
            count3 = recovercount3;  count4 = recovercount4;
            count5 = recovercount5;  count6 = recovercount6;}
      }
      else if (save_flag || save_flag2) {          /* zwischenspeichern */
        speichere_graphen_aus_outputliste_in_files(hislen,2,31,0,l1,l2,
           l3,(KNOTENTYP)n_[0],0,n,(KNOTENTYP)g_[0],0,g,
           (KNOTENTYP)kriti,kriti_[0],0);
      }
      do {
        hislen1 = hislen;  /* Zwischenspeichern */
        lev1 = hislen1-1;
        nebenzweig[0] = 0L;
        starte_history_td(1,hislen1-1);
        do {
          start = 0;  connfl = 0;
          if ((erg1 = konstruiere_patch_top_down(map,&start,1,
                      lev1,1,&connfl))==1 &&
             (!recover || nebenzweig[0]==recovernebenzweig[0])) {

            /* Daten fuer Patch 2: */
            gefunden1 = True;
            start2 = start;    connfl2 = connfl;
            fl_td[0][hislen] = fl_[perm2];  g_td[0][hislen] = g_[perm2];
            krit_td[0][hislen] = kp_[perm2];
            n_td[0][hislen] = n_[perm2];
            anz3_td[0][hislen] = anz3[perm2];   
            per_td[0][0][hislen] = per2[perm2][0]; 
            per_td[0][1][hislen] = per2[perm2][1];
            history[hislen].prev1 = &history[hislen+1];
            history[hislen].vorg = 1;
            memcpy(bc_td[0][hislen],bordercode[perm2],
                  sizeof(KNOTENTYP)*bordercode[perm2][bordercode[perm2][0]+1]);
            hislen++;
            vor1[hislen] = vor2[hislen] = False;  vor[hislen] = 0;
            vater_nr[hislen] = hislen-1;
            hislen++;
            iso = -1;        /* falls Patch 1 zwei Raender enthaelt */
            wh1 = False;
            weiter = False;        /* noch nichts Sinnvolles konstr. */
            zweig[hislen1+1] = 0L;
            if (!recover) {gefunden2 = False;} 
            if (suche_patch(hislen1+1,&hislen,True,&dummy,True)) {

  /* den folgenden Teil um 38 Stellen einruecken: */
  do {
    lev2 = hislen-1;  
    nebenzweig[1] = 0L;
    starte_history_td(hislen1+1,hislen-1);
    do {
      start = start2;   connfl = connfl2;
      if ((erg2 = konstruiere_patch_top_down(map,&start,hislen1+1,
                  lev2,hislen1+1,&connfl))==hislen1+1) {
        gefunden2 = True;
        weiter = True;    /* sinnvoller Patch 2 wurde konstruiert */
        if (!recover || nebenzweig[1]==recovernebenzweig[1]) {
          if (!recover && (level2<hislen-hislen1 || class2==0) &&
              (level3<hislen-hislen1 || class3==0) && 
              (level4<hislen-hislen1 || class4==0) && 
              (level5<hislen-hislen1 || class5==0) && 
              (level6<hislen-hislen1 || class6==0) && 
              (!facerestrict || flaechenzahlen3_ok(&history[1],
              &history[hislen1+1],nil))) {
            if (wh1) {start = 0;   connfl = 0;
                      dummypos = konstruiere_patch_top_down(map,&start,1,
                      0,1,&connfl);}
            if (iso==-1 || perm2==0) {iso = (l1==1 && l2==l3) ? 
               (char)iso_raender(&history[1+hislen1*(perm2==0)],0,1) : 0;} 
              /* l1==1 && l2==l3 <=> NR1-Code und HR-Code gleich <=> evtl.
                 Vertauschung erforderlich. Falls Patch 1 die beiden Raender 
                 enthaelt => "iso" nur einmal berechnen */
            graphenzahl[ARRAYPOS_LN(g,n,2)]++;
            k = verknuepfe_sandwichpatches(
                gk_td[1+hislen1*(perm2==0)][vertauscht ? 1 : 0],
                gk_td[1+hislen1*(perm2==1)][0],
                gk_td[1+hislen1*(perm2==0)][vertauscht ? 0 : 1],l1,l2,l3,
                &randcode[2][offset3],offset3 ? 1+(fall>2) : 0,fall);
            wh1 = True;
            sandwich_minimalitaetstest(k->next,l1!=1 || l2!=l3,n,g,&history[1],
                    &history[hislen1+1],nil,fall>2,31,True,hislen);
            /* Falls Randcodes von Patch 1 gleich, aber Raender nicht
               isomorph sind: noch ein Durchgang mit vertauschten
               Raendern (fall bleibt erhalten) */
            if (l1==1 && l2==l3 && iso==0) {
              start = 0;  connfl = 0;
              dummypos = konstruiere_patch_top_down(map,&start,1,0,1,&connfl);
              start = start2;  connfl = connfl2;
              dummypos = konstruiere_patch_top_down(map,&start,hislen1+1,
                                      0,hislen1+1,&connfl);
              graphenzahl[ARRAYPOS_LN(g,n,2)]++;
              k = verknuepfe_sandwichpatches(
                  gk_td[1+hislen1*(perm2==0)][vertauscht ? 0 : 1],
                  gk_td[1+hislen1*(perm2==1)][0],
                  gk_td[1+hislen1*(perm2==0)][vertauscht ? 1 : 0],l1,l3,l2,
                  &randcode[2][offset3],offset3 ? 1+(fall>2) : 0,fall);
              sandwich_minimalitaetstest(k->next,False,n,g,&history[1],
                       &history[hislen1+1],nil,fall>2,31,True,hislen);
            }
          }
          if (!recover && (save_flag || save_flag2)) 
             {speichere_graphen_aus_outputliste_in_files(hislen,2,31,0,l1,l2,
              l3,(KNOTENTYP)n_[0],0,n,(KNOTENTYP)g_[0],0,g,
              (KNOTENTYP)kriti,kriti_[0],0);}
          if (recover) {recover = False;   
              count = recovercount;    count2 = recovercount2;
              count3 = recovercount3;  count4 = recovercount4;
              count5 = recovercount5;  count6 = recovercount6;}
        }
      }
      nebenzweig[1]++;
      if (nebenzweig[1]==ULONG_MAX) {zweig_error(-2);}
    } while ((lev2 = setze_history_weiter_td(hislen1+1,hislen-1,
             MAX(erg2-1,hislen1+1),True))!=-1);
    nebenzweig[1] = 0L;
  } while (schalte_weiter_td(&hislen,hislen1+1,hislen1+1,&dummy,True));
  /* Ende des um 38 Stellen eingerueckten Textes */
 
            }   /* Patch 2 gefunden */  
            hislen = hislen1;
          }      /* if Patch 1 konstruiert */         
          else {weiter = True;}   /* Patch 1 weiterschalten, denn an
                                     Patch 2 hat's nicht gelegen */
          nebenzweig[0]++;
          if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
        } while ((mod2_used || mod3_used || mod4_used || mod5_used || mod6_used
                 || weiter || gefunden2)
          && ((lev1 = setze_history_weiter_td(1,
              hislen-1,MAX(erg1-1,1),True))!=-1));
        nebenzweig[0] = 0L;
      } while ((mod2_used || mod3_used || mod4_used || mod5_used || mod6_used
               || weiter || gefunden2) && 
               schalte_weiter_td(&hislen,1,1,&dummy,False));
    }   /* if suche_patch */
    /* Ende des um 28 Stellen eingerueckten Textes */
 
          }  /* if */
        }    /* for */
      }      /* for */
      /* Ende des um 18 Stellen eingerueckten Textes */

                      }     /* if */
                    }       /* for n_[0] */  
                  }         /* for g_[0] */
                }           /* if innere */
              }           /* if pruefe_bordercode */
            }             /* if Bruchkantentest */

            /* Moeglichkeit 3.2:  2 Patches, einer mit HR und 2.NR */
            if (l1!=l3 &&         /* sonst Dopplung */
               (!recover || mgl_rec==32) &&
                bruchkantentest(codelen[1]+codelen[2],2,0,g) && 
                bruchkantentest(codelen[0],1,0,g) &&
                (small_face<6 || (g>1 && randcode[0][0]>0))) {
              p2 = 32;  p3 = 0;  p8 = p11 = p15 = 0;
              vertauscht = bilde_bordercode2(randcode[1],codelen[1],per[1],
                           &randcode[2][offset3],codelen[2],per[2],
                           bordercode[0],per2[0]);
              if (pruefe_bordercode(bordercode[0])) {  
                 /* jeder Rand mit Kerbe */
                bordercode[1][0] = 1;  bordercode[1][1] = 3;
                bordercode[1][2] = 3+codelen[0];
                memcpy(&bordercode[1][3],randcode[0],
                       sizeof(KNOTENTYP)*codelen[0]);
                anz3[0] = anzahl_3_val_randknoten(bordercode[0]);
                anz3[1] = anzahl_3_val_randknoten(bordercode[1]);
                per2[1][0] = per[0];
                if (innere >= (anz3[0]&1)+(anz3[1]&1)) {
                  for (g_[0] = recover ? g1_rec : g-1-(small_face>=6); 
                       g_[0]>=0;  g_[0]--) {
                    p10 = (KNOTENTYP)g_[0];
                    g_[1] = g-1-g_[0];       /* >=1, falls small_face>=6 */
                    bkb_[0] = ANZ_BK_BEREINIGT(codelen[1]+codelen[2],g_[0],2);
                    bkb_[1] = ANZ_BK_BEREINIGT(codelen[0],g_[1],1);
                    for (n_[0] = recover ? fln1_rec : innere-(anz3[1]&1)-
                        ((innere-(anz3[1]&1)^anz3[0])&1); n_[0]>=0; n_[0]-=2) {
                      p7 = (KNOTENTYP)n_[0];
                      n_[1] = innere-n_[0];
                      if ((n_[1]^anz3[1])&1) {fprintf(stderr,
                          "Logischer Fehler 4 in top_down_generierung!\n");
                          exit(104);}
                      fl_[0] = FLAECHEN(g_[0],2,n_[0],anz3[0]);
                      fl_[1] = fl-fl_[0];
                      if (fl_[0]>0 && fl_[1]>0 &&
                         (randcode[0][0]>0 || (fl_[1]==1 && g_[1]==0)) &&
                         (pv<5 || (bk_moeglich[fl_[0]][bkb_[0]] &&
			           bk_moeglich[fl_[1]][bkb_[1]]))) {

      /* den folgenden Teil um 18 Stellen einruecken: */
      for (kriti = recover ? (EULERTYP)krit1_rec : kpk_anz[arraypos]-1;  
           kriti>=0;  kriti--) {    /* diese Schleife kann kurz sein */
        p13 = (KNOTENTYP)kriti;
        krit = kpk[arraypos][kriti];    /* kritische Punkte */
        for (kriti_[0] = recover ? krit2_rec : 0;
             kriti_[0]<kp_anz[fl_[0]][bkb_[0]] && 
             (kp_[0] = kp[fl_[0]][bkb_[0]][kriti_[0]])<=krit; kriti_[0]++) {
          if (IS_KP_MOEGLICH(fl_[1],bkb_[1],kp_[1] = krit-kp_[0])) {

    /* den folgenden Teil um 28 Stellen einruecken: */
    p14 = kriti_[0];
    zweig[1] = 0L;
    if (kp_[0]<kp_[1] || (kp_[0]==kp_[1] && (fl_[0]<fl_[1] || 
        (fl_[0]==fl_[1] && g_[0]<g_[1])))) 
         {perm1 = 0;  perm2 = 1;}
    else {perm1 = 1;  perm2 = 0;}
    hislen = 2;
    fl_td[0][0] = fl_[perm1];    g_td[0][0] = g_[perm1]; 
    krit_td[0][0] = kp_[perm1];  n_td[0][0] = n_[perm1];
    anz3_td[0][0] = anz3[perm1];  
    per_td[0][0][0] = per2[perm1][0]; 
    per_td[0][1][0] = per2[perm1][1];
    memcpy(bc_td[0][0],bordercode[perm1],sizeof(KNOTENTYP)*
           bordercode[perm1][bordercode[perm1][0]+1]);
    count++;
    count = count%mod;
    if (!recover) {gefunden1 = False;} 
    if ((recover || !mod_used || count==class) &&
        suche_patch(1,&hislen,True,&dummy,False)) {
      if (recover) {
        if (hislen==recover_hislen)   /* Recovern abschliessen */ 
           {recover = False;  
            count = recovercount;    count2 = recovercount2;
            count3 = recovercount3;  count4 = recovercount4;
            count5 = recovercount5;  count6 = recovercount6;}
      }
      else if (save_flag || save_flag2) {          /* zwischenspeichern */
        speichere_graphen_aus_outputliste_in_files(hislen,2,32,0,l1,l2,
          l3,(KNOTENTYP)n_[0],0,n,(KNOTENTYP)g_[0],0,g,
          (KNOTENTYP)kriti,kriti_[0],0);
      }
      do {
        hislen1 = hislen;  /* Zwischenspeichern */
        lev1 = hislen1-1;
        nebenzweig[0] = 0L;
        starte_history_td(1,hislen1-1);
        do {
          start = 0;  connfl = 0;
          if ((erg1 = konstruiere_patch_top_down(map,&start,1,
                      lev1,1,&connfl))==1 &&
             (!recover || nebenzweig[0]==recovernebenzweig[0])) {

            /* Daten fuer Patch 2: */
            gefunden1 = True;
            start2 = start;   connfl2 = connfl;
            fl_td[0][hislen] = fl_[perm2];  g_td[0][hislen] = g_[perm2];
            krit_td[0][hislen] = kp_[perm2];
            n_td[0][hislen] = n_[perm2];
            anz3_td[0][hislen] = anz3[perm2];   
            per_td[0][0][hislen] = per2[perm2][0]; 
            per_td[0][1][hislen] = per2[perm2][1];
            history[hislen].prev1 = &history[hislen+1];
            history[hislen].vorg = 1;
            memcpy(bc_td[0][hislen],bordercode[perm2],
                  sizeof(KNOTENTYP)*bordercode[perm2][bordercode[perm2][0]+1]);
            hislen++;
            vor1[hislen] = vor2[hislen] = False;  vor[hislen] = 0;
            vater_nr[hislen] = hislen-1;
            hislen++;
            iso = -1;         /* falls Patch 1 zwei Raender enthaelt */
            wh1 = False;
            weiter = False;        /* noch nichts Sinnvolles konstr. */
            zweig[hislen1+1] = 0L;
            if (!recover) {gefunden2 = False;} 
            if (suche_patch(hislen1+1,&hislen,True,&dummy,True)) {

  /* den folgenden Teil um 40 Stellen einruecken: */
  do {
    lev2 = hislen-1;  
    nebenzweig[1] = 0L;
    starte_history_td(hislen1+1,hislen-1);
    do {
      start = start2;   connfl = connfl2;
      if ((erg2 = konstruiere_patch_top_down(map,&start,hislen1+1,
                  lev2,hislen1+1,&connfl))==hislen1+1) {
        gefunden2 = True;
        weiter = True;    /* sinnvoller Patch 2 wurde konstruiert */
        if (!recover || nebenzweig[1]==recovernebenzweig[1]) {
          if (!recover && (level2<hislen-hislen1 || class2==0) && 
             (level3<hislen-hislen1 || class3==0) &&
             (level4<hislen-hislen1 || class4==0) && 
             (level5<hislen-hislen1 || class5==0) &&
             (level6<hislen-hislen1 || class6==0) && 
             (!facerestrict || flaechenzahlen3_ok(&history[1],
              &history[hislen1+1],nil))) {
            if (wh1) {start = 0;   connfl = 0;
                      dummypos = konstruiere_patch_top_down(map,&start,1,
                      0,1,&connfl);}
            if (iso==-1 || perm2==0) {iso = (l1==1 && l2==1 && (l3&1)==1) ? 
               (char)iso_raender(&history[1+hislen1*(perm2==0)],0,1) : 0;} 
              /* l1==1,l2==1 und l3 ungerade <=> NR2-Code und HR-Code gleich 
                 <=> evtl. Vertauschung erforderlich. 
                 Falls Patch 1 die beiden Raender enthaelt => "iso" nur einmal
                 berechnen */
            graphenzahl[ARRAYPOS_LN(g,n,2)]++;
            k = verknuepfe_sandwichpatches(
                gk_td[1+hislen1*(perm2==1)][0],
                gk_td[1+hislen1*(perm2==0)][vertauscht ? 1 : 0],
                gk_td[1+hislen1*(perm2==0)][vertauscht ? 0 : 1],
                l1,l2,l3,&randcode[2][offset3],offset3 ? 1+(fall>2) : 0,
                fall);
            wh1 = True;
            sandwich_minimalitaetstest(k->next,l1!=1 || l2!=1 || (l3&1)==0,n,g,
                    &history[1],&history[hislen1+1],nil,fall>2,32,True,hislen);
            /* Falls Randcodes von Patch 1 gleich, aber Raender nicht
               isomorph sind: noch ein Durchgang mit vertauschten
               Raendern (fall bleibt erhalten) */
            if (l1==1 && l2==1 && (l3&1)==1 && iso==0) {
              start = 0;  connfl = 0;
              dummypos = konstruiere_patch_top_down(map,&start,1,0,1,&connfl);
              start = start2;  connfl = connfl2;
              dummypos = konstruiere_patch_top_down(map,&start,hislen1+1,
                                                    0,hislen1+1,&connfl);
              graphenzahl[ARRAYPOS_LN(g,n,2)]++;
              k = verknuepfe_sandwichpatches(
                  gk_td[1+hislen1*(perm2==1)][0],
                  gk_td[1+hislen1*(perm2==0)][vertauscht ? 0 : 1],
                  gk_td[1+hislen1*(perm2==0)][vertauscht ? 1 : 0],
                  l2,l1,l3,&randcode[2][offset3],offset3 ? 1+(fall>2) : 0,
                  fall);
              sandwich_minimalitaetstest(k->next,False,n,g,&history[1],
                              &history[hislen1+1],nil,fall>2,32,True,hislen);
            }
          }
          if (!recover && (save_flag || save_flag2)) 
             {speichere_graphen_aus_outputliste_in_files(hislen,2,32,0,l1,l2,
              l3,(KNOTENTYP)n_[0],0,n,(KNOTENTYP)g_[0],0,g,
              (KNOTENTYP)kriti,kriti_[0],0);}
          if (recover) {recover = False;  
              count = recovercount;    count2 = recovercount2;
              count3 = recovercount3;  count4 = recovercount4;
              count5 = recovercount5;  count6 = recovercount6;}
        }
      }
      nebenzweig[1]++;
      if (nebenzweig[1]==ULONG_MAX) {zweig_error(-2);}
    } while ((lev2 = setze_history_weiter_td(hislen1+1,hislen-1,
             MAX(erg2-1,hislen1+1),True))!=-1);
    nebenzweig[1] = 0L;
  } while (schalte_weiter_td(&hislen,hislen1+1,hislen1+1,&dummy,True));
  /* Ende des um 40 Stellen eingerueckten Textes */
 
            }   /* Patch 2 gefunden */  
            hislen = hislen1;
          }      /* if Patch 1 konstruiert */         
          else {weiter = True;}   /* Patch 1 weiterschalten, denn an
                                     Patch 2 hat's nicht gelegen */
          nebenzweig[0]++;
          if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
        } while ((mod2_used || mod3_used || mod4_used || mod5_used || mod6_used
                 || weiter || gefunden2)
          && ((lev1 = setze_history_weiter_td(1,
               hislen-1,MAX(erg1-1,1),True))!=-1));
        nebenzweig[0] = 0L;
      } while ((mod2_used || mod3_used || mod4_used || mod5_used || mod6_used
               || weiter || gefunden2) && 
               schalte_weiter_td(&hislen,1,1,&dummy,False));
    }   /* if suche_patch */
    /* Ende des um 28 Stellen eingerueckten Textes */

          }  /* if */
        }    /* for */
      }      /* for */
      /* Ende des um 18 Stellen eingerueckten Textes */

                      }     /* if */
                    }       /* for n_[0] */  
                  }         /* for g_[0] */
                }         /* if innere */
              }           /* if pruefe_bordercode */
            }             /* if l1!=l3 */
          }               /* if g>0 && fl>1 */

          if (g>1 && (!recover || mgl_rec==4) &&     /* sonst nicht moeglich */
             (pv<5 || bk_moeglich[fl][bkb_[0] = ANZ_BK_BEREINIGT(6,g-2,3)])) {
            /* Moeglichkeit 4:  1 Patch mit 3 Raendern */
            p2 = 4;  p3 = 0;  p8 = p11 = p14 = p15 = 0;  p10 = g-2;
            p7 = (KNOTENTYP)fl;  
            bilde_bordercode3(randcode[0],codelen[0],randcode[1],codelen[1],
                              &randcode[2][offset3],codelen[2],bc_td[0][0],
                              &perm1,&perm2,&perm3);
            if (pruefe_bordercode(bc_td[0][0])) {   /* jeder Rand mit Kerbe */
              fl_td[0][0] = fl;   g_td[0][0] = g-2;   
              anz3_td[0][0] = anzahl_3_val_randknoten(bc_td[0][0]);
              n_td[0][0] = innere;    /* passt immer */
              if (innere != INNERE_KNOTEN(g-2,fl,3,anz3_td[0][0]))
	 	 {fprintf(stderr,"Logischer Fehler 9 in " 
                                 "top_down_generierung!\n");  exit(105);} 
              for (kriti = recover ? (EULERTYP)krit1_rec : kpk_anz[arraypos]-1;
                   kriti>=0;  kriti--) {    /* diese Schleife kann kurz sein */
                p13 = (KNOTENTYP)kriti;
                krit = kpk[arraypos][kriti];    /* kritische Punkte */
                if (IS_KP_MOEGLICH(fl,bkb_[0],krit)) {
                  krit_td[0][0] = krit;
                  zweig[1] = 0L;
                  per_td[0][perm1][0] = per[0];
                  per_td[0][perm2][0] = per[1]; 
                  per_td[0][perm3][0] = per[2];
                  hislen = 2;
                  count++;
                  count = count%mod;
                  if ((recover || !mod_used || count==class) &&
                      suche_patch(1,&hislen,True,&dummy,True)) {
                    do {
                      lev1 = hislen-1;
                      nebenzweig[0] = 0L;
                      starte_history_td(1,hislen-1);
                      do {
                        start = 0;  connfl = 0; 
                        if ((erg1 = konstruiere_patch_top_down(map,&start,1,
                             lev1,1,&connfl))==1 && 
                           (!recover || nebenzweig[0]==recovernebenzweig[0])) {
                          if (!recover && (level2<hislen || class2==0) &&
                              (level3<hislen || class3==0) && 
                              (level4<hislen || class4==0) && 
                              (level5<hislen || class5==0) && 
                              (level6<hislen || class6==0) && 
                              (!facerestrict || 
                              flaechenzahlen_ok(&history[1]))) {
                            /* Wichtig: Von den folgenden 3 Konstruktionsmoeg-
                               lichkeiten werden maximal 2 durchgefuehrt 
                               (l1==l3 und Randcode 1 == Randcode 3 ist nicht 
                               gleichzeitig moeglich), sonst waere Ueberhang im
                               "outputbuffer" zu klein */
                            graphenzahl[ARRAYPOS_LN(g,n,2)]++;
                            k = verknuepfe_sandwichpatches(gk_td[1][perm1],
                                gk_td[1][perm2],gk_td[1][perm3],l1,l2,l3,
                                &randcode[2][offset3],offset3 ? 1+(fall>2) : 0,
                                fall);
                            sandwich_minimalitaetstest(k->next,l1!=l3,n,g,
                                &history[1],nil,nil,fall>2,41,True,hislen);
                            if (l1==l3) {
                               /* Nebenraender vertauschen */
                              start = 0;  connfl = 0;
                              dummypos = konstruiere_patch_top_down(map,&start,
                                         1,0,1,&connfl);
                              /* Konstruktionsergebnis wie oben, daher einfache
                                 Konstruktion ohne Tests */
                              graphenzahl[ARRAYPOS_LN(g,n,2)]++;
                              k = verknuepfe_sandwichpatches(gk_td[1][perm2],
                                  gk_td[1][perm1],gk_td[1][perm3],l3,l2,l1,
                                  &randcode[2][offset3],offset3 ? 1+(fall>2) :
                                  0,fall);
                              sandwich_minimalitaetstest(k->next,False,n,g,
                                  &history[1],nil,nil,fall>2,42,True,hislen);
                            }
                            if (fall==2 &&  /* => beide Randcodelaengen ==2 */
                                randcode[0][0]==randcode[2][offset3] &&
                                randcode[2][offset3+1]==0) {
                              /* Haupt- und Nebenrand gleich -> vertauschen
                                 (auf keinen Fall isomorph, da 3 Raender, von 
                                 denen nur 2 gleich sind)  (l2==l3) */
                              start = 0;  connfl = 0;
                              dummypos = konstruiere_patch_top_down(map,&start,
                                         1,0,1,&connfl);
                              /* Konstruktionsergebnis wie oben, daher einfache
                                 Konstruktion ohne Tests */
                              graphenzahl[ARRAYPOS_LN(g,n,2)]++;
                              k = verknuepfe_sandwichpatches(gk_td[1][perm3],
                                  gk_td[1][perm2],gk_td[1][perm1],l1,l2,l3,
                                  &randcode[2][offset3],offset3 ? 1 : 0,2);
                              sandwich_minimalitaetstest(k->next,False,n,g,
                                  &history[1],nil,nil,False,42,True,hislen);
	  	  	    }
                          }
                          if (!recover && (save_flag || save_flag2)) 
                            {speichere_graphen_aus_outputliste_in_files(hislen,
                             2,4,0,l1,l2,l3,(KNOTENTYP)fl,0,n,g-2,0,g,
                             (KNOTENTYP)kriti,0,0);}
                          if (recover) {recover = False; 
                              count = recovercount;    count2 = recovercount2;
                              count3 = recovercount3;  count4 = recovercount4;
                              count5 = recovercount5;  count6 = recovercount6;}
                        }
                        nebenzweig[0]++;
                        if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
                      } while ((lev1 = setze_history_weiter_td(1,hislen-1,
                               MAX(erg1-1,1),True))!=-1);
                      nebenzweig[0] = 0L;
                    } while (schalte_weiter_td(&hislen,1,1,&dummy,True));
                  }
                }  
              }
            }
          }      /* if g>1 */
        }        /* for l2 */
      }          /* for l3 */
    }            /* for l1 */

    if (g>(small_face>6 || (small_face==6 && facenum_max[0]<fl)) &&
       (!recover || mgl_rec==5) && !digon_path && !l1_sandwich &&
       (pv<5 || bk_moeglich[fl][bkb_[0] = ANZ_BK_BEREINIGT(6,g-1,1)])) {
      /* sonst nicht moeglich */
      /* Fall b: "l2" ist gerade (Moeglichkeit 5) */
      /* Falls small_face>6, dann hat jeder Patch mit einem Rand und g==0
         mehr als 6 Bruchkanten, passt also sowieso nicht. Falls small_face==6,
         dann hat jeder Patch mit einem Rand und g==0, der nicht nur 6-Ecke 
         enthaelt, ebenfalls mehr als 6 Bruchkanten. */
      p2 = 5;  p3 = 0;  p8 = p11 = p14 = p15 = 0;  p10 = g-1;
      p7 = (KNOTENTYP)fl;
      /* moegliche Pfadlaengen durchgehen: */
      bc_td[0][0][0] = 1;   bc_td[0][0][1] = 3;   bc_td[0][0][2] = 9;
      for (l1=recover ? l1_rec : 1; l1 < n>>1; l1++) {    /* l1 = Pfadteil 1 */
        p4 = l1;
        for (l3=recover ? l3_rec : l1; l1+l3<n; l3++) {  
            /* l1 <= l3 = Pfadteil 3 */
          p6 = l3;
          for (l2=recover ? l2_rec : 2; l1+l2+l3<=n+1; l2+=2) {  
            /* l2 ist gerade */ 
            p5 = l2;
            innere = n - (l1+l2+l3-1);      /* restliche innere Knoten */
            bilde_sw2_code(l1,l2,l3,bc_td[0][0]);
            fl_td[0][0] = fl;   g_td[0][0] = g-1;   
            anz3_td[0][0] = anzahl_3_val_randknoten(bc_td[0][0]);
            n_td[0][0] = innere;
            if (innere != INNERE_KNOTEN(g-1,fl,1,anz3_td[0][0]))
	       {fprintf(stderr,"Logischer Fehler 10 in " 
                               "top_down_generierung!\n",innere);  exit(106);} 
            for (kriti = recover ? (EULERTYP)krit1_rec : kpk_anz[arraypos]-1;  
                 kriti>=0;  kriti--) {    /* diese Schleife kann kurz sein */
              p13 = (KNOTENTYP)kriti;
              krit = kpk[arraypos][kriti];    /* kritische Punkte */
              if (IS_KP_MOEGLICH(fl,bkb_[0],krit)) {
                krit_td[0][0] = krit;
                zweig[1] = 0L;
                per_td[0][0][0] = randlaenge(&bc_td[0][0][3],0,
                                  ermittle_wh(&bc_td[0][0][3],6));
                hislen = 2;
                count++;
                count = count%mod;
                if ((recover || !mod_used || count==class) &&
                    suche_patch(1,&hislen,True,&dummy,True)) {
                  do {
                    lev1 = hislen-1;
                    nebenzweig[0] = 0L;
                    starte_history_td(1,hislen-1);
                    do {
                      start = 0;  connfl = 0; 
                      if ((erg1 = konstruiere_patch_top_down(map,&start,1,
                           lev1,1,&connfl))==1 &&
                          (!recover || nebenzweig[0]==recovernebenzweig[0])) {
                        if (!recover && (level2<hislen || class2==0) &&
                           (level3<hislen || class3==0) && 
                           (level4<hislen || class4==0) && 
                           (level5<hislen || class5==0) && 
                           (level6<hislen || class6==0) && 
                           (!facerestrict || flaechenzahlen_ok(&history[1]))) {
                          graphenzahl[ARRAYPOS_LN(g,n,2)]++;
                          fall = ((l3&1)<<1) + (l1&1) + 1;
                          verknuepfe_sandwichpatch2(gk_td[1][0],
                                                    &bc_td[0][0][3],fall);
                          sandwich_minimalitaetstest(fall==2 || fall==4 ? 
                            gk_td[1][0]->next->invers : gk_td[1][0],False,n,
                            g,&history[1],nil,nil,fall==1 || fall==3,5,True,
                            hislen);  
                          /* Laufrichtung nicht festlegen, da Spiegelbild immer
                             passt, wenn Original passt. */
                        }
                        if (!recover && (save_flag || save_flag2)) 
                           {speichere_graphen_aus_outputliste_in_files(hislen,
                            2,5,0,l1,l2,l3,(KNOTENTYP)fl,0,n,g-1,0,g,
                            (KNOTENTYP)kriti,0,0);}
                        if (recover) {recover = False;   
                            count = recovercount;    count2 = recovercount2;
                            count3 = recovercount3;  count4 = recovercount4;
                            count5 = recovercount5;  count6 = recovercount6;}
                      }
                      nebenzweig[0]++;
                      if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
                    } while ((lev1 = setze_history_weiter_td(1,hislen-1,
                             MAX(erg1-1,1),True))!=-1);
                    nebenzweig[0] = 0L;
                  } while (schalte_weiter_td(&hislen,1,1,&dummy,True));
                }  
              }
            }
          }               /* for l2 */
        }                 /* for l3 */
      }                   /* for l1 */
    }                     /* if g>0 */
    if (graphstat) {
#ifndef NOTIMES
      dummy_ct = times(&TMS);
      buffertime = TMS.tms_utime;
      sprintf(strpuf,"\nConstructed %d map%s with genus %d and"
                     " %d vertices along type-2 Petrie paths "
                     "in %.1f seconds, accepted %d.",
                     graphenzahl[ARRAYPOS_LN(g,n,2)],
                     graphenzahl[ARRAYPOS_LN(g,n,2)]==1 ? (char *)"" :
                     (char *)"s",g,n,
                     (double)(buffertime-savetime)/time_factor,
                     non_iso_graphenzahl[ARRAYPOS_LN(g,n,2)]);
      logfile_entry(strpuf,True,True,False);
      savetime = buffertime;
#else
      sprintf(strpuf,"\nConstructed %d map%s with genus %d and"
                     " %d vertices along type-2 Petrie paths, "
                     "accepted %d.",
                     graphenzahl[ARRAYPOS_LN(g,n,2)],
                     graphenzahl[ARRAYPOS_LN(g,n,2)]==1 ? (char *)"" :
                     (char *)"s",g,n,
                     non_iso_graphenzahl[ARRAYPOS_LN(g,n,2)]);
      logfile_entry(strpuf,True,True,False);
#endif //NOTIMES
    }
  }                       /* if do_sandwich */
  
  if (do_brille && (!recover || pfadtyp_rec==3)) {       /* Brillenpfade */

    p1 = 3;
    randcode[0][1] = randcode[1][1] = 0;   /* fuer Nebenraender, falls 2 BKs */
    vor1[1] = vor2[1] = False;   vor[1] = 0;
    history[0].prev1 = &history[1];   vater_nr[1] = 0;
    history[0].vorg = 1;    
    /* diese Daten bleiben waehrend des gesamten folgenden Vorgangs erhalten */
  
    /* moegliche Pfadlaengen durchgehen: */
    for (l1 = recover ? l1_rec : MIN(3,small_face); 
         l1 <= (loop_brille ? 1 : (digon_brille || digon_path ? 2 : n>>1));  
         l1++) {    
      /* l1 = Pfadteil 1 (bei Loop-Brille immer l1==1, bei Digon-Brille immer
         l1<=2, bei Digon-Path immer l1==2, weil Einecke verboten sind) */
      p4 = l1;
      for (l3 = recover ? l3_rec : l1; l1+l3<=n; l3++) { 
                                           /* l1 <= l3 = Pfadteil 3 */
        p6 = l3;
        for (l2 = recover ? l2_rec : 1; l1+l2+l3<=n+1; l2++) {
          p5 = l2;
          innere = n - (l1+l2+l3-1);      /* restliche innere Knoten */
          fall = bilde_brillen_randcodes(l1,l3,l2,randcode[0],&codelen[0],
                 randcode[1],&codelen[1],randcode[2],&codelen[2],&offset3);
          per[0]  = randlaenge(randcode[0],0,codelen[0]-1);
          per[1]  = randlaenge(randcode[1],0,codelen[1]-1);
          per[2]  = randlaenge(&randcode[2][offset3],0,
                               codelen[2]/(1+(l1==l3))-1);

          /* Moeglichkeit 1:  3 Patches mit je 1 Rand */
          if (fl>2 && (!recover || mgl_rec==1) && 
              bruchkantentest(codelen[0],1,0,g) &&
              bruchkantentest(codelen[1],1,0,g) && 
              bruchkantentest(codelen[2],1,0,g) &&
              (small_face<6 || (g>2 && randcode[0][0]>0 && randcode[1][0]>0
               && randcode[2][offset3]>0))) {
            p2 = 1;  p3 = 0;
            bordercode[0][0] = bordercode[1][0] = bordercode[2][0] = 1; 
            bordercode[0][1] = bordercode[1][1] = bordercode[2][1] = 3;
            bordercode[0][2] = 3 + codelen[0];
            bordercode[1][2] = 3 + codelen[1];
            bordercode[2][2] = 3 + codelen[2];
            memcpy(&bordercode[0][3],randcode[0],
                   sizeof(KNOTENTYP)*codelen[0]);
            memcpy(&bordercode[1][3],randcode[1],
                   sizeof(KNOTENTYP)*codelen[1]);
            memcpy(&bordercode[2][3],&randcode[2][offset3],
                   sizeof(KNOTENTYP)*codelen[2]);
            anz3[0] = anzahl_3_val_randknoten(bordercode[0]);
            anz3[1] = anzahl_3_val_randknoten(bordercode[1]);
            anz3[2] = anzahl_3_val_randknoten(bordercode[2]);
            if (innere >= (anz3[0]&1)+(anz3[1]&1)+(anz3[2]&1)) {
               /* denn fuer jede ungerade Anzahl 3-valenter Randknoten muss
                  die Anzahl der inneren Knoten auch ungerade sein =>
                  mindestens 1 innerer Knoten pro ungerader 3-val-Anzahl */ 
              for (g_[0] = recover ? g1_rec : (l1<=2 ? 0 : 
                   g-2*(small_face>=6)); g_[0]>=(small_face>=6); g_[0]--) { 
                p10 = (KNOTENTYP)g_[0];
                for (g_[1] = recover ? g2_rec : 
                     (l1==l3 ? MIN(g-g_[0]-(small_face>=6),g_[0]) : 
                     (l3<=2 ? 0 : g-g_[0]-(small_face>=6))); 
                     g_[1]>=(small_face>=6); g_[1]--) {
                  /* hier muss l3<=2 abgefragt werden, denn aus l1<=2 und l3<=2
                     folgt nicht l1==l3, so dass g_[1]<=g_[0]==0 nicht
                     automatisch gelten wuerde */
                  p11 = (KNOTENTYP)g_[1];
                  g_[2] = g-g_[0]-g_[1];  
                  bkb_[0] = ANZ_BK_BEREINIGT(codelen[0],g_[0],1);
                  bkb_[1] = ANZ_BK_BEREINIGT(codelen[1],g_[1],1);
                  bkb_[2] = ANZ_BK_BEREINIGT(codelen[2],g_[2],1);
                  for (n_[0] = recover ? fln1_rec : (randcode[0][0]==0 ? 0 :
                       innere-(anz3[2]&1) - ((innere-(anz3[2]&1)^anz3[0])&1));
                       /* wird nie negativ */
                       n_[0]>=0; n_[0]-=2) {     /* Paritaet passt */
                    p7 = (KNOTENTYP)n_[0];
                    j = l1==l3 && g_[0]==g_[1] ? 
                        MIN(n_[0],innere-(anz3[2]&1)-n_[0]) : 
                        (l3<=2 ? 0 : innere-(anz3[2]&1)-n_[0]);
                    /* hier muss l3<=2 abgefragt werden, denn aus l1<=2 und 
                       l3<=2 folgt nicht l1==l3, so dass j<=n_[0]==0 nicht
                       automatisch gelten wuerde */
                    for (n_[1] = recover ? fln2_rec : j-((j^anz3[1])&1); 
                         n_[1]>=0; n_[1]-=2) {   /* Paritaet passt */
                      p8 = (KNOTENTYP)n_[1];
                      n_[2] = innere-n_[0]-n_[1];
                      if ((n_[2]^anz3[2])&1) {fprintf(stderr,
                          "Logischer Fehler 5 in top_down_generierung!\n");
                          exit(107);}
                      fl_[0] = FLAECHEN(g_[0],1,n_[0],anz3[0]);
                      fl_[1] = FLAECHEN(g_[1],1,n_[1],anz3[1]);
                      fl_[2] = fl-fl_[0]-fl_[1];
                      if (fl_[0]>0 && fl_[1]>0 && fl_[2]>0 &&
                         (randcode[2][offset3]>0 || (fl_[2]==1 && g_[2]==0)) &&
                         /* keine Kerbe => 1 Flaeche, Geschlecht 0 */
                         (pv<5 || (bk_moeglich[fl_[0]][bkb_[0]] &&
                                   bk_moeglich[fl_[1]][bkb_[1]] &&
			           bk_moeglich[fl_[2]][bkb_[2]]))) {

      /* Flaechenzahl passt - kritische Punkte durchgehen */
      /* den folgenden Teil um 18 Stellen einruecken: */
      for (kriti = recover ? (EULERTYP)krit1_rec : kpk_anz[arraypos]-1;  
           kriti>=0;  kriti--) {    /* diese Schleife kann kurz sein */
        p13 = (KNOTENTYP)kriti;
        krit = kpk[arraypos][kriti];    /* kritische Punkte */
        for (kriti_[0] = recover ? krit2_rec : 0;
             kriti_[0]<kp_anz[fl_[0]][bkb_[0]] && 
            (kp_[0] = kp[fl_[0]][bkb_[0]][kriti_[0]])<=krit; 
             kriti_[0]++) {  /* auch diese Schleife kann kurz sein */
          p14 = kriti_[0];
          for (kriti_[1] = recover ? krit3_rec : (l1==l3 && n_[0]==n_[1] &&
               g_[0]==g_[1] ? kriti_[0] : 0);  /* => Patch 2 groesser als 1 */
               kriti_[1]<kp_anz[fl_[1]][bkb_[1]] && 
               kp_[0]+(kp_[1] = kp[fl_[1]][bkb_[1]][kriti_[1]])<=krit; 
               kriti_[1]++) {  /* auch diese Schleife kann kurz sein */
            if (IS_KP_MOEGLICH(fl_[2],bkb_[2],kp_[2] = krit-kp_[0]-kp_[1])) {

    /* den folgenden Teil um 28 Stellen einruecken: */
    p15 = kriti_[1];
    zweig[1] = 0L;
    sortiere_patches3(kp_,fl_,g_,&perm1,&perm2,&perm3);
    hislen = 2;
    fl_td[0][0] = fl_[perm1];    g_td[0][0] = g_[perm1]; 
    krit_td[0][0] = kp_[perm1];  n_td[0][0] = n_[perm1];
    anz3_td[0][0] = anz3[perm1];  
    per_td[0][0][0] = per[perm1];
    memcpy(bc_td[0][0],bordercode[perm1],sizeof(KNOTENTYP)*(3+codelen[perm1]));
    count++;
    count = count%mod;
    if (patchcheck) {
      overflow[1] = False;
      for (f=0; f<anz_face; f++)  {pc_flaechenzahl_sk[f] = 0;}
    }
    if (!recover) {gefunden1 = False;} 
    if ((recover || !mod_used || count==class) &&
        suche_patch(1,&hislen,True,&dummy,False)) {
      if (recover) {
        if (hislen==recover_hislen)   /* Recovern abschliessen */ 
           {recover = False;  
            count = recovercount;    count2 = recovercount2;
            count3 = recovercount3;  count4 = recovercount4;
            count5 = recovercount5;  count6 = recovercount6;}
      }
      else if (save_flag || save_flag2) {          /* zwischenspeichern */
        speichere_graphen_aus_outputliste_in_files(hislen,3,1,0,l1,l2,
          l3,(KNOTENTYP)n_[0],(KNOTENTYP)n_[1],n,(KNOTENTYP)g_[0],
          (KNOTENTYP)g_[1],g,(KNOTENTYP)kriti,kriti_[0],kriti_[1]);
      }
      do {
        hislen1 = hislen;         /* Zwischenspeichern */
        /* "hislen1" kann sich von Durchlauf zu Durchlauf aendern, deshalb
           innerhalb der Schleife zwischenspeichern */
        lev1 = hislen1-1;
        nebenzweig[0] = 0L;
        if (patchcheck) {starte_pc_history_td(1,hislen1-1);}
        else {starte_history_td(1,hislen1-1);}
        pc = pc2 = False;
        do {
          start = 0;  connfl = 0;
          if (patchcheck) {lev1 = hislen; 
                           errechne_flaechenzahlen(1,hislen1-1);}
          if ((erg1 = konstruiere_patch_top_down(map,&start,1,
                      lev1,1,&connfl))==1 &&
             (!recover || nebenzweig[0]==recovernebenzweig[0])) {

            /* Daten fuer Patch 2: */
            gefunden1 = True;
            pc = False;
            start2 = start;   connfl2 = connfl;
            fl_td[0][hislen] = fl_[perm2];    g_td[0][hislen] = g_[perm2];
            krit_td[0][hislen] = kp_[perm2];  n_td[0][hislen] = n_[perm2];
            anz3_td[0][hislen] = anz3[perm2];  
            per_td[0][0][hislen] = per[perm2];
            history[hislen].prev1 = &history[hislen+1];
            history[hislen].vorg = 1;
            memcpy(bc_td[0][hislen],bordercode[perm2],
                   sizeof(KNOTENTYP)*(3+codelen[perm2]));
            hislen++;
            vor1[hislen] = vor2[hislen] = False;  vor[hislen] = 0;
            vater_nr[hislen] = hislen-1;
            hislen++;
            wh1 = False;
            weiter = False;        /* noch nichts Sinnvolles konstr. */
            zweig[hislen1+1] = 0L;
            if (patchcheck) {
              overflow[hislen1+1] = False;
              for (f=0; f<anz_face; f++) {pc_flaechenzahl_sk[f] = 
                                          (history[1].flaechenzahl)[f];}
            }
            if (!recover) {gefunden2 = False;} 
            if (suche_patch(hislen1+1,&hislen,True,&pc,False)) {
              if (recover) {
                if (hislen==recover_hislen)   /* Recovern abschliessen */ 
                   {recover = False;  
                    count = recovercount;    count2 = recovercount2;
                    count3 = recovercount3;  count4 = recovercount4;
                    count5 = recovercount5;  count6 = recovercount6;}
              }
              else if (save_flag || save_flag2) {     /* zwischenspeichern */
                speichere_graphen_aus_outputliste_in_files(hislen,3,1,0,l1,
                  l2,l3,(KNOTENTYP)n_[0],(KNOTENTYP)n_[1],n,(KNOTENTYP)g_[0],
                  (KNOTENTYP)g_[1],g,(KNOTENTYP)kriti,kriti_[0],kriti_[1]);
              }
              do {
                hislen2 = hislen;  
                lev2 = hislen2-1;
                nebenzweig[1] = 0L;
                if (patchcheck) {starte_pc_history_td(hislen1+1,hislen2-1);}
                else {starte_history_td(hislen1+1,hislen2-1);}
                do {
                  start = start2;  connfl = connfl2; 
                  if (patchcheck) {lev2 = hislen; 
		      errechne_flaechenzahlen(hislen1+1,hislen2-1);}
                  if ((erg2 = konstruiere_patch_top_down(map,&start,
                      hislen1+1,lev2,hislen1+1,&connfl))==hislen1+1 &&
                      (!recover || nebenzweig[1]==recovernebenzweig[1])) {
                    /* Daten fuer Patch 3: */
                    gefunden2 = True;
                    pc2 = False;
                    start3 = start;   connfl3 = connfl;
                    fl_td[0][hislen] = fl_[perm3];
                    krit_td[0][hislen] = kp_[perm3];
                    g_td[0][hislen] = g_[perm3];
                    n_td[0][hislen] = n_[perm3];
                    anz3_td[0][hislen] = anz3[perm3];  
                    per_td[0][0][hislen] = per[perm3];
                    history[hislen].prev1 = &history[hislen+1];
                    history[hislen].vorg = 1;
                    memcpy(bc_td[0][hislen],bordercode[perm3],
                           sizeof(KNOTENTYP)*(3+codelen[perm3]));
                    hislen++;
                    vor1[hislen] = vor2[hislen] = False;  vor[hislen] = 0;
                    vater_nr[hislen] = hislen-1;
                    hislen++;
                    wh2 = False;
                    weiter2 = False;
                    zweig[hislen2+1] = 0L;
                    if (patchcheck) {
                      overflow[hislen2+1] = False;
                      for (f=0; f<anz_face; f++) {pc_flaechenzahl_sk[f] = 
                        (history[1].flaechenzahl)[f] +
                        (history[hislen1+1].flaechenzahl)[f];}
                    }
                    if (!recover) {gefunden3 = False;} 
                    if (suche_patch(hislen2+1,&hislen,True,&pc2,True)) {

  /* folgenden Text um 48 Stellen einruecken: */
  do {
    lev3 = hislen-1;  
    nebenzweig[2] = 0L;
    if (patchcheck) {starte_pc_history_td(hislen2+1,hislen-1);}
    else {starte_history_td(hislen2+1,hislen-1);}
    do {
      start = start3;  connfl = connfl3;
      if (patchcheck) {lev3 = hislen; 
                       errechne_flaechenzahlen(hislen2+1,hislen-1);}
      if ((erg3 = konstruiere_patch_top_down(map,&start,hislen2+1,
                  lev3,hislen2+1,&connfl))==hislen2+1) {
        gefunden3 = True;
        weiter = weiter2 = True;    /* sinnvoller Patch 3 wurde konstruiert */
        if (!recover || nebenzweig[2]==recovernebenzweig[2]) {
          if (!recover) {
            if ((level2<hislen-hislen2 || class2==0) &&
                (level3<hislen-hislen2 || class3==0) &&
                (level4<hislen-hislen2 || class4==0) && 
                (level5<hislen-hislen2 || class5==0) &&
                (level6<hislen-hislen2 || class6==0) && 
                (!facerestrict || flaechenzahlen3_ok(&history[1],
                 &history[hislen1+1],&history[hislen2+1]))) {  
              if (wh1) {
                start = 0;   connfl = 0;
                dummypos = konstruiere_patch_top_down(map,&start,1,0,1,
                                                      &connfl);
              }
              if (wh2) {
                start = start2;   connfl = connfl2;
                dummypos = konstruiere_patch_top_down(map,&start,
                           hislen1+1,0,hislen1+1,&connfl);
              }
              graphenzahl[ARRAYPOS_LN(g,n,3)]++;
              k = verknuepfe_brillenpatches(
                  gk_td[1+hislen1*(perm2==0)+hislen2*(perm3==0)][0],
                  gk_td[1+hislen1*(perm2==1)+hislen2*(perm3==1)][0],
                  gk_td[1+hislen1*(perm2==2)+hislen2*(perm3==2)][0],l1,l3,l2,
                  &randcode[2][offset3],offset3 ? 3-codelen[0] : 0,fall);
              wh1 = wh2 = True;
              brillen_minimalitaetstest(k,l1!=l3 || g_[0]!=g_[1] || 
                fl_[0]!=fl_[1] || kriti_[0]!=kriti_[1],n,g,&history[1],
                &history[hislen1+1],&history[hislen2+1],1,hislen);
            }
            if (save_flag || save_flag2) 
               {speichere_graphen_aus_outputliste_in_files(hislen,3,1,0,l1,l2,
                l3,(KNOTENTYP)n_[0],(KNOTENTYP)n_[1],n,(KNOTENTYP)g_[0],
                (KNOTENTYP)g_[1],g,(KNOTENTYP)kriti,kriti_[0],kriti_[1]);}
          }
          else {recover = False;  
                count = recovercount;    count2 = recovercount2;
                count3 = recovercount3;  count4 = recovercount4;
                count5 = recovercount5;  count6 = recovercount6;}
        }
      }
      nebenzweig[2]++;
      if (nebenzweig[2]==ULONG_MAX) {zweig_error(-3);}
    } while ((lev3 = patchcheck ?
              setze_pc_history_weiter_td(hislen2+1,hislen-1) :
              setze_history_weiter_td(hislen2+1,hislen-1,
              MAX(erg3-1,hislen2+1),True))!=-1);
    if (patchcheck) {
      overflow[hislen2+1] = False;
      for (f=0; f<anz_face; f++) {pc_flaechenzahl_sk[f] = 
         (history[1].flaechenzahl)[f] +
         (history[hislen1+1].flaechenzahl)[f];}
    }
    nebenzweig[2] = 0L;
  } while (schalte_weiter_td(&hislen,hislen2+1,hislen2+1,&pc2,True));
  /* Ende des um 48 Stellen eingerueckten Textes */

                    }   /* if suche_patch 3 */
                    hislen = hislen2;
                  }    /* if Patch 2 konstruiert */ 
                  else {weiter2 = True;}   /* an Patch 3 scheitert's nicht */
                  nebenzweig[1]++;
                  if (nebenzweig[1]==ULONG_MAX) {zweig_error(-2);}
	        } while ((mod2_used || mod3_used || mod4_used || mod5_used ||
                          mod6_used || pc2 || weiter2 || gefunden3) &&
                  (lev2 = 
                  patchcheck ? setze_pc_history_weiter_td(hislen1+1,hislen-1)
                  : setze_history_weiter_td(hislen1+1,
                  hislen-1,MAX(erg2-1,hislen1+1),True))!=-1);
                if (patchcheck) {
                  overflow[hislen1+1] = False;
                  for (f=0; f<anz_face; f++) {pc_flaechenzahl_sk[f] = 
                                              (history[1].flaechenzahl)[f];}
                }
                nebenzweig[1] = 0L;
              } while ((mod2_used || mod3_used || mod4_used || mod5_used ||
                        mod6_used || pc2 || weiter2 || gefunden3) && 
                       schalte_weiter_td(&hislen,hislen1+1,hislen1+1,&pc,
                       False));
            }     /* if suche_patch */
            hislen = hislen1;
          }      /* if Patch 1 konstruiert */
          else {weiter = True;}   /* naechster Versuch, denn an Patch 2 und 3
                                     scheitert's (noch) nicht */
          nebenzweig[0]++;
          if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
        } while ((mod2_used || mod3_used || mod4_used || mod5_used || mod6_used
                  || pc || pc2 || weiter || gefunden2) && 
                 ((lev1 = patchcheck ?
                 setze_pc_history_weiter_td(1,hislen-1) :
                 setze_history_weiter_td(1,
                 hislen-1,MAX(erg1-1,1),True))!=-1));
        if (patchcheck) {
          overflow[1] = False;
          for (f=0; f<anz_face; f++)  {pc_flaechenzahl_sk[f] = 0;}
        }
        nebenzweig[0] = 0L;
      } while ((mod2_used || mod3_used || mod4_used || mod5_used || mod6_used
               || pc || pc2 || weiter || 
        gefunden2) && schalte_weiter_td(&hislen,1,1,&dummy,False));
    }   /* if */
    /* Ende des um 28 Stellen eingerueckten Textes */

            }  /* if */
          }    /* for */
        }      /* for */
      }        /* for */
      /* Ende des um 18 Stellen eingerueckten Textes */
         
                      }   /* if */
                    }     /* for n_[1] */
                  }       /* for n_[0] */  
                }         /* for g_[1] */
              }           /* for g_[0] */
            }             /* if innere */       
          }               /* if fl>2 && ... */
  
          if (g>0 && fl>1) {
            /* Moeglichkeit 2:  2 Patches, einer mit 2 Nebenraendern */
            if ((!recover || mgl_rec==2) &&
                bruchkantentest(codelen[0]+codelen[1],2,0,g) && 
                bruchkantentest(codelen[2],1,0,g) &&
                (small_face<6 || (g>1 && randcode[2][offset3]>0))) {
              /* Bei "loop_brille==True", "digon_brille" oder "digon_path"
                 besitzt ein Nebenrand keine Kerbe,
                 so dass es keinen Patch mit den 2 erforderlichen Nebenraendern
                 geben kann. "pruefe_bordercode" wird dies feststellen. */
              p2 = 2;  p3 = 0;  p8 = p11 = p15 = 0;
              vertauscht = bilde_bordercode2(randcode[0],codelen[0],per[0],
                           randcode[1],codelen[1],per[1],bordercode[0],
                           per2[0]);                   /* Nebenpatch */
              if (pruefe_bordercode(bordercode[0])) {  
                bordercode[2][0] = 1;  bordercode[2][1] = 3;
                bordercode[2][2] = 3+codelen[2];     /* Hauptpatch */
                memcpy(&bordercode[2][3],&randcode[2][offset3],
                       sizeof(KNOTENTYP)*codelen[2]);
                anz3[0] = anzahl_3_val_randknoten(bordercode[0]);
                anz3[2] = anzahl_3_val_randknoten(bordercode[2]);
                per2[2][0] = per[2];
                if (innere >= (anz3[0]&1)+(anz3[2]&1)) {
                  for (g_[0] = recover ? g1_rec : g-1-(small_face>=6); 
                       g_[0]>=0;  g_[0]--) {
                    p10 = (KNOTENTYP)g_[0];
                    g_[2] = g-1-g_[0];       /* >=1, falls small_face>=6 */
                    bkb_[0] = ANZ_BK_BEREINIGT(codelen[0]+codelen[1],g_[0],2);
                    bkb_[2] = ANZ_BK_BEREINIGT(codelen[2],g_[2],1);
                    for (n_[0] = recover ? fln1_rec : innere-(anz3[2]&1)-
                        ((innere-(anz3[2]&1)^anz3[0])&1); n_[0]>=0; n_[0]-=2) {
                      p7 = (KNOTENTYP)n_[0];
                      n_[2] = innere-n_[0];
                      if ((n_[2]^anz3[2])&1) {fprintf(stderr,
                          "Logischer Fehler 6 in top_down_generierung!\n");
                          exit(108);}
                      fl_[0] = FLAECHEN(g_[0],2,n_[0],anz3[0]);
                      fl_[2] = fl-fl_[0];
                      if (fl_[0]>0 && fl_[2]>0 &&
                         (randcode[2][offset3]>0 || (fl_[2]==1 && g_[2]==0)) &&
                         /* keine Kerbe => 1 Flaeche, Geschlecht 0 */
                         (pv<5 || (bk_moeglich[fl_[0]][bkb_[0]] &&
			           bk_moeglich[fl_[2]][bkb_[2]]))) {

      /* den folgenden Teil um 18 Stellen einruecken: */
      for (kriti = recover ? (EULERTYP)krit1_rec : kpk_anz[arraypos]-1;  
           kriti>=0;  kriti--) {    /* diese Schleife kann kurz sein */
        p13 = (KNOTENTYP)kriti;
        krit = kpk[arraypos][kriti];    /* kritische Punkte */
        for (kriti_[0] = recover ? krit2_rec : 0;
             kriti_[0]<kp_anz[fl_[0]][bkb_[0]] && 
             (kp_[0] = kp[fl_[0]][bkb_[0]][kriti_[0]])<=krit; kriti_[0]++) {
          if (IS_KP_MOEGLICH(fl_[2],bkb_[2],kp_[2] = krit-kp_[0])) {

    /* den folgenden Teil um 26 Stellen einruecken: */
    p14 = kriti_[0];
    zweig[1] = 0L;
    if (kp_[0]<kp_[2] || (kp_[0]==kp_[2] && (fl_[0]<fl_[2] || 
        (fl_[0]==fl_[2] && g_[0]<g_[2])))) 
         {perm1 = 0;  perm2 = 2;}
    else {perm1 = 2;  perm2 = 0;}
    hislen = 2;
    fl_td[0][0] = fl_[perm1];    g_td[0][0] = g_[perm1]; 
    krit_td[0][0] = kp_[perm1];  n_td[0][0] = n_[perm1];
    anz3_td[0][0] = anz3[perm1];  
    per_td[0][0][0] = per2[perm1][0]; 
    per_td[0][1][0] = per2[perm1][1];
    memcpy(bc_td[0][0],bordercode[perm1],sizeof(KNOTENTYP)*
           bordercode[perm1][bordercode[perm1][0]+1]);
    count++;
    count = count%mod;
    if (!recover) {gefunden1 = False;} 
    if ((recover || !mod_used || count==class) &&
        suche_patch(1,&hislen,True,&dummy,False)) {
      if (recover) {
        if (hislen==recover_hislen)   /* Recovern abschliessen */ 
           {recover = False;  
            count = recovercount;    count2 = recovercount2;
            count3 = recovercount3;  count4 = recovercount4;
            count5 = recovercount5;  count6 = recovercount6;}
      }
      else if (save_flag || save_flag2) {          /* zwischenspeichern */
        speichere_graphen_aus_outputliste_in_files(hislen,3,2,0,l1,l2,l3,
          (KNOTENTYP)n_[0],0,n,(KNOTENTYP)g_[0],0,g,
          (KNOTENTYP)kriti,kriti_[0],0);
      }
      do {
        hislen1 = hislen;  /* Zwischenspeichern */
        lev1 = hislen1-1;
        nebenzweig[0] = 0L;
        starte_history_td(1,hislen1-1);
        do {
          start = 0;  connfl = 0;
          if ((erg1 = konstruiere_patch_top_down(map,&start,1,
                      lev1,1,&connfl))==1 &&
             (!recover || nebenzweig[0]==recovernebenzweig[0])) {

            /* Daten fuer Patch 2: */
            gefunden1 = True;
            start2 = start;    connfl2 = connfl;
            fl_td[0][hislen] = fl_[perm2];  g_td[0][hislen] = g_[perm2];
            krit_td[0][hislen] = kp_[perm2];
            n_td[0][hislen] = n_[perm2];
            anz3_td[0][hislen] = anz3[perm2];   
            per_td[0][0][hislen] = per2[perm2][0]; 
            per_td[0][1][hislen] = per2[perm2][1];
            history[hislen].prev1 = &history[hislen+1];
            history[hislen].vorg = 1;
            memcpy(bc_td[0][hislen],bordercode[perm2],
                  sizeof(KNOTENTYP)*bordercode[perm2][bordercode[perm2][0]+1]);
            hislen++;
            vor1[hislen] = vor2[hislen] = False;  vor[hislen] = 0;
            vater_nr[hislen] = hislen-1;
            hislen++;
            iso = -1;           /* noch nicht auf isomorphe Raender geprueft */
            wh1 = False;
            weiter = False;        /* noch nichts Sinnvolles konstr. */
            zweig[hislen1+1] = 0L;
            if (!recover) {gefunden2 = False;} 
            if (suche_patch(hislen1+1,&hislen,True,&dummy,True)) {

  /* den folgenden Teil um 38 Stellen einruecken: */
  do {
    lev2 = hislen-1;  
    nebenzweig[1] = 0L;
    starte_history_td(hislen1+1,hislen-1);
    do {
      start = start2;  connfl = connfl2;
      if ((erg2 = konstruiere_patch_top_down(map,&start,hislen1+1,
                  lev2,hislen1+1,&connfl))==hislen1+1) {
        gefunden2 = True;
        weiter = True;    /* sinnvoller Patch 2 wurde konstruiert */
        if (!recover || nebenzweig[1]==recovernebenzweig[1]) {
          if (!recover && (level2<hislen-hislen1 || class2==0) && 
             (level3<hislen-hislen1 || class3==0) &&
             (level4<hislen-hislen1 || class4==0) && 
             (level5<hislen-hislen1 || class5==0) &&
             (level6<hislen-hislen1 || class6==0) && 
             (!facerestrict || flaechenzahlen3_ok(&history[1],
              &history[hislen1+1],nil))) {
            if (wh1) {start = 0;   connfl = 0;
                      dummypos = konstruiere_patch_top_down(map,&start,1,
                      0,1,&connfl);}
            graphenzahl[ARRAYPOS_LN(g,n,3)]++;
            if (iso==-1 || perm2==0) {iso = l1==l3 ? 
               (char)iso_raender(&history[1+hislen1*(perm2==0)],0,1) : 0;} 
              /* falls Nebenraender in Patch 1 => "iso" nur einmal berechnen */
            k = verknuepfe_brillenpatches(
                gk_td[1+hislen1*(perm2==0)][vertauscht ? 1 : 0],
                gk_td[1+hislen1*(perm2==0)][vertauscht ? 0 : 1],
                gk_td[1+hislen1*(perm2==2)][0],l1,l3,l2,
                &randcode[2][offset3],offset3 ? 3-codelen[0] : 0,fall);
            wh1 = True;
            brillen_minimalitaetstest(k,l1!=l3,n,g,&history[1],
                &history[hislen1+1],nil,21,hislen);
            if (l1==l3 && iso==0) {
              start = 0;  connfl = 0;
              dummypos = konstruiere_patch_top_down(map,&start,1,0,1,
                                                    &connfl);
              dummypos = konstruiere_patch_top_down(map,&start,hislen1+1,
                                                 0,hislen1+1,&connfl);
              graphenzahl[ARRAYPOS_LN(g,n,3)]++;
              k = verknuepfe_brillenpatches(
                  gk_td[1+hislen1*(perm2==0)][vertauscht ? 0 : 1],
                  gk_td[1+hislen1*(perm2==0)][vertauscht ? 1 : 0],
                  gk_td[1+hislen1*(perm2==2)][0],l3,l1,l2,
                  &randcode[2][offset3],offset3 ? 3-codelen[0] : 0,fall);
              brillen_minimalitaetstest(k,False,n,g,&history[1],
                  &history[hislen1+1],nil,22,hislen);
            }
          }
          if (!recover && (save_flag || save_flag2)) 
             {speichere_graphen_aus_outputliste_in_files(hislen,3,2,0,l1,l2,l3,
              (KNOTENTYP)n_[0],0,n,(KNOTENTYP)g_[0],0,g,
              (KNOTENTYP)kriti,kriti_[0],0);}
          if (recover) {recover = False;   
              count = recovercount;    count2 = recovercount2;
              count3 = recovercount3;  count4 = recovercount4;
              count5 = recovercount5;  count6 = recovercount6;}
        }
      }
      nebenzweig[1]++;
      if (nebenzweig[1]==ULONG_MAX) {zweig_error(-2);}
    } while ((lev2 = setze_history_weiter_td(hislen1+1,hislen-1,
             MAX(erg2-1,hislen1+1),True))!=-1);
    nebenzweig[1] = 0L;
  } while (schalte_weiter_td(&hislen,hislen1+1,hislen1+1,&dummy,True));
  /* Ende des um 38 Stellen eingerueckten Textes */
 
            }   /* Patch 2 gefunden */  
            hislen = hislen1;
          }      /* if Patch 1 konstruiert */         
          else {weiter = True;}   /* Patch 1 weiterschalten, denn an
                                     Patch 2 hat's nicht gelegen */
          nebenzweig[0]++;
          if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
        } while ((mod2_used || mod3_used || mod4_used || mod5_used || mod6_used
                 || weiter || gefunden2) 
          && ((lev1 = setze_history_weiter_td(1,
               hislen-1,MAX(erg1-1,1),True))!=-1));
        nebenzweig[0] = 0L;
      } while ((mod2_used || mod3_used || mod4_used || mod5_used || mod6_used
               || weiter || gefunden2) && 
               schalte_weiter_td(&hislen,1,1,&dummy,False));
    }   /* if suche_patch */
    /* Ende des um 28 Stellen eingerueckten Textes */

          }    /* if */
        }      /* for */
      }        /* for */
      /* Ende des um 18 Stellen eingerueckten Textes */
 
                      }     /* if */
                    }       /* for n_[0] */  
                  }         /* for g_[0] */
                }           /* if innere */
              }           /* if pruefe_bordercode */
            }             /* if Bruchkantentest */

            /* Moeglichkeit 3.1:  2 Patches, einer mit HR und 1.NR */
            if ((!recover || mgl_rec==31) &&
                bruchkantentest(codelen[0]+codelen[2],2,0,g) && 
                bruchkantentest(codelen[1],1,0,g) &&
                (small_face<6 || (g>1 && randcode[1][0]>0))) {
              /* Bei "loop_brille", "digon_brille" oder "digon_path" besitzt 
                 Nebenrand 1 keine Kerbe,
                 so dass es keinen Patch mit den 2 erforderlichen Raendern
                 geben kann. "pruefe_bordercode" wird dies feststellen. */
              p2 = 31;  p3 = 0;  p8 = p11 = p15 = 0;
              vertauscht = bilde_bordercode2(randcode[0],codelen[0],per[0],
                           &randcode[2][offset3],codelen[2],per[2],
                           bordercode[0],per2[0]);
              if (pruefe_bordercode(bordercode[0])) {  
                bordercode[1][0] = 1;  bordercode[1][1] = 3;
                bordercode[1][2] = 3+codelen[1];
                memcpy(&bordercode[1][3],randcode[1],
                       sizeof(KNOTENTYP)*codelen[1]);
                anz3[0] = anzahl_3_val_randknoten(bordercode[0]);
                anz3[1] = anzahl_3_val_randknoten(bordercode[1]);
                per2[1][0] = per[1];
                if (innere >= (anz3[0]&1)+(anz3[1]&1)) {
                  for (g_[0] = recover ? g1_rec : g-1-(small_face>=6); 
                       g_[0]>=0;  g_[0]--) {
                    p10 = (KNOTENTYP)g_[0];
                    g_[1] = g-1-g_[0];       /* >=1, falls small_face>=6 */
                    bkb_[0] = ANZ_BK_BEREINIGT(codelen[0]+codelen[2],g_[0],2);
                    bkb_[1] = ANZ_BK_BEREINIGT(codelen[1],g_[1],1);
                    for (n_[0] = recover ? fln1_rec : innere-(anz3[1]&1)-
                        ((innere-(anz3[1]&1)^anz3[0])&1); n_[0]>=0; n_[0]-=2) {
                      p7 = (KNOTENTYP)n_[0];
                      n_[1] = innere-n_[0];
                      if ((n_[1]^anz3[1])&1) {fprintf(stderr,
                          "Logischer Fehler 7 in top_down_generierung!\n");
                          exit(109);}
                      fl_[0] = FLAECHEN(g_[0],2,n_[0],anz3[0]);
                      fl_[1] = fl-fl_[0];
                      if (fl_[0]>0 && fl_[1]>0 &&
                         (randcode[1][0]>0 || (fl_[1]==1 && g_[1]==0)) &&
                         /* keine Kerbe => 1 Flaeche, Geschlecht 0 */
                         (pv<5 || (bk_moeglich[fl_[0]][bkb_[0]] &&
			           bk_moeglich[fl_[1]][bkb_[1]]))) {

      /* den folgenden Teil um 18 Stellen einruecken: */
      for (kriti = recover ? (EULERTYP)krit1_rec : kpk_anz[arraypos]-1;  
           kriti>=0;  kriti--) {    /* diese Schleife kann kurz sein */
        p13 = (KNOTENTYP)kriti;
        krit = kpk[arraypos][kriti];    /* kritische Punkte */
        for (kriti_[0] = recover ? krit2_rec : 0;
             kriti_[0]<kp_anz[fl_[0]][bkb_[0]] && 
             (kp_[0] = kp[fl_[0]][bkb_[0]][kriti_[0]])<=krit; kriti_[0]++) {
          if (IS_KP_MOEGLICH(fl_[1],bkb_[1],kp_[1] = krit-kp_[0])) {

    /* den folgenden Teil um 26 Stellen einruecken: */
    p14 = kriti_[0];
    zweig[1] = 0L;
    if (kp_[0]<kp_[1] || (kp_[0]==kp_[1] && (fl_[0]<fl_[1] || 
        (fl_[0]==fl_[1] && g_[0]<g_[1])))) 
         {perm1 = 0;  perm2 = 1;}
    else {perm1 = 1;  perm2 = 0;}
    hislen = 2;
    fl_td[0][0] = fl_[perm1];    g_td[0][0] = g_[perm1]; 
    krit_td[0][0] = kp_[perm1];  n_td[0][0] = n_[perm1];
    anz3_td[0][0] = anz3[perm1];  
    per_td[0][0][0] = per2[perm1][0]; 
    per_td[0][1][0] = per2[perm1][1];
    memcpy(bc_td[0][0],bordercode[perm1],sizeof(KNOTENTYP)*
           bordercode[perm1][bordercode[perm1][0]+1]);
    count++;
    count = count%mod;
    if (!recover) {gefunden1 = False;} 
    if ((recover || !mod_used || count==class) &&
        suche_patch(1,&hislen,True,&dummy,False)) {
      if (recover) {
        if (hislen==recover_hislen)   /* Recovern abschliessen */ 
           {recover = False;  
            count = recovercount;    count2 = recovercount2;
            count3 = recovercount3;  count4 = recovercount4;
            count5 = recovercount5;  count6 = recovercount6;}
      }
      else if (save_flag || save_flag2) {          /* zwischenspeichern */
        speichere_graphen_aus_outputliste_in_files(hislen,3,31,0,l1,l2,
          l3,(KNOTENTYP)n_[0],0,n,(KNOTENTYP)g_[0],0,g,
          (KNOTENTYP)kriti,kriti_[0],0);
      }
      do {
        hislen1 = hislen;  /* Zwischenspeichern */
        lev1 = hislen1-1;
        nebenzweig[0] = 0L;
        starte_history_td(1,hislen1-1);
        do {
          start = 0;  connfl = 0;
          if ((erg1 = konstruiere_patch_top_down(map,&start,1,
                      lev1,1,&connfl))==1 &&
             (!recover || nebenzweig[0]==recovernebenzweig[0])) {

            /* Daten fuer Patch 2: */
            gefunden1 = True;
            start2 = start;   connfl2 = connfl;
            fl_td[0][hislen] = fl_[perm2];  g_td[0][hislen] = g_[perm2];
            krit_td[0][hislen] = kp_[perm2];
            n_td[0][hislen] = n_[perm2];
            anz3_td[0][hislen] = anz3[perm2];   
            per_td[0][0][hislen] = per2[perm2][0]; 
            per_td[0][1][hislen] = per2[perm2][1];
            history[hislen].prev1 = &history[hislen+1];
            history[hislen].vorg = 1;
            memcpy(bc_td[0][hislen],bordercode[perm2],
                  sizeof(KNOTENTYP)*bordercode[perm2][bordercode[perm2][0]+1]);
            hislen++;
            vor1[hislen] = vor2[hislen] = False;  vor[hislen] = 0;
            vater_nr[hislen] = hislen-1;
            hislen++;
            wh1 = False;
            weiter = False;        /* noch nichts Sinnvolles konstr. */
            zweig[hislen1+1] = 0L;
            if (!recover) {gefunden2 = False;} 
            if (suche_patch(hislen1+1,&hislen,True,&dummy,True)) {

  /* den folgenden Teil um 38 Stellen einruecken: */
  do {
    lev2 = hislen-1;  
    nebenzweig[1] = 0L;
    starte_history_td(hislen1+1,hislen-1);
    do {
      start = start2;  connfl = connfl2;
      if ((erg2 = konstruiere_patch_top_down(map,&start,hislen1+1,
                  lev2,hislen1+1,&connfl))==hislen1+1) {
        gefunden2 = True;
        weiter = True;    /* sinnvoller Patch 2 wurde konstruiert */
        if (!recover || nebenzweig[1]==recovernebenzweig[1]) {
          if (!recover && (level2<hislen-hislen1 || class2==0) && 
             (level3<hislen-hislen1 || class3==0) &&
             (level4<hislen-hislen1 || class4==0) && 
             (level5<hislen-hislen1 || class5==0) &&
             (level6<hislen-hislen1 || class6==0) && 
             (!facerestrict || flaechenzahlen3_ok(&history[1],
              &history[hislen1+1],nil))) {
            if (wh1) {start = 0;   connfl = 0;
                      dummypos = konstruiere_patch_top_down(map,&start,1,
                      0,1,&connfl);}
            graphenzahl[ARRAYPOS_LN(g,n,3)]++;
            k = verknuepfe_brillenpatches(
                gk_td[1+hislen1*(perm2==0)][vertauscht ? 1 : 0],
                gk_td[1+hislen1*(perm2==1)][0],
                gk_td[1+hislen1*(perm2==0)][vertauscht ? 0 : 1],l1,l3,l2,
                &randcode[2][offset3],offset3 ? 3-codelen[0] : 0,fall);
            wh1 = True;
            brillen_minimalitaetstest(k,True,n,g,&history[1],
                &history[hislen1+1],nil,31,hislen);
          }
          if (!recover && (save_flag || save_flag2)) 
             {speichere_graphen_aus_outputliste_in_files(hislen,3,31,0,l1,l2,
              l3,(KNOTENTYP)n_[0],0,n,(KNOTENTYP)g_[0],0,g,
              (KNOTENTYP)kriti,kriti_[0],0);}
          if (recover) {recover = False;  
              count = recovercount;    count2 = recovercount2;
              count3 = recovercount3;  count4 = recovercount4;
              count5 = recovercount5;  count6 = recovercount6;}
        }
      }
      nebenzweig[1]++;
      if (nebenzweig[1]==ULONG_MAX) {zweig_error(-2);}
    } while ((lev2 = setze_history_weiter_td(hislen1+1,hislen-1,
             MAX(erg2-1,hislen1+1),True))!=-1);
    nebenzweig[1] = 0L;
  } while (schalte_weiter_td(&hislen,hislen1+1,hislen1+1,&dummy,True));
  /* Ende des um 38 Stellen eingerueckten Textes */
 
            }   /* Patch 2 gefunden */  
            hislen = hislen1;
          }      /* if Patch 1 konstruiert */         
          else {weiter = True;}   /* Patch 1 weiterschalten, denn an
                                     Patch 2 hat's nicht gelegen */
          nebenzweig[0]++;
          if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
        } while ((mod2_used || mod3_used || mod4_used || mod5_used || mod6_used
                 || weiter || gefunden2) 
          && ((lev1 = setze_history_weiter_td(1,
               hislen-1,MAX(erg1-1,1),True))!=-1));
        nebenzweig[0] = 0L;
      } while ((mod2_used || mod3_used || mod4_used || mod5_used || mod6_used
                || weiter || gefunden2) && 
        schalte_weiter_td(&hislen,1,1,&dummy,False));
    }   /* if suche_patch */
    /* Ende des um 26 Stellen eingerueckten Textes */
 
          }  /* if */
        }    /* for */
      }      /* for */
      /* Ende des um 18 Stellen eingerueckten Textes */

                      }     /* if */
                    }       /* for n_[0] */  
                  }         /* for g_[0] */
                }           /* if innere */
              }           /* if pruefe_bordercode */
            }             /* if Bruchkantentest */

            /* Moeglichkeit 3.2:  2 Patches, einer mit HR und 2.NR */
            if (l1!=l3 &&          /* sonst Dopplung */
               (!recover || mgl_rec==32) &&
                bruchkantentest(codelen[1]+codelen[2],2,0,g) && 
                bruchkantentest(codelen[0],1,0,g) &&
                (small_face<6 || (g>1 && randcode[0][0]>0))) {
              p2 = 32;  p3 = 0;  p8 = p11 = p15 = 0;
              bilde_bordercode2(randcode[1],codelen[1],per[1],
                                &randcode[2][offset3],
                                codelen[2],per[2],bordercode[0],per2[0]);
              if (pruefe_bordercode(bordercode[0])) {  
                bordercode[1][0] = 1;  bordercode[1][1] = 3;
                bordercode[1][2] = 3+codelen[0];
                memcpy(&bordercode[1][3],randcode[0],
                       sizeof(KNOTENTYP)*codelen[0]);
                anz3[0] = anzahl_3_val_randknoten(bordercode[0]);
                anz3[1] = anzahl_3_val_randknoten(bordercode[1]);
                per2[1][0] = per[0];
                if (innere >= (anz3[0]&1)+(anz3[1]&1)) {
                  for (g_[0] = recover ? g1_rec : g-1-(small_face>=6); 
                       g_[0]>=0;  g_[0]--) {
                    p10 = (KNOTENTYP)g_[0];
                    g_[1] = g-1-g_[0];       /* >=1, falls small_face>=6 */
                    bkb_[0] = ANZ_BK_BEREINIGT(codelen[1]+codelen[2],g_[0],2);
                    bkb_[1] = ANZ_BK_BEREINIGT(codelen[0],g_[1],1);
                    for (n_[0] = recover ? fln1_rec : innere-(anz3[1]&1)-
                        ((innere-(anz3[1]&1)^anz3[0])&1); n_[0]>=0; n_[0]-=2) {
                      p7 = (KNOTENTYP)n_[0];
                      n_[1] = innere-n_[0];
                      if ((n_[1]^anz3[1])&1) {fprintf(stderr,
                          "Logischer Fehler 8 in top_down_generierung!\n");
                          exit(110);}
                      fl_[0] = FLAECHEN(g_[0],2,n_[0],anz3[0]);
                      fl_[1] = fl-fl_[0];
                      if (fl_[0]>0 && fl_[1]>0 &&
                         (l1>2 || (fl_[1]==1 && g_[1]==0)) &&
                         (pv<5 || (bk_moeglich[fl_[0]][bkb_[0]] &&
			           bk_moeglich[fl_[1]][bkb_[1]]))) {

      /* den folgenden Teil um 18 Stellen einruecken: */
      for (kriti = recover ? (EULERTYP)krit1_rec : kpk_anz[arraypos]-1;  
           kriti>=0;  kriti--) {    /* diese Schleife kann kurz sein */
        p13 = (KNOTENTYP)kriti;
        krit = kpk[arraypos][kriti];    /* kritische Punkte */
        for (kriti_[0] = recover ? krit2_rec : 0;
             kriti_[0]<kp_anz[fl_[0]][bkb_[0]] && 
             (kp_[0] = kp[fl_[0]][bkb_[0]][kriti_[0]])<=krit; kriti_[0]++) {
          if (IS_KP_MOEGLICH(fl_[1],bkb_[1],kp_[1] = krit-kp_[0])) {

    /* den folgenden Teil um 26 Stellen einruecken: */
    p14 = kriti_[0];
    zweig[1] = 0L;
    if (kp_[0]<kp_[1] || (kp_[0]==kp_[1] && (fl_[0]<fl_[1] || 
        (fl_[0]==fl_[1] && g_[0]<g_[1])))) 
         {perm1 = 0;  perm2 = 1;}
    else {perm1 = 1;  perm2 = 0;}
    hislen = 2;
    fl_td[0][0] = fl_[perm1];    g_td[0][0] = g_[perm1]; 
    krit_td[0][0] = kp_[perm1];  n_td[0][0] = n_[perm1];
    anz3_td[0][0] = anz3[perm1];  
    per_td[0][0][0] = per2[perm1][0]; 
    per_td[0][1][0] = per2[perm1][1];
    memcpy(bc_td[0][0],bordercode[perm1],sizeof(KNOTENTYP)*
           bordercode[perm1][bordercode[perm1][0]+1]);
    count++;
    count = count%mod;
    if (!recover) {gefunden1 = False;} 
    if ((recover || !mod_used || count==class) &&
        suche_patch(1,&hislen,True,&dummy,False)) {
      if (recover) {
        if (hislen==recover_hislen)   /* Recovern abschliessen */ 
           {recover = False; 
            count = recovercount;    count2 = recovercount2;
            count3 = recovercount3;  count4 = recovercount4;
            count5 = recovercount5;  count6 = recovercount6;}
      }
      else if (save_flag || save_flag2) {          /* zwischenspeichern */
        speichere_graphen_aus_outputliste_in_files(hislen,3,32,0,l1,l2,
          l3,(KNOTENTYP)n_[0],0,n,(KNOTENTYP)g_[0],0,g,
          (KNOTENTYP)kriti,kriti_[0],0);
      }
      do {
        hislen1 = hislen;  /* Zwischenspeichern */
        lev1 = hislen1-1;
        nebenzweig[0] = 0L;
        starte_history_td(1,hislen1-1);
        do {
          start = 0;  connfl = 0;
          if ((erg1 = konstruiere_patch_top_down(map,&start,1,
                      lev1,1,&connfl))==1 &&
             (!recover || nebenzweig[0]==recovernebenzweig[0])) {

            /* Daten fuer Patch 2: */
            gefunden1 = True;
            start2 = start;   connfl2 = connfl;
            fl_td[0][hislen] = fl_[perm2];  g_td[0][hislen] = g_[perm2];
            krit_td[0][hislen] = kp_[perm2];
            n_td[0][hislen] = n_[perm2];
            anz3_td[0][hislen] = anz3[perm2];   
            per_td[0][0][hislen] = per2[perm2][0]; 
            per_td[0][1][hislen] = per2[perm2][1];
            history[hislen].prev1 = &history[hislen+1];
            history[hislen].vorg = 1;
            memcpy(bc_td[0][hislen],bordercode[perm2],
                  sizeof(KNOTENTYP)*bordercode[perm2][bordercode[perm2][0]+1]);
            hislen++;
            vor1[hislen] = vor2[hislen] = False;  vor[hislen] = 0;
            vater_nr[hislen] = hislen-1;
            hislen++;
            wh1 = False;
            weiter = False;        /* noch nichts Sinnvolles konstr. */
            zweig[hislen1+1] = 0L;
            if (!recover) {gefunden2 = False;} 
            if (suche_patch(hislen1+1,&hislen,True,&dummy,True)) {

  /* den folgenden Teil um 38 Stellen einruecken: */
  do {
    lev2 = hislen-1;  
    nebenzweig[1] = 0L;
    starte_history_td(hislen1+1,hislen-1);
    do {
      start = start2;  connfl = connfl2;
      if ((erg2 = konstruiere_patch_top_down(map,&start,hislen1+1,
                  lev2,hislen1+1,&connfl))==hislen1+1) {
        gefunden2 = True;
        weiter = True;    /* sinnvoller Patch 2 wurde konstruiert */
        if (!recover || nebenzweig[1]==recovernebenzweig[1]) {
          if (!recover && (level2<hislen-hislen1 || class2==0) && 
             (level3<hislen-hislen1 || class3==0) &&
             (level4<hislen-hislen1 || class4==0) && 
             (level5<hislen-hislen1 || class5==0) &&
             (level6<hislen-hislen1 || class6==0) && 
             (!facerestrict || flaechenzahlen3_ok(&history[1],
              &history[hislen1+1],nil))) {
            if (wh1) {start = 0;   connfl = 0;
                      dummypos = konstruiere_patch_top_down(map,&start,1,
                      0,1,&connfl);}
            graphenzahl[ARRAYPOS_LN(g,n,3)]++;
            k = verknuepfe_brillenpatches(
                gk_td[1+hislen1*(perm2==1)][0],
                gk_td[1+hislen1*(perm2==0)][vertauscht ? 1 : 0],
                gk_td[1+hislen1*(perm2==0)][vertauscht ? 0 : 1],l1,l3,l2,
                &randcode[2][offset3],offset3 ? 3-codelen[0] : 0,fall);
            wh1 = True;
            brillen_minimalitaetstest(k,True,n,g,&history[1],
                &history[hislen1+1],nil,32,hislen);
          }
          if (!recover && (save_flag || save_flag2)) 
             {speichere_graphen_aus_outputliste_in_files(hislen,3,32,0,l1,l2,
              l3,(KNOTENTYP)n_[0],0,n,(KNOTENTYP)g_[0],0,g,
              (KNOTENTYP)kriti,kriti_[0],0);}
          if (recover) {recover = False; 
              count = recovercount;    count2 = recovercount2;
              count3 = recovercount3;  count4 = recovercount4;
              count5 = recovercount5;  count6 = recovercount6;}
        }
      }
      nebenzweig[1]++;
      if (nebenzweig[1]==ULONG_MAX) {zweig_error(-2);}
    } while ((lev2 = setze_history_weiter_td(hislen1+1,hislen-1,
             MAX(erg2-1,hislen1+1),True))!=-1);
    nebenzweig[1] = 0L;
  } while (schalte_weiter_td(&hislen,hislen1+1,hislen1+1,&dummy,True));
  /* Ende des um 38 Stellen eingerueckten Textes */
 
            }   /* Patch 2 gefunden */  
            hislen = hislen1;
          }      /* if Patch 1 konstruiert */         
          else {weiter = True;}   /* Patch 1 weiterschalten, denn an
                                     Patch 2 hat's nicht gelegen */
          nebenzweig[0]++;
          if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
        } while ((mod2_used || mod3_used || mod4_used || mod5_used || mod6_used
                 || weiter || gefunden2) 
          && ((lev1 = setze_history_weiter_td(1,
               hislen-1,MAX(erg1-1,1),True))!=-1));
        nebenzweig[0] = 0L;
      } while ((mod2_used || mod3_used || mod4_used || mod5_used || mod6_used
               || weiter || gefunden2) && 
               schalte_weiter_td(&hislen,1,1,&dummy,False));
    }   /* if suche_patch */
    /* Ende des um 26 Stellen eingerueckten Textes */

          }  /* if */
        }    /* for */
      }      /* for */
      /* Ende des um 18 Stellen eingerueckten Textes */

                      }   /* if */
                    }     /* for n_[0] */  
                  }       /* for g_[0] */
                }         /* if innere */
              }         /* if pruefe_bordercode */
            }           /* if l1!=l3 */
          }             /* if g>0 && fl>1 */

          if (g>1 && (!recover || mgl_rec==4) && l1>2 &&
             (pv<5 || bk_moeglich[fl][bkb_[0] = ANZ_BK_BEREINIGT(6,g-2,3)])) {
            /* Moeglichkeit 4:  1 Patch mit 3 Raendern */
            /* wenn l1<=2, so hat der erste Nebenrand keine Kerbe, kann also
               nicht Teil eines Patches mit mehreren Raendern sein */
            p2 = 4;  p3 = 0;  p8 = p11 = p14 = p15 = 0;  p10 = g-2;  
            p7 = (KNOTENTYP)fl;
            bilde_bordercode3(randcode[0],codelen[0],randcode[1],codelen[1],
              &randcode[2][offset3],codelen[2],bc_td[0][0],
              &perm1,&perm2,&perm3);
            if (pruefe_bordercode(bc_td[0][0])) {  
              fl_td[0][0] = fl;   g_td[0][0] = g-2;   
              anz3_td[0][0] = anzahl_3_val_randknoten(bc_td[0][0]);
              n_td[0][0] = innere;    /* passt immer */
              if (innere != INNERE_KNOTEN(g-2,fl,3,anz3_td[0][0]))
	 	 {fprintf(stderr,"Logischer Fehler 11 in " 
                                 "top_down_generierung!\n");  exit(111);} 
              for (kriti = recover ? (EULERTYP)krit1_rec : kpk_anz[arraypos]-1;
                   kriti>=0;  kriti--) {    /* diese Schleife kann kurz sein */
                p13 = (KNOTENTYP)kriti;
                krit = kpk[arraypos][kriti];    /* kritische Punkte */
                if (IS_KP_MOEGLICH(fl,bkb_[0],krit)) {
                  krit_td[0][0] = krit;
                  zweig[1] = 0L;
                  per_td[0][perm1][0] = per[0];
                  per_td[0][perm2][0] = per[1]; 
                  per_td[0][perm3][0] = per[2];
                  hislen = 2;
                  count++;
                  count = count%mod;
                  if ((recover || !mod_used || count==class) &&
                      suche_patch(1,&hislen,True,&dummy,True)) {  
                      /* gefunden */
                    do {
                      lev1 = hislen-1;
                      nebenzweig[0] = 0L;
                      starte_history_td(1,hislen-1);
                      do {
                        start = 0;  connfl = 0; 
                        if ((erg1 = konstruiere_patch_top_down(map,&start,1,
                             lev1,1,&connfl))==1 && (!recover || 
                             nebenzweig[0]==recovernebenzweig[0])) {
                          if (!recover && (level2<hislen || class2==0) && 
                             (level3<hislen || class3==0) &&
                             (level4<hislen || class4==0) && 
                             (level5<hislen || class5==0) &&
                             (level6<hislen || class6==0) && 
                             (!facerestrict ||
                              flaechenzahlen_ok(&history[1]))) {
                            graphenzahl[ARRAYPOS_LN(g,n,3)]++;
                            k = verknuepfe_brillenpatches(gk_td[1][perm1],
                                gk_td[1][perm2],gk_td[1][perm3],l1,l3,l2,
                                &randcode[2][offset3],offset3 ? 3-codelen[0] : 
                                0,fall);
                            brillen_minimalitaetstest(k,l1!=l3,n,g,
                                               &history[1],nil,nil,41,hislen);
                            if (l1==l3) { 
                               /* Nebenraender vertauschen */
                              start = 0;  connfl = 0;
                              dummypos = konstruiere_patch_top_down(map,&start,
                                         1,0,1,&connfl);
                              /* Konstruktionsergebnis wie oben, daher einfache
                                 Konstruktion ohne Tests */
                              graphenzahl[ARRAYPOS_LN(g,n,3)]++;
                              k = verknuepfe_brillenpatches(gk_td[1][perm2],
                                  gk_td[1][perm1],gk_td[1][perm3],l3,l1,l2,
                                  &randcode[2][offset3],offset3 ? 3-codelen[0] 
                                  : 0,fall);
                              brillen_minimalitaetstest(k,False,n,g,
                                &history[1],nil,nil,42,hislen);
                            }
	    	          }
                          if (!recover && (save_flag || save_flag2)) 
                            {speichere_graphen_aus_outputliste_in_files(hislen,
                             3,4,0,l1,l2,l3,(KNOTENTYP)fl,0,n,g-2,0,g,
                             (KNOTENTYP)kriti,0,0);}
                          if (recover) {recover = False; 
                              count = recovercount;    count2 = recovercount2;
                              count3 = recovercount3;  count4 = recovercount4;
                              count5 = recovercount5;  count6 = recovercount6;}
                        }
                        nebenzweig[0]++;
                        if (nebenzweig[0]==ULONG_MAX) {zweig_error(-1);}
                      } while ((lev1 = setze_history_weiter_td(1,hislen-1,
                               MAX(erg1-1,1),True))!=-1);
                      nebenzweig[0] = 0L;
                    } while (schalte_weiter_td(&hislen,1,1,&dummy,True));
                  }
                }  
              }
            }
          }      /* if g>1 */
        }        /* for l2 */
      }          /* for l3 */
    }            /* for l1 */
    if (graphstat) {
#ifndef NOTIMES
      dummy_ct = times(&TMS);
      buffertime = TMS.tms_utime;
      sprintf(strpuf,"\nConstructed %d map%s with genus %d and"
                     " %d vertices along type-3 Petrie paths in"
                     " %.1f seconds, accepted %d.",
                     graphenzahl[ARRAYPOS_LN(g,n,3)],
                     graphenzahl[ARRAYPOS_LN(g,n,3)]==1 ? (char *)"" : 
                     (char *)"s",g,n,
                     (double)(buffertime-savetime)/time_factor,
                     non_iso_graphenzahl[ARRAYPOS_LN(g,n,3)]);
      logfile_entry(strpuf,True,True,False);
      savetime = buffertime;
#else
      sprintf(strpuf,"\nConstructed %d map%s with genus %d and"
                     " %d vertices along type-3 Petrie paths, "
                     " accepted %d.",
                     graphenzahl[ARRAYPOS_LN(g,n,3)],
                     graphenzahl[ARRAYPOS_LN(g,n,3)]==1 ? (char *)"" : 
                     (char *)"s",g,n,
                     non_iso_graphenzahl[ARRAYPOS_LN(g,n,3)]);
      logfile_entry(strpuf,True,True,False);
#endif //NOTIMES
    }
  }                       /* if do_brille */
}


/**************************************************************/
/* Sonstige Funktionen, die nur von "main" aufgerufen werden: */
/**************************************************************/

/**************************SORTIERE_FLAECHEN********************************/
/*  Sortiert das Array "face" in aufsteigender Reihenfolge                 */
/*  Die Arrays "facenum_min(_usr)" und "facenum_max(_usr)" werden gleich 
    mitsortiert.                                                           */
/*  Ausserdem werden die Werte von "gerade" und "doppelkanten" bestimmt
    und einige Pruefungen vorgenommen.                                     */

void sortiere_flaechen(void) {
  static FLAECHENTYP i,h;
  static KNOTENTYP hh,anz;
  static BOOL getauscht;
  getauscht = True;              /* Schleife einmal durchlaufen */
  anz = anz_face;
  while (anz>1 && getauscht) {
    i = 1;   getauscht = False;
    while (i<anz) {
      if (face[i]<face[i-1]) {
        getauscht=True; 
        h = face[i];       face[i] = face[i-1];          face[i-1] = h;
        hh = facenum_min_usr[i];  facenum_min_usr[i] = facenum_min_usr[i-1];  
        facenum_min_usr[i-1] = hh;
        hh = facenum_max_usr[i];  facenum_max_usr[i] = facenum_max_usr[i-1];  
        facenum_max_usr[i-1] = hh;
        hh = facenum_min[i];  facenum_min[i] = facenum_min[i-1];  
        facenum_min[i-1] = hh;
        hh = facenum_max[i];  facenum_max[i] = facenum_max[i-1];  
        facenum_max[i-1] = hh;
      }
      i++;
    }
    anz--;    /* nun steht das groesste Element am Ende der Liste */
  }         
  for (i=0; i<anz_face; i++) {
    if (facenum_min_usr[i] > facenum_max_usr[i]) 
       {fprintf(stderr,"Error: Minimum face number of degree %d is bigger"
                       " than maximum number!\n",face[i]);  exit(40);}
  }
  for (i=0; i+1<anz_face; i++) {
    if (face[i]==face[i+1]) {fprintf(stderr,"Error: Face of degree %d"
                             " defined twice!\n",face[i]); exit(41);}
  }
  if (face[anz_face-1]>F_MAX) {fprintf(stderr,"Error: Face degree %d exceeds "
                         "allowed interval [1,%d]!\n",face[anz_face-1],F_MAX);
                          exit(42);}
  if (face[0]<3) {doppelkanten = True;}
}

/****************UNERLAUBTE_KOMBINATION*************************************/

void unerlaubte_kombination(FLAECHENTYP *face,KNOTENTYP *facenum,
     FLAECHENTYP anz_face,KNOTENTYP genus,KNOTENTYP fl,char *warum) {
  static KNOTENTYP h; 
  sprintf(strpuf,"  Remark: The following combination is not possible due to "
                 "%s:\n  Genus %d, %d faces: ",warum,genus,fl);
  logfile_entry(strpuf,True,False,False);
  for (h=0; h<anz_face; h++) {
    sprintf(strpuf,"%d %d-gon%s, ",facenum[h],face[h],facenum[h]==1 ? 
           (char *)"" : (char *)"s");
    logfile_entry(strpuf,False,False,False);
  }
  logfile_entry((char *)"\n",False,True,False);
}

/******************PRUEFE_GRUENBAUM_SAETZE***********************************/
/* Diese Funktion prueft, ob der Benutzer Flaechenkombinationen aufgerufen
   hat, die laut Gruenbaum (siehe Buch "Convex Polytopes") nicht realisierbar
   sind. Die Funktion arbeitet nur bei planaren Graphen.
   "face" muss aufsteigend sortiert sein.                                   */

BOOL pruefe_gruenbaum_saetze(FLAECHENTYP *face,KNOTENTYP *facenum,
                             FLAECHENTYP anz_face,KNOTENTYP fl) {
  static FLAECHENTYP k,i;
  static KNOTENTYP sum;       /* Ausnahmeflaechen */
  for (k=2; k<=5; k++) {
    sum = 0;
    for (i=0; i<anz_face; i++) {if (face[i]%k) {sum += facenum[i];}}
    if (sum==1) {return(False);}    /* 13.4.2(k) */
    else if (sum==0) {
      if (conn2==False && conn3==False) {return(False);}       /* 13.4.3(k) */
      if (k==3 && fl%2) {return(False);}                     /* 13.4.4(3) */
      else if (k==4 && fl%4!=2) {return(False);}               /* 13.4.4(4) */
      else if (k==5 && fl%10!=2) {return(False);}              /* 13.4.4(5) */ 
    }
    else if (sum==2 && k==3 && fl%2) {return(False);}     /* 13.4.4(3) */
  }
  return(True);
}

/*******************JUCOVIC_SUM*********************************************/
/*  Errechnet die Summe auf der rechten Seite der Formel von Jucovic       */
/*  und von Barnette. "face" muss aufsteigend sortiert sein.               */

signed long jucovic_sum(KNOTENTYP genus,KNOTENTYP bigfaces,FLAECHENTYP *face,
       KNOTENTYP *facenum,FLAECHENTYP anz_face) {
  static signed long sum,sum2;
  static FLAECHENTYP i;
  static signed long face3,face4,face5;

  /* Jucovic-Summe: */
  sum = 0;
  for (i=0; i<anz_face; i++) {    /* Flaechen durchgehen */
    if (face[i]==3) {face3 = (signed long)facenum[i];}
    else if (face[i]==4) {face4 = (signed long)facenum[i];}
    else if (face[i]==5) {face5 = (signed long)facenum[i];}
    else if (face[i]>6) 
            {sum += ((((signed long)face[i]+1L)>>1)-6L)*facenum[i];}
  }
  if (sum>2L*face4) 
     {sum = 4L*(1L-genus) - face5 + (sum-2L*face4-1L)/3L+1L;}
     /* "von Hand" aufgerundet */
  else {sum = 4L*(1L-genus) - face5 + (sum-2L*face4)/3L;}
       /* automatisch aufgerundet */

  /* Barnette-Summe: */
  if (face3>face5)
     {sum2 = 2L*(1L-genus) - bigfaces + (face3-face5-1L)/2L+1L;}  
     /* "von Hand" aufgerundet */
  else {sum2 = 2L*(1L-genus) - bigfaces + (face3-face5)/2L;}  
       /* automatisch aufgerundet */
  return(MAX(sum,sum2));
}

/*******************JENDROL_SUM*********************************************/
/*  Ueberprueft die Formeln von Jendrol.                                   */
/*  "face" muss aufsteigend sortiert sein.                                 */

BOOL jendrol_sum(KNOTENTYP genus,FLAECHENTYP *face,KNOTENTYP *facenum,
                 FLAECHENTYP anz_face) {
  static KNOTENTYP sum,sum2;
  static int i;
  static KNOTENTYP face5,face6,face7;

  /* Theorem 1 beta/gamma: */
  if (genus==0) {
    sum = sum2 = face6 = 0;
    for (i=(int)anz_face-1; sum<=2 && i>=0; i--) {    /* Flaechen durchgehen */
      if (face[i]%3) {sum += facenum[i];}
      if (face[i]!=6) {sum2 += facenum[i];} else {face6 = facenum[i];}
    }
    if (sum<=2 && (sum2&1)!=(face6&1) && !conn1 && !conn2) {return(False);}
    /* wahrscheinlich wurde die Gueltigkeit nur fuer 3--zush. Karten
       bewiesen */
  }

  /* Theorem 3: */
  else if (genus==1) {
    face5 = face7 = 0;
    for (i=0; i<anz_face; i++) {
      if (((face[i]<5 || face[i]>7) && facenum[i]) ||
          (face[i]==5 && facenum[i]!=1) || (face[i]==7 && facenum[i]!=1)) 
         {return(True);}     /* Kriterium nicht erfuellt => alles ok */
      else if (face[i]==5) {face5 = facenum[i];}
      else if (face[i]==7) {face7 = facenum[i];}
    }
    return(face5!=1 || face7!=1);   /* Kriterium erfuellt => keine Karten */
    /* die Karten waeren 3--zsh. => im Gegensatz zu oben ist keine 
       Einschraenkung erforderlich */
  }  
  return(True);    /* falls genus>2 oder Theorem 1 nicht anwendbar */
}

/**********************BELEGE_BK_KP_MOEGLICH*****************************/
/* Diese Funktion erhaelt eine Kombination aus "anz_face" verschiedenen
   Flaechengraden, wobei "facenum[i]" angibt, wie oft die Flaeche vom
   Grad "face[i]" vertreten ist. Die Funktion nimmt alle moeglichen
   Teilmengen dieser Flaechen und belegt die Arrays "bk_moeglich" und
   "kp_moeglich"
   entsprechend. Interpretiert bedeutet das:  "facenum" enthaelt die
   Flaechen einer Zielkarte, und die Funktion errechnet alle moeglichen
   Flaechenkombinationen in den Patches.                               */
/* Die Funktion arbeitet rekursiv. "i" gibt an, bis zum wievielten
   Flaechentyp schon vorgedrungen wurde. "facenum_patch" gibt an, wie 
   viele Flaechen in den "virtuellen Patch" aufgenommen wurden.        */

void belege_bk_kp_moeglich(FLAECHENTYP i,KNOTENTYP *facenum,
                           KNOTENTYP *facenum_patch) {
  static KNOTENTYP j,flaechen;
  static POSTYP bruchkanten,kritische_punkte;
  if (i<anz_face) {   /* auswaehlen, wie viele Flaechen vom Grad face[i] in den
                         "virtuellen Patch" aufgenommen werden */
    for (facenum_patch[i]=0; facenum_patch[i]<=facenum[i];
         facenum_patch[i]++) 
      {belege_bk_kp_moeglich(i+1,facenum,facenum_patch);}
  }
  else {     /* jeder Flaechengrad beruecksichtigt => auswerten */
    flaechen = 0;   bruchkanten = kritische_punkte = 0;
    for (j=0; j<anz_face; j++) {
      bruchkanten += (POSTYP)facenum_patch[j]*(POSTYP)face[j];
      /* spaeter muessen fuer jede Flaeche ausser der ersten 6 Bruchkanten
         abgezogen werden */
      if (face[j]>6) {kritische_punkte += 
                      (POSTYP)facenum_patch[j]*(POSTYP)(face[j]-6);}
      flaechen += facenum_patch[j];
    }
    if (flaechen>0 && bruchkanten>=(POSTYP)(flaechen-1)*6) {  /* Lazy-eval. */
       /* Anzahl der Bruchkanten ist nicht zu klein, so dass sich der Patch
          also nicht fruehzeitig schliessen wuerde und auch pseudokonvex
          sein kann */
      if (bruchkanten-(POSTYP)(flaechen-1)*6>bk_max)
         {fprintf(stderr,"Logischer Fehler in belege_bk_kp_moeglich!\n");
          exit(100);}
      bk_moeglich[flaechen][bruchkanten-(POSTYP)(flaechen-1)*6] = True;
      bk_moeglich[0][bruchkanten-(POSTYP)(flaechen-1)*6] = True;
      if (alternative) {kritische_punkte = 0;}  /* wichtig, damit Schleifen
                 ueber kritische Punkte automatisch nicht durchlaufen werden */
      SET_KP_MOEGLICH(flaechen,bruchkanten-(POSTYP)(flaechen-1)*6,
                      kritische_punkte);
      SET_KP_MOEGLICH(0,bruchkanten-(POSTYP)(flaechen-1)*6,kritische_punkte);
    }
  }
}

/********************SORTIERE_EIN****************************************/
/*  Sortiert einen Wert "wert" in eine aufsteigend sortierte Liste
    "array" der Groesse "groesse" ein, aber nur dann, wenn der Wert noch
    nicht vorkommt.                                                     */

void sortiere_ein(KNOTENTYP *groesse,KNOTENTYP *array,KNOTENTYP wert) {
  static KNOTENTYP i,j;
  if (*groesse==0) {array[0] = wert;  *groesse = 1;}  /* erster Eintrag */
  else {    /* "array" enthaelt schon Eintraege */
    i = 0;
    while (i<*groesse && array[i]<wert) {i++;}
    if (i==*groesse) {array[i] = wert;  (*groesse)++;}
    else if (array[i]!=wert) {   /* sonst nichts tun */
      for (j = *groesse; j>i; j--) {array[j] = array[j-1];}
      array[i] = wert;  (*groesse)++;
    }
  }
} 

/***********ERRECHNE_KOMBINATIONEN**************************************/
/* Diese Funktion errechnet erlaubte Kombinationen von Flaechenzahlen.
   Sie arbeitet rekursiv. "i" ist der Index der aktuellen Flaeche.
   "fl" ist die gewuenschte Flaechenzahl, "genus", "anz_face", "facenum", 
   "facenum_min", "facenum_max", "euler_facenum_min" und "euler_facenum_max" 
   siehe "preufe_flaechen-
   kombination". "sum" ist die Summe der bisher genommenen Flaechen.   */
/* Leider muss diese Funktion zweimal komplett durchlaufen werden:
   Beim ersten Mal wird u.a. der Wert von "bk_max" ermittelt, beim zweiten
   Mal werden die Eintraege in das Array "bk_moeglich" vorgenommen, dessen
   Groesse von "bk_max" abhaengt. "pass" unterscheidet zwischen beiden
   Durchlaeufen ("1" und "2").                                         */  

BOOL errechne_kombinationen(FLAECHENTYP i,FLAECHENTYP anz_face,KNOTENTYP sum,
     KNOTENTYP *facenum,KNOTENTYP *facenum_min,KNOTENTYP *facenum_max,
     KNOTENTYP fl,KNOTENTYP genus,KNOTENTYP *euler_facenum_min,
     KNOTENTYP *euler_facenum_max,FLAECHENTYP *face,char pass) {
  static KNOTENTYP bigfaces,h;
  static signed long eulersumme,face6;
  static unsigned long kritische_punkte; 
         /* fuer Aufspaltung nach kritischen Fl. */
  static FLAECHENTYP j;
  static KNOTENTYP ii,f;
  static POSTYP bk_sum;
  static BOOL festgelegt = False;    /* MUSS static sein, da Wert nur beim
                                        ersten Aufruf festgelegt werden soll */
  static KNOTENTYP facenum_patch[MAXFTYPEN];  /* fuer 2.Durchgang */  

  BOOL erg = False;
  if (i==0) {             /* Eulerformel berechnen */
    if (facenum_min[i]<=fl-sum && facenum_max[i]>=fl-sum) { 
      /* sonst unmoeglich */
      facenum[i] = fl-sum;      /* mit Flaechen des letzten Typs auffuellen */
      eulersumme = 0L;          /* Eulersumme berechnen */
      kritische_punkte = 0L;
      bigfaces = 0;             /* Anzahl grosser Flaechen */
      for (j=0; j<anz_face; j++) {
        eulersumme += (signed long)facenum[j]*(6-(signed long)face[j]);
        if (face[j]==6) {face6 = (signed long)facenum[j];}
        else if (face[j]>6) {
          if (!alternative) 
             {kritische_punkte += facenum[j]*(KNOTENTYP)(face[j]-6);}
          bigfaces += facenum[j];
        }
      }
      if (eulersumme==12L-12L*(signed long)genus) {  /* Kombination gefunden */
        if (bigfaces>2 && genus==0 && !doppelkanten && !conn1 && !conn2 &&    
             /* Barnette/Jucovic-Saetze anwenden (genus==0 wegen 3-Zsh., 
                was bei genus>0 nicht ueberprueft werden kann) */  
            face6 < jucovic_sum(0,bigfaces,face,facenum,anz_face))
          {if (pass==1) {unerlaubte_kombination(face,facenum,anz_face,genus,fl,
				 (char *)"the theorems of Barnette/Jucovic");}}
        else if (genus<2 && !doppelkanten &&   /* Jendrol-Saetze anwenden */
                 !jendrol_sum(genus,face,facenum,anz_face)) 
          {if (pass==1) {unerlaubte_kombination(face,facenum,anz_face,genus,fl,
						(char *)"Jendrol's theorem");}}
        else if (genus==0 && !doppelkanten &&   /* Gruenbaum-Saetze anwenden
                 (nicht bei nicht-trivialen Doppelkanten und Loops, da dort die
                  Gueltigkeit unklar ist): */
                 !pruefe_gruenbaum_saetze(face,facenum,anz_face,fl))
          {if (pass==1) {unerlaubte_kombination(face,facenum,anz_face,genus,fl,
				             (char *)"Gruenbaum's theorem");}}
        else {                /* Tests ueberstanden */
          erg = True;
          if (pass==1) {                     /* Grenzen aendern: */
            for (j=0; j<anz_face; j++) {
              if (facenum[j] < euler_facenum_min[j]) 
                 {euler_facenum_min[j] = facenum[j];}
              if (facenum[j] > euler_facenum_max[j])
  	       {euler_facenum_max[j] = facenum[j];}
            }
            if (kritische_punkte < krit_min) {krit_min = kritische_punkte;}
            if (kritische_punkte > krit_max) {krit_max = kritische_punkte;}
            /* "bk_max" und "bc_len_max" angleichen: */
            bk_sum = MIN(6,big_face);
            for (j=0; j<anz_face; j++) {
              if (face[j]>6) {bk_sum += (face[j]-6)*facenum[j];}
            }
            if (bk_sum>bk_max) 
               {bk_max = bk_sum;  bc_len_max = MAX(6,bk_max)+3+genus_end_usr;}
            festgelegt = True;
          }
          else {
            sortiere_ein(&kpk_anz[ARRAYPOS_N(genus,2*fl+4*genus-4)],
                         kpk[ARRAYPOS_N(genus,2*fl+4*genus-4)],
                         kritische_punkte);
            /* Natuerlich kann bei mehreren Flaechenkombinationen die
               Anzahl der kritischen Punkte gleich sein (insbesondere bei
               "alternative==True", wo die Anzahl der kritischen Punkte immer
               0 ist). Auch ist nicht gewaehrleistet, dass die Folge der
               auftretenden kritischen Punkte monoton waechst (z.B. tritt
               erst 1 Neuneck, 6 Sechsecke, 5 Dreiecke auf, hat aber weniger
               kritische Punkte als beispielsweise 2 Achtecke, 8 Vierecke).
               Deshalb muss die Anzahl der kritischen Punkte ganz gewoehnlich
               einsortiert werden. */ 
            belege_bk_kp_moeglich(0,facenum,facenum_patch);
          } 
        }
      }
    }    
  }
  else {
    if (sum + facenum_min[i] <= fl) {
      sum += (facenum[i] = facenum_min[i]);
      while (sum<=fl && facenum[i]<=facenum_max[i]) {
        if (errechne_kombinationen(i-1,anz_face,sum,facenum,facenum_min,
            facenum_max,fl,genus,euler_facenum_min,euler_facenum_max,face,pass)
            ==True) {erg = True;}  /* Moeglichkeit gefunden */
        facenum[i]++;  sum++;
      }
    }
  }       
  return(erg);
}

/*********************PRUEFE_FLAECHENKOMBINATION*****************************/
/* Diese Funktion prueft, ob die vom Benutzer gewuenschte Flaechenkombination
   ueberhaupt moeglich ist und wenn ja, ob sich irgendwelche Einschraenkungen
   an Flaechenzahlen eines bestimmten Typs ergeben.                         */
/* Falls ueberhaupt keine Graphen erzeugt werden koennen, gibt die Funktion
   "False" zurueck. Falls die Funktion "True" zurueckgibt, enthaelt das Array
   "is_moeglich" fuer jedes Geschlecht und jede Flaechenanzahl getrennt die 
   Information, ob zugehoerige Graphen produziert werden koennen.           */
/* "n_anf" und "n_end" sind die kleinste bzw. groesste gewuenschte KNOTENzahl
   in den fertigen Graphen, "g_anf" und "g_end" das kleinste bzw. groesste
   gewuenschte Geschlecht. Die Funktion versucht, die Werte einzuschraenken.
   "face", "facenum_min" und "facenum_max" zeigen
   auf die Arrays, in denen der Benutzer die gewuenschten Flaechen und deren
   Zahlen spezifiziert hat. Die Arrays enthalten jeweils "anz_face" Ein-
   traege. "face" ist aufsteigend sortiert.                                 */

BOOL pruefe_flaechenkombination(KNOTENTYP *g_anf,KNOTENTYP *g_end,
     KNOTENTYP *n_anf,KNOTENTYP *n_end,FLAECHENTYP *face,KNOTENTYP 
     *facenum_min,KNOTENTYP *facenum_max,FLAECHENTYP *anz_face) {
  static KNOTENTYP euler_facenum_min[MAXFTYPEN], euler_facenum_max[MAXFTYPEN];
                   /* durch Eulerformel ermittelte Grenzen */
  static KNOTENTYP facenum[MAXFTYPEN];   /* fuer konkrete Flaechenzahlen */
  static int i,j;             /* i = Index des betrachteten Flaechentyps */ 
  static KNOTENTYP n;
  static EULERTYP genus;
  static FILE *logfile;

  /* konkrete Kombinationen ausrechnen: */ 
  for (i=0; i<*anz_face; i++) {euler_facenum_min[i] = F_MAXANZ;
                               euler_facenum_max[i] = 0;}
  for (genus = (EULERTYP)(*g_anf); genus <= (EULERTYP)(*g_end); genus++) {
    for (n = *n_anf; n <= *n_end; n+=2) {
      is_moeglich[ARRAYPOS_N(genus,n)] = n/2+2<=2*(KNOTENTYP)genus ? False :
          errechne_kombinationen(*anz_face-1,*anz_face,0,facenum,facenum_min,
                                 facenum_max,n/2+2-2*(KNOTENTYP)genus,
                                 (KNOTENTYP)genus,euler_facenum_min,
                                 euler_facenum_max,face,1);
      if (!is_moeglich[ARRAYPOS_N(genus,n)]) {
        sprintf(strpuf,"Result (by Euler formula or theorem): No maps "
                "with genus %d and %d vertices possible!\n",genus,n);
        logfile_entry(strpuf,True,True,False);
      }
    }
  }  

  /* Flaechenzahlen an die durch die Eulerformel errechneten Zahlen anpassen.
     Ob die Zahlen auch genutzt werden, haengt davon ab, ob der Benutzer 
     Flaechenzahlen eingeschraenkt hat oder nicht, also ob
     facerestrict==True.  */
  for (i=*anz_face; i>0; i--) {
    if (euler_facenum_min[i-1] > facenum_min[i-1]) 
       {facenum_min[i-1] = euler_facenum_min[i-1];}
    if (euler_facenum_max[i-1] < facenum_max[i-1]) 
       {facenum_max[i-1] = euler_facenum_max[i-1];}
    if (facenum_max[i-1]==0) {     /* Flaeche bleibt ungenutzt */
      sprintf(strpuf,"Result by Euler formula:  No maps with %d-gons"
                     " possible!\n",face[i-1]);
      logfile_entry(strpuf,True,True,False);
      for (j=i; j<*anz_face; j++) {
        face[j-1] = face[j];  facenum_min[j-1] = facenum_min[j];
        facenum_max[j-1] = facenum_max[j];
      }
      (*anz_face)--;
    }
  }

  /* obere Grenze der Graphenerzeugung einschraenken: */
  /* 1.: Geschlecht einschraenken */
  genus = *g_end;
  do {
    n = *n_end;
    while (n>=*n_anf && !is_moeglich[ARRAYPOS_N(genus,n)]) {n-=2;}
    if (n < *n_anf) {   /* gar keine Knotenzahl passt bei Geschlecht "genus" */
      sprintf(strpuf,"=> Result computed with Euler formula:\n"
                      "No maps with the given face size number(s) and the "
                      "given vertex number(s) exist for genus %d!\n",genus);
      logfile_entry(strpuf,True,True,False);
      genus--;
    }
  } while (n<*n_anf && genus>=(EULERTYP)(*g_anf));
  if (genus < (EULERTYP)(*g_anf)) {return(False);}   
     /* gesamte Matrix auf "False" => gar keine Graphen moeglich */
  *g_end = (KNOTENTYP)genus;

  /* 2.: Knotenzahl einschraenken */
  n = *n_end;
  do {
    genus = (EULERTYP)(*g_end);
    while (genus>=(EULERTYP)(*g_anf) && !is_moeglich[ARRAYPOS_N(genus,n)]) 
          {genus--;}
    if (genus < (EULERTYP)(*g_anf)) { 
      /* gar kein Geschlecht passt bei Knotenzahl "n" */
      sprintf(strpuf,"=> Result computed with Euler formula:\n"
                      "No maps with the given face size number(s) and the "
                      "given genus exist for vertex number %d!\n",n);
      logfile_entry(strpuf,True,True,False);
      n-=2;
    }  
  } while (genus<(EULERTYP)(*g_anf) && n>=*n_anf);
  *n_end = n;

  /* untere Grenze der Graphenerzeugung einschraenken: */
  /* 1.: Geschlecht einschraenken */
  genus = (EULERTYP)(*g_anf);
  do {
    n = *n_end;
    while (n>=*n_anf && !is_moeglich[ARRAYPOS_N(genus,n)]) {n-=2;}
    if (n < *n_anf) {   /* gar keine Knotenzahl passt bei Geschlecht "genus" */
      sprintf(strpuf,"=> Result computed with Euler formula:\n"
                      "No maps with the given face size number(s) and the "
                      "given vertex number(s) exist for genus %d!\n",genus);
      logfile_entry(strpuf,True,True,False);      
      genus++;
    }
  } while (n<*n_anf && genus<=(EULERTYP)(*g_end));
  *g_anf = (KNOTENTYP)genus;

  /* 2.: Knotenzahl einschraenken */
  n = *n_anf;
  do {
    genus = (EULERTYP)(*g_end);
    while (genus>=(EULERTYP)(*g_anf) && !is_moeglich[ARRAYPOS_N(genus,n)]) 
          {genus--;}
    if (genus < (EULERTYP)(*g_anf)) {
      /* gar kein Geschlecht passt bei Knotenzahl "n" */
      sprintf(strpuf,"=> Result computed with Euler formula:\n"
                      "No maps with the given face size number(s) and the "
                      "given genus exist for vertex number %d!\n",n);
      logfile_entry(strpuf,True,True,False);
      n+=2;
    }  
  } while (genus<(EULERTYP)(*g_anf) && n<=*n_end);
  *n_anf = n;
  return(True);
}

/**************PATCHERZEUGUNGSGRENZEN***************************************/
/*  Fuer die Top-Down-Erzeugung                                            */

void patcherzeugungsgrenzen(void) {
  static KNOTENTYP i;
  if (td_limits) {                             /* Benutzervorgaben pruefen */
    for (i=1; i<=genus_end_usr; i++) {
      if (cmax_g_usr[i] > cmax_g_usr[i-1]) 
         {sprintf(strpuf,"Error in top down limits:  Concave sum limit for " 
                  "genus %d must not be higher than for genus %d!\n",i,i-1); 
          logfile_entry(strpuf,True,True,True);
          exit(97);}
      else if (cmax_g_usr[i]==cmax_g_usr[i-1]) {
        if (fmax_g_usr[i] > fmax_g_usr[i-1])
           {sprintf(strpuf,"Error in top down limits:  Face number limit for " 
                  "genus %d must not be higher than for genus %d!\n",i,i-1); 
            logfile_entry(strpuf,True,True,True);
            exit(98);}
        else if (fmax_g_usr[i]==fmax_g_usr[i-1]) {
          if (fmax_g_usr[i] > 0 &&                  /* sonst unbedeutend */
              bmax_g_usr[i] >= bmax_g_usr[i-1] &&
              bmax_g_usr[i-1] < genus_end_usr-i+2) 
             /* wenn fuer Geschlecht i-1 sowieso schon die maximale Anzahl
                Raender gegeben ist, so darf die Randzahl fuer Geschlecht i
                genauso hoch angegeben sein (also eigentlich ZU hoch, aber
                das wird zugelassen, damit der Benutzer nicht ueber die
                maximal moeglichen Randzahlen nachdenken muss) */
             {sprintf(strpuf,"Error in top down limits:  Boundary number limit"
              " for genus %d must be lower than for genus %d!\n",i,i-1); 
              logfile_entry(strpuf,True,True,True);
              exit(43);}

	}
      }
    }
    for (i=0; i<=genus_end_usr; i++) {
      if ((i==0 && fmax_g_usr[i]==0) || (fmax_g_usr[i]>0 && bmax_g_usr[i]==0)) 
         {sprintf(strpuf,"Error in top down limits:  Illegal parameter 0 "
                  "detected for genus %d!\n",i);
          logfile_entry(strpuf,True,True,True);
          exit(44);}
    }
  }
  else if (td_limits_auto) {
    /* Limits festlegen - koennen ueber der theoretischen Grenze liegen */
    switch (genus_end_usr) {
      case 0: {
        cmax_g_usr[0] = krit_max/3;
        bmax_g_usr[0] = 1;   
        fmax_g_usr[0] = (n_end_usr>>1)+2;
        break;
      }
      case 1: {
        cmax_g_usr[0] = cmax_g_usr[1] = krit_max/3;
        bmax_g_usr[0] = 2;         bmax_g_usr[1] = 1;     
        fmax_g_usr[0] = (n_end_usr>>1)+2-2*genus_anf_usr;  
        fmax_g_usr[1] = n_end_usr>>1;
        break;
      }
      case 2: {
        cmax_g_usr[0] = cmax_g_usr[1] = cmax_g_usr[2] = krit_max/3;
        bmax_g_usr[0] = 3; 
        fmax_g_usr[0] = (n_end_usr>>1)+2-2*genus_anf_usr;
        bmax_g_usr[1] = 2; 
        fmax_g_usr[1] = (n_end_usr>>1)+2-2*MAX(1,genus_anf_usr);
        bmax_g_usr[2] = 1;  
        fmax_g_usr[2] = (n_end_usr>>1)-2;
        break;
      }
      default: {
        for (i=0; i<=genus_end_usr; i++) {
          cmax_g_usr[i] = krit_max/3;
          bmax_g_usr[i] = genus_end_usr-i+1;
          fmax_g_usr[i] = (n_end_usr>>1)+2-2*MAX(i,genus_anf_usr);
        }
        break;
      }
    }
  }
  else {     /* keine Limits */
    for (i=0; i<=genus_end_usr; i++) { 
      fmax_g_usr[i] = (n_end_usr>>1)+2-2*MAX(i,genus_anf_usr);  
      bmax_g_usr[i] = genus_end_usr+1-i;
      cmax_g_usr[i] = krit_max;
    }
  }
  for (i=0; i<=genus_end_usr; i++) 
      {fmax_g[i] = fmax_g_usr[i];   bmax_g[i] = bmax_g_usr[i];
       cmax_g[i] = cmax_g_usr[i];}  /* vorerst */
} 

/********************GEHE_FACESTATBAUM_DURCH****************************/
/*  liest die Flaechenstatistik aus                                    */

void gehe_facestatbaum_durch(STATTREENODE *root,FLAECHENTYP *code,
                             KNOTENTYP len) {
  static KNOTENTYP f;
  while (root) {                         /* einen Level durchgehen */
    code[len] = root->code;  len++;
    if (root->zaehler) {
      for (f=0; f<len; f++) {
        sprintf(strpuf,"%d ",code[f]);
        logfile_entry(strpuf,False,False,False);
      }
      sprintf(strpuf,":  %d map%s\n",root->zaehler,
              root->zaehler==1 ? (char *)"" : (char *)"s");
      logfile_entry(strpuf,False,False,False);
    }
    if (root->nextlevel)
       {gehe_facestatbaum_durch(root->nextlevel,code,len);}
    root = root->next;  len--;
  }
}
    
/******************************MAIN*****************************************/

int main(int argc,char *argv[]) {
  int i,j,k;
#ifndef NOTIMES
  clock_t dummy, buffertime;
#endif //NOTIMES
  int prio;
  int l=0;                  /* >0 => l-ter Parameter ist expliziter Filename */
  KNOTENTYP f_max_bb;   /* Groesstmoegliche Flaechenzahl eines Patches, in dem
                           eine Bauchbinde am besten bewertet sein kann. */
  BOOL standardout = False;   /* True => Graphen mit hoechster Knotenzahl auf
                                 stdout ausgeben */
  BOOL standardout_all = False;  /* True => alle Graphen auf stdout ausgeben */
  BOOL unknown_option = False;  /* True => unbekannte Option entdeckt */
  BOOL double_option = False;   /* True => doppelte Option entdeckt */
  BOOL invalid_param = False;   /* True => ungueltiger Parameter entdeckt */
  BOOL patchstat = False;       /* True => entsprechende Option benutzt */
  int dela;                     /* fuer Option "delaney" */
  char filenamenteil[FILENAME_MAX];   /* gemeinsamer Teil aller Filenamen */
  char filenamenteil2[FILENAME_MAX];   /* so aehnlich */
  char *fileindex = nil;         /* fuer individuelle Filenamen */
  FILE *logfile,*f;  
  BOOL dummybool;
  KNOTENTYP facenum[MAXFTYPEN];  /* fuer bk_moeglich-Initialisierung */

  /* Wurden die Konstanten unzulaessig manipuliert? */
  if (N_MAX_P>KN_MAX)           /* N_MAX oder N_MAX_P wurde manipuliert */
    {fprintf(stderr,"Internal error: Constant N_MAX_P too high!\n"); exit(45);}
  if (F_MAX>FL_MAX || F_MAX>N_MAX_P)       /* F_MAX wurde manipuliert */
    {fprintf(stderr,"Internal error: Constant F_MAX too high!\n"); exit(46);}
  if (G_MAX>GEN_MAX)          /* G_MAX wurde manipuliert */
    {fprintf(stderr,"Internal error: Constant G_MAX too high!\n"); exit(47);}

  /* Argumente auswerten */
  if (argc<2) {
    fprintf(stderr,"Usage: see manual.\n");
    fprintf(stderr,"2004-06-20: New option -bigendian for big endian output.\n");
    exit(48);
  }
  for (i=1; i<argc; i++) {
    if (argv[i][0]!='-') {unknown_option = True;}
    else {
      switch (argv[i][1]) {
        case 'v': {
          if (strcmp(&argv[i][1],(char *)"v")==0) {     /* letzte Knotenzahl */
            if (v_used) {double_option = True;}
            else {
              i++;   v_used = True; 
              if (i<argc && isdigit(argv[i][0]))
                 {n_end_usr = n_end = atoi(argv[i]);}
              else {invalid_param = True;}
            }  
          }
          else if (strcmp(&argv[i][1],(char *)"vs")==0) {  /*erste Knotenzahl*/
            if (vs_used) {double_option = True;}
            else {
              i++;   vs_used = True; 
              if (i<argc && isdigit(argv[i][0]))
                 {n_anf_usr = n_anf = atoi(argv[i]);}
              else {invalid_param = True;}
            }  
          }
          else {unknown_option = True;}
          break;
        }
        case 'o': {
          if (strcmp(&argv[i][1],(char *)"output")==0) {
            if (output_used) {double_option = True;}
            else {
              i++;   output_used = True;
              if (i<argc) {
                if (strcmp(argv[i],(char *)"none")==0) {output = False;}
                else if (strcmp(argv[i],(char *)"stdout")==0) 
                        {standardout_all = True;}
                else if (strcmp(argv[i],(char *)"stdout_max")==0) 
                        {standardout = True;}
                else {invalid_param = True;}
              }
              else {invalid_param = True;}
            }
	  }
          else if (strcmp(&argv[i][1],(char *)"outputmem")==0) {
            if (outputmem_used) {double_option = True;}
            else {
              i++;   outputmem_used = True;
              if (i<argc && isdigit(argv[i][0])) {
                basis = atol(argv[i]);
                if (i+1<argc && isdigit(argv[i+1][0])) 
                   {i++;  zusatz = atol(argv[i]);}
              }
              else {invalid_param = True;}
            }
          }     
          else if (strcmp(&argv[i][1],(char *)"old_mod2")==0) {
            if (old_mod2_used) {double_option = True;}
            else { 
              i++;   old_mod2_used = True;
              if (i<argc && isdigit(argv[i][0])) {old_mod2 = atoi(argv[i]);}
              else {invalid_param = True;}
            }
          }
          else if (strcmp(&argv[i][1],(char *)"old_class2")==0) {
            if (old_class2_used) {double_option = True;}
            else { 
              i++;   old_class2_used = True;
              if (i<argc && isdigit(argv[i][0])) {old_class2 = atoi(argv[i]);}
              else {invalid_param = True;}
            }
          }
          else if (strcmp(&argv[i][1],(char *)"old_mod3")==0) {
            if (old_mod3_used) {double_option = True;}
            else { 
              i++;   old_mod3_used = True;
              if (i<argc && isdigit(argv[i][0])) {old_mod3 = atoi(argv[i]);}
              else {invalid_param = True;}
            }
          }
          else if (strcmp(&argv[i][1],(char *)"old_class3")==0) {
            if (old_class3_used) {double_option = True;}
            else { 
              i++;   old_class3_used = True;
              if (i<argc && isdigit(argv[i][0])) {old_class3 = atoi(argv[i]);}
              else {invalid_param = True;}
            }
          }
          else if (strcmp(&argv[i][1],(char *)"old_mod4")==0) {
            if (old_mod4_used) {double_option = True;}
            else { 
              i++;   old_mod4_used = True;
              if (i<argc && isdigit(argv[i][0])) {old_mod4 = atoi(argv[i]);}
              else {invalid_param = True;}
            }
          }
          else if (strcmp(&argv[i][1],(char *)"old_class4")==0) {
            if (old_class4_used) {double_option = True;}
            else { 
              i++;   old_class4_used = True;
              if (i<argc && isdigit(argv[i][0])) {old_class4 = atoi(argv[i]);}
              else {invalid_param = True;}
            }
          }
          else if (strcmp(&argv[i][1],(char *)"old_mod5")==0) {
            if (old_mod5_used) {double_option = True;}
            else { 
              i++;   old_mod5_used = True;
              if (i<argc && isdigit(argv[i][0])) {old_mod5 = atoi(argv[i]);}
              else {invalid_param = True;}
            }
          }
          else if (strcmp(&argv[i][1],(char *)"old_class5")==0) {
            if (old_class5_used) {double_option = True;}
            else { 
              i++;   old_class5_used = True;
              if (i<argc && isdigit(argv[i][0])) {old_class5 = atoi(argv[i]);}
              else {invalid_param = True;}
            }
          }
          else if (strcmp(&argv[i][1],(char *)"old_mod6")==0) {
            if (old_mod6_used) {double_option = True;}
            else { 
              i++;   old_mod6_used = True;
              if (i<argc && isdigit(argv[i][0])) {old_mod6 = atoi(argv[i]);}
              else {invalid_param = True;}
            }
          }
          else if (strcmp(&argv[i][1],(char *)"old_class6")==0) {
            if (old_class6_used) {double_option = True;}
            else { 
              i++;   old_class6_used = True;
              if (i<argc && isdigit(argv[i][0])) {old_class6 = atoi(argv[i]);}
              else {invalid_param = True;}
            }
          }
          else {unknown_option = True;}
          break;
        }
        case 'g': {
          if (strcmp(&argv[i][1],(char *)"g")==0) {    /* Maximalgeschlecht */ 
            if (g_used) {double_option = True;}
            else {
              i++;   g_used = True;
              if (i<argc && isdigit(argv[i][0]))
                 {genus_end_usr = genus_end = atoi(argv[i]);}
              else {invalid_param = True;}
            }
          }   
          else if (strcmp(&argv[i][1],(char *)"gs")==0) {  
            if (gs_used) {double_option = True;}
            else {
              i++;   gs_used = True;
              if (i<argc && isdigit(argv[i][0]))
                 {genus_anf_usr = genus_anf = atoi(argv[i]);}
              else {invalid_param = True;}
            }
          }   
          else {unknown_option = True;}
          break;
        }
        case 'n': {
          if (strcmp(&argv[i][1],(char *)"no_recover")==0) {  
            if (no_recover_used) {double_option = True;}
            else {no_recover_used = True;  recover = False;}
	  }
          else {unknown_option = True;}
          break;
        }
        case 'b': {
          if (strcmp(&argv[i][1],(char *)"bigendian")==0) {  
            if (bigendian_used) {double_option = True;}
            else {bigendian_used = True;  bigendian = True;}
	  }
          else {unknown_option = True;}
          break;
        }
        case 'm': {
          if (strcmp(&argv[i][1],(char *)"mapcon")==0) {
            if (mapcon_used) {double_option = True;}
            else {
              i++;   mapcon_used = True;   do_conn = True;
              if (i<argc) {
                if (strcmp(argv[i],(char *)"3")==0)
                   {conn1 = conn2 = False;}
                else if (strcmp(argv[i],(char *)"2")==0)
                   {conn1 = conn3 = False;}
                else if (strcmp(argv[i],(char *)"1")==0)
                   {conn2 = conn3 = False;}
                else if (strcmp(argv[i],(char *)"12")==0)
                   {conn3 = False;}
                else if (strcmp(argv[i],(char *)"13")==0)
                   {conn2 = False;}
                else if (strcmp(argv[i],(char *)"23")==0)
                   {conn1 = False;}
                else if (strcmp(argv[i],(char *)"123")!=0)
                   {invalid_param = True;}
              }
              else {invalid_param = True;}
            }
          }
          else if (strcmp(&argv[i][1],(char *)"mapstat")==0) {
            if (mapstat_used) {double_option = True;}
            else {graphstat = mapstat_used = True;}
          }
          else if (strcmp(&argv[i][1],(char *)"mdeza1")==0) {
            if (mdeza1_used) {double_option = True;}
            else {mdeza1_used = True;}
          }
          else if (strcmp(&argv[i][1],(char *)"memory")==0) {
            if (memory_used) {double_option = True;}
            else {
              i++;  memory_used = True;
              if (i<argc && isdigit(argv[i][0])) {mem_max = atol(argv[i]);}
              else {invalid_param = True;}
            }
          }
          else if (strcmp(&argv[i][1],(char *)"mod")==0) {
            if (mod_used) {double_option = True;}
            else { 
              i++;   mod_used = True;
              if (i<argc && isdigit(argv[i][0])) {mod = atoi(argv[i]);}
              else {invalid_param = True;}
            }
          }
          else if (strcmp(&argv[i][1],(char *)"mod2")==0) {
            if (mod2_used) {double_option = True;}
            else { 
              i++;   mod2_used = True;
              if (i<argc && isdigit(argv[i][0])) {mod2 = atoi(argv[i]);}
              else {invalid_param = True;}
            }
          }
          else if (strcmp(&argv[i][1],(char *)"mod3")==0) {
            if (mod3_used) {double_option = True;}
            else { 
              i++;   mod3_used = True;
              if (i<argc && isdigit(argv[i][0])) {mod3 = atoi(argv[i]);}
              else {invalid_param = True;}
            }
          }
          else if (strcmp(&argv[i][1],(char *)"mod4")==0) {
            if (mod4_used) {double_option = True;}
            else { 
              i++;   mod4_used = True;
              if (i<argc && isdigit(argv[i][0])) {mod4 = atoi(argv[i]);}
              else {invalid_param = True;}
            }
          }
          else if (strcmp(&argv[i][1],(char *)"mod5")==0) {
            if (mod5_used) {double_option = True;}
            else { 
              i++;   mod5_used = True;
              if (i<argc && isdigit(argv[i][0])) {mod5 = atoi(argv[i]);}
              else {invalid_param = True;}
            }
          }
          else if (strcmp(&argv[i][1],(char *)"mod6")==0) {
            if (mod6_used) {double_option = True;}
            else { 
              i++;   mod6_used = True;
              if (i<argc && isdigit(argv[i][0])) {mod6 = atoi(argv[i]);}
              else {invalid_param = True;}
            }
          }
          else {unknown_option = True;}
          break;
        }
        case 'f': {
          if (strcmp(&argv[i][1],(char *)"f")==0) {        /* Flaechentyp */
            i++;  f_used = True;                       /* Dopplung moeglich */
            if (anz_face<MAXFTYPEN) { 
              if (i<argc && isdigit(argv[i][0])) {
                face[anz_face]=atoi(argv[i]);
                if (delaney) {  /* naechste Zahl gibt Zugehoerigkeit zu den
                                   Mengen an */
                  if (++i<argc) {
                    switch(dela = atoi(argv[i])) {
      	  	      case 1:   {dela_set[face[anz_face]] = 1;  break;}
  	  	      case 2:   {dela_set[face[anz_face]] = 2;  break;}
  	  	      case 3:   {dela_set[face[anz_face]] = 4;  break;}
  	  	      case 12:  {dela_set[face[anz_face]] = 3;  break;}
  	  	      case 21:  {dela_set[face[anz_face]] = 3;  break;}
  	  	      case 13:  {dela_set[face[anz_face]] = 5;  break;}
  	  	      case 31:  {dela_set[face[anz_face]] = 5;  break;}
  	  	      case 23:  {dela_set[face[anz_face]] = 6;  break;}
  	  	      case 32:  {dela_set[face[anz_face]] = 6;  break;}
  	  	      case 123: {dela_set[face[anz_face]] = 7;  break;}
  	  	      case 132: {dela_set[face[anz_face]] = 7;  break;}
  	  	      case 213: {dela_set[face[anz_face]] = 7;  break;}
  	  	      case 231: {dela_set[face[anz_face]] = 7;  break;}
  	  	      case 312: {dela_set[face[anz_face]] = 7;  break;}
  	  	      case 321: {dela_set[face[anz_face]] = 7;  break;}
                      default:  {invalid_param = True;}
		    }
  	          }
                  else {invalid_param = True;}
                }
                facenum_max[anz_face] = facenum_max_usr[anz_face] = F_MAXANZ;
                facenum_min[anz_face] = facenum_min_usr[anz_face] = 0;  
                 /* falls facenumbers==True durch eine andere Flaeche oder 
                    durch "facestat" und fuer die korrekte Erstellung des 
                    Filenamens erforderlich */
                if (i+1<argc && argv[i+1][0]!='-') {   /* Intervall einlesen */
                  char *pos,*oldpos;
                  long num;
                  facenumbers = facerestrict = True;
                  i++;
                  if (argv[i][0]=='[' || argv[i][0]=='l') {
                    pos = &argv[i][1];
                    num = strtol(pos,&pos,10);
                    if (pos > &argv[i][1]) {                 
                      facenum_min_usr[anz_face] = facenum_min[anz_face] =
                                                  (KNOTENTYP)num;
                      oldpos = pos;
                      if (*pos==',' || *pos==';' || *pos=='-') { 
                        /* Intervallende folgt */
                        pos++;  oldpos = pos;
                        num = strtol(pos,&pos,10);
                        if (pos > oldpos && (*pos==']' || *pos=='u'))
			   {facenum_max_usr[anz_face] = facenum_max[anz_face] =
                                                        (KNOTENTYP)num;}
                        else {invalid_param = True;}
                      }
                      else if (*pos) {invalid_param = True;}
                    }
                    else {invalid_param = True;}
                  }
                  else if (isdigit(argv[i][0])) {
                    pos = &argv[i][0];
                    num = strtol(pos,&pos,10);
                    if (pos > &argv[i][0] && (*pos==']' || *pos=='u'))
		       {facenum_max[anz_face] = facenum_max_usr[anz_face] = 
                                                (KNOTENTYP)num;}
                    else {invalid_param = True;}
                  }
                  else {invalid_param = True;}
                }    /* if Intervall einlesen */
                anz_face++;
              }
              else {invalid_param = True;}
            }
            else {
              fprintf(stderr,"Error: Number of face types exceeds maximum "
                             "%d!\n",MAXFTYPEN); exit(49);
            }
          }
          else if (strcmp(&argv[i][1],(char *)"fileindex")==0) { 
            if (fileindex_used) {double_option = True;}
            else {
              i++;  fileindex_used = True;
              if (i<argc && argv[i][0]!='-') {fileindex = argv[i];}
              else {invalid_param = True;}
            }
          }
          else if (strcmp(&argv[i][1],(char *)"facestat")==0) {
            if (facestat_used) {double_option = True;}
            else {facestat_used = facestat = facenumbers = True;}
            /* Flaechenstatistik erstellen => Flaechenzahlen speichern */  
	  }
          else if (strcmp(&argv[i][1],(char *)"facecon")==0) {
            if (facecon_used) {double_option = True;}
            else {
              i++;  facecon_used = True;
              if (i<argc && isdigit(argv[i][0])) {
                if (strcmp(argv[i],(char *)"3")==0)
		   {facecon1 = facecon2 = False;}
                else if (strcmp(argv[i],(char *)"23")==0)
	                {facecon1 = False;}
                else if (strcmp(argv[i],(char *)"123")!=0)
		        {invalid_param = True;}
              }
            }
          }
          else {unknown_option = True;}
          break;
        }              /* case f */
        case 'p': {    /* Flaeche, an der jeder Pfad liegen muss */
         if (strcmp(&argv[i][1],(char *)"pv")==0) {
            if (pv_used) {double_option = True;}
            else {
              i++;  pv_used = True; 
              if (i<argc && isdigit(argv[i][0])) {pv = (char)atoi(argv[i]);}
              else {invalid_param = True;}
            }
          } 
          else if (strcmp(&argv[i][1],(char *)"patchstat")==0) {
            if (patchstat_used) {double_option = True;}
            else {patchstat_used = patchstat = True;}
          }
          else if (strcmp(&argv[i][1],(char *)"patchcheck")==0) {
            if (patchcheck_used) {double_option = True;}
            else {patchcheck_used = patchcheck = True;}
          }
          else if (strcmp(&argv[i][1],(char *)"pid")==0) {
            if (pid_used) {double_option = True;}
            else {fprintf(stdout,"%d\n",getpid());  fflush(stdout);}
          }
          else if (strcmp(&argv[i][1],(char *)"priority")==0) {
            if (priority_used) {double_option = True;}
            else {
              i++;  priority_used = True;
              if (i<argc) {
                prio = atoi(argv[i]);
                if (strcmp(argv[i],(char *)"123")==0)
  	           {bauchbindenkennung=1;  sandwichkennung=2;
                    brillenkennung=3;}
                else if (strcmp(argv[i],(char *)"132")==0)
  	           {bauchbindenkennung=1;  sandwichkennung=3;
                    brillenkennung=2;}
                else if (strcmp(argv[i],(char *)"213")==0)
  	           {bauchbindenkennung=2;  sandwichkennung=1;
                    brillenkennung=3;}
                else if (strcmp(argv[i],(char *)"231")==0)
  	           {bauchbindenkennung=3;  sandwichkennung=1;
                    brillenkennung=2;}
                else if (strcmp(argv[i],(char *)"312")==0)
  	           {bauchbindenkennung=2;  sandwichkennung=3;
                    brillenkennung=1;}
                else if (strcmp(argv[i],(char *)"321")==0)
  	           {bauchbindenkennung=3;  sandwichkennung=2;
                    brillenkennung=1;}
                else {invalid_param = True;}
	      }
            }
          }
          else if (strcmp(&argv[i][1],(char *)"patchcon")==0) {
            if (patchcon_used) {double_option = True;}
            else {patchcon_used = patchconn = True;}
          }
          else {unknown_option = True;}
          break;
        }          
        case 'a': {    /* Alternative Patcherzeugung ohne kritische Flaeche */
          if (strcmp(&argv[i][1],(char *)"alt")==0) {
            if (alt_used) {double_option = True;}
            else if (td_limits)
              {fprintf(stderr,"Error using option 'alt': Option keyword must "
                       "occur before\ndefining topdown limits using option "
                       "'td_limits'!\n");  exit(96);}
            else {alt_used = alternative = True;}
          }
          else {unknown_option = True;}
          break;
        }
        case 'd': {    /* Duale Ausgabe => Triangulierungen */
          if (strcmp(&argv[i][1],(char *)"dual")==0) {
            if (dual_used) {double_option = True;}
            else {dual_used = dual = True;}
          }
          else if (strcmp(&argv[i][1],(char *)"db")==0) {
            if (db_used) {double_option = True;}
            else {db_used = doppelkanten = True;}
          }
          else if (strcmp(&argv[i][1],(char *)"digon_path")==0) {
            if (digon_path_used) {double_option = True;}
            else {digon_path_used = digon_path = True;
                  do_bauchbinde = False;}   /* weil sonst die Einschraenkung,
                  dass kein Patch alle Zweiecke besitzen darf, nicht moeglich
                  waere */
          }
          else if (strcmp(&argv[i][1],(char *)"delaney")==0) {
            if (delaney_used) {double_option = True;}
            else {
              if (f_used) {fprintf(stderr,"Error using option 'delaney': "
                           "Option keyword must occur before\ndefining face "
                           "degrees using option 'f'!\n");  exit(50);}
              delaney_used = delaney = True;
            }
          }
          else {unknown_option = True;}
          break;
        }
        case 'l': {    /* eigener Name fuer das Logfile */
          if (strcmp(&argv[i][1],(char *)"logfilename")==0) {
            if (logfilename_used) {double_option = True;}
            else {
              i++;  logfilename_used = True;
              if (i<argc && strlen(argv[i])<=FILENAME_MAX) {l=i;}
              else {invalid_param = True;}
            }
          }
          else if (strcmp(&argv[i][1],(char *)"level")==0) {
            if (level_used) {double_option = True;}
            else {
              i++;  level_used = True;
              if (i<argc && isdigit(argv[i][0])) {level = atoi(argv[i]);}
              else {invalid_param = True;}
            }
          }
          else if (strcmp(&argv[i][1],(char *)"level2")==0) {
            if (level2_used) {double_option = True;}
            else {
              i++;  level2_used = True;
              if (i<argc && isdigit(argv[i][0])) {level2 = atoi(argv[i]);}
              else {invalid_param = True;}
            }
          }
          else if (strcmp(&argv[i][1],(char *)"level3")==0) {
            if (level3_used) {double_option = True;}
            else {
              i++;  level3_used = True;
              if (i<argc && isdigit(argv[i][0])) {level3 = atoi(argv[i]);}
              else {invalid_param = True;}
            }
          }
          else if (strcmp(&argv[i][1],(char *)"level4")==0) {
            if (level4_used) {double_option = True;}
            else {
              i++;  level4_used = True;
              if (i<argc && isdigit(argv[i][0])) {level4 = atoi(argv[i]);}
              else {invalid_param = True;}
            }
          }
          else if (strcmp(&argv[i][1],(char *)"level5")==0) {
            if (level5_used) {double_option = True;}
            else {
              i++;  level5_used = True;
              if (i<argc && isdigit(argv[i][0])) {level5 = atoi(argv[i]);}
              else {invalid_param = True;}
            }
          }
          else if (strcmp(&argv[i][1],(char *)"level6")==0) {
            if (level6_used) {double_option = True;}
            else {
              i++;  level6_used = True;
              if (i<argc && isdigit(argv[i][0])) {level6 = atoi(argv[i]);}
              else {invalid_param = True;}
            }
          }
          else if (strcmp(&argv[i][1],(char *)"lazydump")==0) {
            if (lazydump_used) {double_option = True;}
            else {lazydump_used = True;}
          }
          else if (strcmp(&argv[i][1],(char *)"logfile")==0) {
            if (logfile_used) {double_option = True;}
            else {
              i++;  logfile_used = True;
              if (i<argc) {
                if (strcmp(argv[i],(char *)"none")==0) 
                   {logfile_out = stderr_out = False;}
                else if (strcmp(argv[i],(char *)"stderr")==0) 
                   {logfile_out = False;}
                else if (strcmp(argv[i],(char *)"file")==0) 
                   {stderr_out = False;}
                else if (strcmp(argv[i],(char *)"both")!=0) 
                   {invalid_param = True;}
              }
              else {invalid_param = True;} 
            }
          }
          else {unknown_option = True;}    
          break;
        }
        case 's': {
          if (strcmp(&argv[i][1],(char *)"save")==0) {
            if (save_used) {double_option = True;}
            else {
              i++;  save_used = True;
              if (i<argc && isdigit(argv[i][0])) {
                S_intervall = atoi(argv[i]);  
                if (S_intervall<=0) {save = False;}
              }
              else {invalid_param = True;}
            }
          }
          else if (strcmp(&argv[i][1],(char *)"shortfilename")==0) {
            if (shortfilename_used) {double_option = True;}
            else {shortfilename_used = True;}
          }
          else {unknown_option = True;}
          break;
        }
        case 't': {
          if (strcmp(&argv[i][1],(char *)"topdown")==0) {
            if (topdown_used) {double_option = True;}
            else {topdown_used = topdown = True;}
          }
          else if (strcmp(&argv[i][1],(char *)"td_limits")==0) {
            if (td_limits_used) {double_option = True;}
            else {
              KNOTENTYP j;
              if (!g_used) {fprintf(stderr,"Error using option 'td_limits': "
                           "Option keyword must occur after\ndefining the "
                           "maximum genus using option 'g'!\n");  exit(51);}
              i++;  topdown = td_limits_used = True;
              if (i<argc) {
                if (strcmp(argv[i],(char *)"auto")==0) {td_limits_auto = True;}
                else {
                  td_limits = True;
                  if (!alternative) {   /* kritische Summen bestimmen */
                    if (strcmp(argv[i],(char *)"c")==0) { /*=> "concave sum" */
                      for (j=0; !invalid_param && j<=genus_end_usr; j++) {
                        i++;
                        if (i<argc && isdigit(argv[i][0])) 
                           {cmax_g_usr[j] = atoi(argv[i]);}
                        else {invalid_param = True;}
                      }
                    }
                    else {invalid_param = True;} 
                    if (!invalid_param) {i++;}
                  }
                  else {for (j=0; j<=genus_end_usr; j++) {cmax_g_usr[j] = 0;} }
                  if (!invalid_param && strcmp(argv[i],(char *)"f")==0) {
                    for (j=0; !invalid_param && j<=genus_end_usr; j++) {
                      i++;
                      if (i<argc && isdigit(argv[i][0])) 
                         {fmax_g_usr[j] = atoi(argv[i]);}
                      else {invalid_param = True;}
                    }
                  }
                  else {invalid_param = True;} 
                  if (!invalid_param) {
                    i++;
                    if (i<argc && strcmp(argv[i],(char *)"b")==0) {
                      for (j=0; !invalid_param && j<=genus_end_usr; j++) {
                        i++;
                        if (i<argc && isdigit(argv[i][0])) 
                           {bmax_g_usr[j] = atoi(argv[i]);}
                        else {invalid_param = True;}
                      }
                    }
                    else {invalid_param = True;} 
                  }
                }
              }
            }
          }
          else if (strcmp(&argv[i][1],(char *)"types")==0) {
            if (types_used) {double_option = True;}
            else {
              i++;  types_used = True;
              if (i<argc) {
                if (strcmp(argv[i],(char *)"1")==0) 
                   {do_sandwich = do_brille = False;}
                else if (strcmp(argv[i],(char *)"2")==0) 
                   {do_bauchbinde = do_brille = False;}
                else if (strcmp(argv[i],(char *)"3")==0) 
                   {do_bauchbinde = do_sandwich = False;}
                else if (strcmp(argv[i],(char *)"12")==0) 
                   {do_brille = False;}
                else if (strcmp(argv[i],(char *)"23")==0) 
                   {do_bauchbinde = False;}
                else if (strcmp(argv[i],(char *)"13")==0) 
                   {do_sandwich = False;}
                else if (strcmp(argv[i],(char *)"123")!=0) 
                   {invalid_param = True;}
              }
              else {invalid_param = True;}
            }  
          }
          else {unknown_option = True;}    
          break;
        }
        case 'c': {
          if (strcmp(&argv[i][1],(char *)"class")==0) {
            if (class_used) {double_option = True;}
            else { 
              i++;   class_used = True;
              if (i<argc && isdigit(argv[i][0])) {class = atoi(argv[i]);}
              else {invalid_param = True;}
            }
          }
          else if (strcmp(&argv[i][1],(char *)"class2")==0) {
            if (class2_used) {double_option = True;}
            else { 
              i++;   class2_used = True;
              if (i<argc && isdigit(argv[i][0])) {class2 = atoi(argv[i]);}
              else {invalid_param = True;}
            }
          }
          else if (strcmp(&argv[i][1],(char *)"class3")==0) {
            if (class3_used) {double_option = True;}
            else { 
              i++;   class3_used = True;
              if (i<argc && isdigit(argv[i][0])) {class3 = atoi(argv[i]);}
              else {invalid_param = True;}
            }
          }
          else if (strcmp(&argv[i][1],(char *)"class4")==0) {
            if (class4_used) {double_option = True;}
            else { 
              i++;   class4_used = True;
              if (i<argc && isdigit(argv[i][0])) {class4 = atoi(argv[i]);}
              else {invalid_param = True;}
            }
          }
          else if (strcmp(&argv[i][1],(char *)"class5")==0) {
            if (class5_used) {double_option = True;}
            else { 
              i++;   class5_used = True;
              if (i<argc && isdigit(argv[i][0])) {class5 = atoi(argv[i]);}
              else {invalid_param = True;}
            }
          }
          else if (strcmp(&argv[i][1],(char *)"class6")==0) {
            if (class6_used) {double_option = True;}
            else { 
              i++;   class6_used = True;
              if (i<argc && isdigit(argv[i][0])) {class6 = atoi(argv[i]);}
              else {invalid_param = True;}
            }
          }
          else if (strcmp(&argv[i][1],(char *)"comp4")==0) {
            if (comp4_used) {double_option = True;}
            else {comp4_used = comp4 = True;}
          }
          else {unknown_option = True;}
          break;
        }
        default: {unknown_option = True; break;}
      }     /* switch */
    }       /* else */
    if (unknown_option) {fprintf(stderr,"Error: Unknown option '%s'!\n",
                         argv[i]);  exit(52);}
    if (invalid_param)  {fprintf(stderr,"Error: Parameter no.%d (`%s') is "
                         "invalid!\n",i,i<argc ? argv[i] : 
                         (char *)"--missing--");  exit(53);}
    if (double_option)  {fprintf(stderr,"Error: Option '%s' used twice!\n",
                         argv[i]);  exit(54);}   /* Abbruch, um den Benutzer
                     auf einen moeglichen Eingabefehler aufmerksam zu machen */
  }       /* for */

#ifdef NOTIMES
  save = False;
#endif //NOTIMES

  /* Argumente ueberpruefen */
  if (!gs_used) {genus_anf = genus_anf_usr = genus_end;}
  if (!g_used)  {fprintf(stderr,"Error: Missing option 'g'!\n"); exit(55);}
  if (genus_anf>genus_end) {fprintf(stderr,"Error: Genus to start is bigger" 
                                    " than genus to end!\n"); exit(56);}
  if (genus_end>G_MAX)
     {fprintf(stderr,"Error: Maximum genus is too big (maximum %d)!\n",
              G_MAX); exit(57);}

  if (!vs_used) {n_anf = n_anf_usr = n_end;}
  if (!v_used) {fprintf(stderr,"Error: Missing option 'v'!\n");  exit(58);}
  if (n_anf>n_end) {fprintf(stderr,"Error: Vertex number to start is bigger"
                            " than vertex number to end!\n"); exit(59);}
  if (n_end%2 || n_anf%2) 
     {fprintf(stderr,"Error: Vertex number is odd!\n"); exit(60);}
  if ((EULERTYP)n_anf<MAX(2,4*(EULERTYP)genus_anf-2))
     {fprintf(stderr,"Error: Vertex number to start is too small\n");
      exit(61);}

  if (!f_used) {fprintf(stderr,"Error: No face types specified!\n"); exit(62);}
  if (anz_face>12 && !fileindex && (logfile_out || output)) {
    fprintf(stderr,"Error: Filename cannot contain all allowed face sizes!\n"
                   "Use a file index to unify the filename...\n");
    exit(63);
  }
  sortiere_flaechen();

  if (level_used) {
    if (topdown) 
       {fprintf(stderr,"Error: Option 'level' cannot be used in "
                       "topdown mode!\n");  exit(181);}
    else {
      if (pv<10)   {fprintf(stderr,"Error: Option 'level' can only be used in "
                                   "recursive mode!\n");  exit(65);}
      if (!class_used) {fprintf(stderr,"Missing class-parameter!\n"); 
                        exit(66);}
    }
  }
  if (class_used) {
    if (!mod_used) {fprintf(stderr,"Missing mod-parameter!\n"); exit(67);}
  }
  if (mod_used) {
    if (mod<1)    {fprintf(stderr,"Invalid mod-parameter!\n"); exit(68);}
    if (!class_used) {fprintf(stderr,"Missing class-parameter!\n"); exit(69);}
  }
  if (class2_used) {
    if (!mod2_used) {fprintf(stderr,"Missing mod2-parameter!\n"); exit(117);}
  }
  if (mod2_used) {
    if (mod2<1)    {fprintf(stderr,"Invalid mod2-parameter!\n"); exit(118);}
    if (!class2_used) {fprintf(stderr,"Missing class2-parameter!\n");  
                       exit(119);}
    if (topdown && !td_limits_used) {fprintf(stderr,"Error: Option 'td_limits'"
        "MUST be used when using option 'mod2'!\n"); exit(120);} 
       /* Um einen Einheitlichen Stammpatch-Vorrat zu sichern.
          Das ist nicht noetig, wenn nur mod_used, aber nicht
          modx_used benutzt wird, denn im obersten Level ist die Liste der
          Stammpatches unerheblich. */
    if (!topdown) {fprintf(stderr,"Error: Option 'mod2' can only be used in "
                           "topdown mode!\n");  exit(121);}
  }
  if (level2_used) {
    if (topdown) {
      if (!class2_used) {fprintf(stderr,"Error: Missing class2-parameter!\n");
                         exit(178);}
      if (level2<1)  {fprintf(stderr,"Error: Invalid level2-parameter!\n");
                      exit(179);}
    }
    else {fprintf(stderr,"Error: Option 'level2' can only be used in "
                                   "topdown mode!\n");  exit(177);}
  } 
  if (old_class2_used || old_mod2_used) {
    alias = True;
    if (!topdown) {fprintf(stderr,"Error: Option 'old_mod2' can only be used"
                   " in topdown mode!\n");  exit(124);}
    if (!mod2_used) {fprintf(stderr,"Error: Option 'mod2' must be used when"
                     " using option 'old_mod2'!\n"); exit(125);}
    if (old_mod2 && !old_class2_used) 
       {fprintf(stderr,"Missing old_class2-parameter!\n");  exit(126);}
    if (!old_mod2_used) {fprintf(stderr,"Missing old_mod2-parameter!\n");
                         exit(127);}
    if (!old_mod2 && old_class2_used) {fprintf(stderr,"Option 'old_class2' can"
        " only be used when setting old_mod2>0!\n");  exit(219);}
    if (old_mod2 && (mod2%old_mod2)) 
       {fprintf(stderr,"Error: mod2-parameter must be a"
                       " multiple of old_mod2-parameter!\n");  exit(128);}
    if (old_mod2 && ((class2-old_class2)%old_mod2)) 
       {fprintf(stderr,"Error: The difference"
        " between the class2-parameter and the old_class2-parameter must be a"
        " multiple of the old_mod2-parameter!\n"); exit(129);}
    if (mod3_used || mod4_used || mod5_used || mod6_used) 
       {fprintf(stderr,"Error: Option 'old_mod2' cannot be used when using"
        " option 'mod3', 'mod4', 'mod5', or 'mod6'!\n");  exit(158);}
  }
  if (class3_used) {
    if (!mod3_used) {fprintf(stderr,"Missing mod3-parameter!\n"); exit(140);}
  }
  if (mod3_used) {
    if (mod3<1)    {fprintf(stderr,"Invalid mod3-parameter!\n"); exit(141);}
    if (!class3_used) {fprintf(stderr,"Missing class3-parameter!\n"); 
                       exit(142);}
    if (topdown && !td_limits_used) {fprintf(stderr,"Error: Option 'td_limits'"
        "MUST be used when using option 'mod3' in topdown mode!\n");
        exit(129);}  /* um einen Einheitlichen Stammpatch-Vorrat zu sichern */
    if (!topdown) {fprintf(stderr,"Error: Option 'mod3' can only be used in "
                           "topdown mode!\n");  exit(130);}
/*  if (do_bauchbinde) {fprintf(stderr,"Error: Option 'mod3' must not be used "
                        "when type-1-maps are allowed!\n"); exit(138);}*/
    if (mod2_used && level3<=level2) 
       {fprintf(stderr,"Error: Invalid level3-parameter!\n");  exit(126);}
  }
  if (level3_used) {
    if (topdown) {
      if (!class3_used) {fprintf(stderr,"Error: Missing class3-parameter!\n");
                         exit(125);}
    }
    else {fprintf(stderr,"Error: Option 'level3' can only be used in "
                                   "topdown mode!\n");  exit(124);}
  } 
  if (old_class3_used || old_mod3_used) {
    alias2 = True;
    if (!topdown) {fprintf(stderr,"Error: Option 'old_mod3' can only be used"
                   " in topdown mode!\n");  exit(132);}
    if (!mod3_used) {fprintf(stderr,"Error: Option 'mod3' must be used when"
                     " using option 'old_mod3'!\n"); exit(133);}
    if (old_mod3 && !old_class3_used) 
       {fprintf(stderr,"Missing old_class3-parameter!\n"); exit(134);}
    if (!old_mod3_used) {fprintf(stderr,"Missing old_mod3-parameter!\n");
                         exit(135);}
    if (!old_mod3 && old_class3_used) {fprintf(stderr,"Option 'old_class3' can"
        " only be used when setting old_mod3>0!\n");  exit(220);}
    if (old_mod3 && (mod3%old_mod3)) 
       {fprintf(stderr,"Error: mod3-parameter must be a"
                       " multiple of old_mod3-parameter!\n");  exit(136);}
    if (old_mod3 && (class3-old_class3)%old_mod3) 
       {fprintf(stderr,"Error: The difference"
        " between the class3-parameter and the old_class3-parameter must be a"
        " multiple of the old_mod3-parameter!\n"); exit(137);}
    if (old_mod2_used || old_class2_used) 
       {fprintf(stderr,"Error: The options 'old_mod3' and 'old_mod2' must not"
                " be used simultaneously!\n");  exit(139);}
    if (mod4_used || mod5_used || mod6_used) 
       {fprintf(stderr,"Error: Option 'old_mod3' cannot be used when using"
        " option 'mod4', 'mod5', or 'mod6'!\n");  exit(159);}
  }
  if (class4_used) {
    if (!mod4_used) {fprintf(stderr,"Missing mod4-parameter!\n"); exit(143);}
  }
  if (mod4_used) {
    if (mod4<1)    {fprintf(stderr,"Invalid mod4-parameter!\n"); exit(144);}
    if (!class4_used) {fprintf(stderr,"Missing class4-parameter!\n"); 
                       exit(145);}
    if (topdown && !td_limits_used) {fprintf(stderr,"Error: Option 'td_limits'"
        "MUST be used when using option 'mod4' in topdown mode!\n");
        exit(146);}  /* um einen Einheitlichen Stammpatch-Vorrat zu sichern */
    if (!topdown) {fprintf(stderr,"Error: Option 'mod4' can only be used in "
                           "topdown mode!\n");  exit(147);}
/*  if (do_bauchbinde) {fprintf(stderr,"Error: Option 'mod4' must not be used "
                        "when type-1-maps are allowed!\n"); exit(148);}*/
    if (mod3_used && level4<=level3) 
       {fprintf(stderr,"Error: Invalid level4-parameter!\n");  exit(150);}
    if (mod2_used && level4<=level2) 
       {fprintf(stderr,"Error: Invalid level4-parameter!\n");  exit(180);}
  }
  if (level4_used) {
    if (topdown) {
      if (!class4_used) {fprintf(stderr,"Error: Missing class4-parameter!\n");
                         exit(149);}
    }
    else {fprintf(stderr,"Error: Option 'level4' can only be used in "
                                   "topdown mode!\n");  exit(151);}
  } 
  if (old_class4_used || old_mod4_used) {
    alias3 = True;
    if (!topdown) {fprintf(stderr,"Error: Option 'old_mod4' can only be used"
                   " in topdown mode!\n");  exit(151);}
    if (!mod4_used) {fprintf(stderr,"Error: Option 'mod4' must be used when"
                     " using option 'old_mod4'!\n"); exit(152);}
    if (old_mod4 && !old_class4_used) 
       {fprintf(stderr,"Missing old_class4-parameter!\n"); exit(153);}
    if (!old_mod4_used) {fprintf(stderr,"Missing old_mod4-parameter!\n");
                         exit(154);}
    if (!old_mod4 && old_class4_used) {fprintf(stderr,"Option 'old_class4' can"
        " only be used when setting old_mod4>0!\n");  exit(221);}
    if (old_mod4 && (mod4%old_mod4)) 
       {fprintf(stderr,"Error: mod4-parameter must be a"
                       " multiple of old_mod4-parameter!\n");  exit(155);}
    if (old_mod4 && (class4-old_class4)%old_mod4) 
       {fprintf(stderr,"Error: The difference"
        " between the class4-parameter and the old_class4-parameter must be a"
        " multiple of the old_mod4-parameter!\n"); exit(156);}
    if (old_mod2_used || old_class2_used || old_mod3_used || old_class3_used) 
       {fprintf(stderr,"Error: The options 'old_mod4' and 'old_mod2' or "
                "'old_mod3' must not be used simultaneously!\n");  exit(157);}
    if (mod5_used || mod6_used) 
       {fprintf(stderr,"Error: Option 'old_mod4' cannot be used when using"
        " option 'mod5' or 'mod6'!\n");  exit(224);}
  }
  if (class5_used) {
    if (!mod5_used) {fprintf(stderr,"Missing mod5-parameter!\n"); exit(182);}
  }
  if (mod5_used) {
    if (mod5<1)    {fprintf(stderr,"Invalid mod5-parameter!\n"); exit(183);}
    if (!class5_used) {fprintf(stderr,"Missing class5-parameter!\n"); 
                       exit(184);}
    if (topdown && !td_limits_used) {fprintf(stderr,"Error: Option 'td_limits'"
        "MUST be used when using option 'mod5' in topdown mode!\n");
        exit(185);}  /* um einen Einheitlichen Stammpatch-Vorrat zu sichern */
    if (!topdown) {fprintf(stderr,"Error: Option 'mod5' can only be used in "
                           "topdown mode!\n");  exit(186);}
/*  if (do_bauchbinde) {fprintf(stderr,"Error: Option 'mod5' must not be used "
                        "when type-1-maps are allowed!\n"); exit(187);}*/
    if (mod4_used && level5<=level4) 
       {fprintf(stderr,"Error: Invalid level5-parameter!\n");  exit(188);}
    if (mod3_used && level5<=level3) 
       {fprintf(stderr,"Error: Invalid level5-parameter!\n");  exit(189);}
    if (mod2_used && level5<=level2) 
       {fprintf(stderr,"Error: Invalid level5-parameter!\n");  exit(190);}
  }
  if (level5_used) {
    if (topdown) {
      if (!class5_used) {fprintf(stderr,"Error: Missing class5-parameter!\n");
                         exit(191);}
    }
    else {fprintf(stderr,"Error: Option 'level5' can only be used in "
                                   "topdown mode!\n");  exit(192);}
  } 
  if (old_class5_used || old_mod5_used) {
    alias4 = True;
    if (!topdown) {fprintf(stderr,"Error: Option 'old_mod5' can only be used"
                   " in topdown mode!\n");  exit(193);}
    if (!mod5_used) {fprintf(stderr,"Error: Option 'mod5' must be used when"
                     " using option 'old_mod5'!\n"); exit(194);}
    if (old_mod5 && !old_class5_used) 
       {fprintf(stderr,"Missing old_class5-parameter!\n"); exit(195);}
    if (!old_mod5_used) {fprintf(stderr,"Missing old_mod5-parameter!\n");
                         exit(196);}
    if (!old_mod5 && old_class5_used) {fprintf(stderr,"Option 'old_class5' can"
        " only be used when setting old_mod5>0!\n");  exit(222);}
    if (old_mod5 && (mod5%old_mod5)) 
       {fprintf(stderr,"Error: mod5-parameter must be a"
                       " multiple of old_mod5-parameter!\n");  exit(197);}
    if (old_mod5 && (class5-old_class5)%old_mod5) 
       {fprintf(stderr,"Error: The difference"
        " between the class5-parameter and the old_class5-parameter must be a"
        " multiple of the old_mod5-parameter!\n"); exit(198);}
    if (old_mod2_used || old_class2_used || old_mod3_used || old_class3_used ||
        old_mod4_used || old_class4_used)
       {fprintf(stderr,"Error: The options 'old_mod5' and 'old_mod2', "
                "'old_mod3' or 'old_mod4' must not be used simultaneously!\n");
                exit(199);}
    if (mod6_used) 
       {fprintf(stderr,"Error: Option 'old_mod5' cannot be used when using"
        " 'mod6'!\n");  exit(225);}
  }
  if (class6_used) {
    if (!mod6_used) {fprintf(stderr,"Missing mod6-parameter!\n"); exit(200);}
  }
  if (mod6_used) {
    if (mod6<1)    {fprintf(stderr,"Invalid mod6-parameter!\n"); exit(201);}
    if (!class6_used) {fprintf(stderr,"Missing class6-parameter!\n"); 
                       exit(202);}
    if (topdown && !td_limits_used) {fprintf(stderr,"Error: Option 'td_limits'"
        "MUST be used when using option 'mod6' in topdown mode!\n");
        exit(203);}  /* um einen Einheitlichen Stammpatch-Vorrat zu sichern */
    if (!topdown) {fprintf(stderr,"Error: Option 'mod6' can only be used in "
                           "topdown mode!\n");  exit(204);}
/*  if (do_bauchbinde) {fprintf(stderr,"Error: Option 'mod6' must not be used "
                        "when type-1-maps are allowed!\n"); exit(205);}*/
    if (mod5_used && level6<=level5) 
       {fprintf(stderr,"Error: Invalid level6-parameter!\n");  exit(206);}
    if (mod4_used && level6<=level4) 
       {fprintf(stderr,"Error: Invalid level6-parameter!\n");  exit(207);}
    if (mod3_used && level6<=level3) 
       {fprintf(stderr,"Error: Invalid level6-parameter!\n");  exit(208);}
    if (mod2_used && level6<=level2) 
       {fprintf(stderr,"Error: Invalid level6-parameter!\n");  exit(209);}
  }
  if (level6_used) {
    if (topdown) {
      if (!class6_used) {fprintf(stderr,"Error: Missing class6-parameter!\n");
                         exit(210);}
    }
    else {fprintf(stderr,"Error: Option 'level6' can only be used in "
                                   "topdown mode!\n");  exit(211);}
  } 
  if (old_class6_used || old_mod6_used) {
    alias5 = True;
    if (!topdown) {fprintf(stderr,"Error: Option 'old_mod6' can only be used"
                   " in topdown mode!\n");  exit(212);}
    if (!mod6_used) {fprintf(stderr,"Error: Option 'mod6' must be used when"
                     " using option 'old_mod6'!\n"); exit(213);}
    if (old_mod6 && !old_class6_used) 
       {fprintf(stderr,"Missing old_class6-parameter!\n"); exit(214);}
    if (!old_mod6_used) {fprintf(stderr,"Missing old_mod6-parameter!\n");
                         exit(215);}
    if (!old_mod6 && old_class6_used) {fprintf(stderr,"Option 'old_class6' can"
        " only be used when setting old_mod6>0!\n");  exit(223);}
    if (old_mod6 && (mod6%old_mod6)) 
       {fprintf(stderr,"Error: mod6-parameter must be a"
                       " multiple of old_mod6-parameter!\n");  exit(216);}
    if (old_mod6 && (class6-old_class6)%old_mod6) 
       {fprintf(stderr,"Error: The difference"
        " between the class6-parameter and the old_class6-parameter must be a"
        " multiple of the old_mod6-parameter!\n"); exit(217);}
    if (old_mod2_used || old_class2_used || old_mod3_used || old_class3_used ||
        old_mod4_used || old_class4_used || old_mod5_used || old_class5_used) 
       {fprintf(stderr,"Error: The options 'old_mod4' and 'old_mod2', "
                "'old_mod3', 'old_mod4', or 'old_mod5' must not be used"
                " simultaneously!\n");  exit(218);}
  }
  if (genus_end>0 && conn2!=conn3) 
     {fprintf(stderr,"Error: 2- and 3-connected maps can only be distinguished"
                     " in the planar case!\n");  exit(71);}
  if (patchcheck && ((!topdown && pv<10) || (topdown && !facerestrict)))
     {fprintf(stderr,"Error: Option 'patchcheck' is useless!\n");  exit(72);}
  if (patchcheck && topdown && genus_end>0) 
     {fprintf(stderr,"Error: Option 'patchcheck' cannot be used in topdown "
                   "mode if the maximum genus is larger than 0!\n"); exit(73);}
     /* damit es keine Komplikationen durch Speicherung von isomorphen 
        Raendern und so gibt */
  if (digon_path && do_bauchbinde) 
     {fprintf(stderr,"Error: Options 'type 1' and 'digon_path' used"
                     " simultaneously!\n"); exit(74);}    
  if (!save && lazydump_used) 
     {fprintf(stderr,"Error: Options 'save 0' and 'lazydump' used"
	      " simultaneously!\n"); exit(112);}

  /* gemeinsamen Teil aller Filenamen erstellen: */
  filenamenteil[0] = 0;     /* leeren */
  if (delaney) {strcat(filenamenteil,(char *)"_del");}
  if (!shortfilename_used) {
    for (i=0; i<MIN(12,anz_face); i++) {
      sprintf(strpuf,"_f%d",face[i]);
      strcat(filenamenteil,strpuf);
      if (delaney) {
        j = (int)dela_set[face[i]];
        sprintf(strpuf,"d%d",j==1 ? 1 : (j==2 ? 2 : (j==3 ? 12 : (j==4 ? 3 :
                            (j==5 ? 13 : (j==6 ? 23 : 123))))));
        strcat(filenamenteil,strpuf);
      }
      if (facenum_min_usr[i]>0) {
        sprintf(strpuf,"[%d",facenum_min_usr[i]);
        strcat(filenamenteil,strpuf);
      }
      if (facenum_max_usr[i]<F_MAXANZ) {
        sprintf(strpuf,"%s%d]",facenum_min_usr[i]>0 ? (char *)"," : 
                (char *)"_",facenum_max_usr[i]);
        strcat(filenamenteil,strpuf);
      }
    }
    if (!do_bauchbinde || !do_sandwich || !do_brille) {
      strcat(filenamenteil,(char *)"_t");
      if (do_bauchbinde) {strcat(filenamenteil,(char *)"1");}
      if (do_sandwich)   {strcat(filenamenteil,(char *)"2");}
      if (do_brille)     {strcat(filenamenteil,(char *)"3");}
    }
    if (priority_used) {sprintf(strpuf,"_p%d",prio);
                        strcat(filenamenteil,strpuf);}
    if (alternative)  {strcat(filenamenteil,(char *)"_alt");}
    if (!conn1 || !conn2 || !conn3) {
      strcat(filenamenteil,(char *)"_mc");
      if (conn1) {strcat(filenamenteil,(char *)"1");}
      if (conn2) {strcat(filenamenteil,(char *)"2");}
      if (conn3) {strcat(filenamenteil,(char *)"3");}
    }
    if (!facecon1 || !facecon2) {
      strcat(filenamenteil,(char *)"_fc");
      if (facecon1) {strcat(filenamenteil,(char *)"1");}
      if (facecon2) {strcat(filenamenteil,(char *)"2");}
      strcat(filenamenteil,(char *)"3");
    }
    if (patchconn) {strcat(filenamenteil,(char *)"_pcon");}
    if (patchcheck) {strcat(filenamenteil,(char *)"_pch");}
    if (dual) {strcat(filenamenteil,(char *)"_dual");}
    if (doppelkanten) {strcat(filenamenteil,(char *)"_db");}
    if (mdeza1_used) {strcat(filenamenteil,(char *)"_md1");}
  }
  if (fileindex)    {strcat(filenamenteil,(char *)"_");
                     strcat(filenamenteil,fileindex);}
  if (!shortfilename_used) {
    if (pv<PV_DEFAULT) {sprintf(strpuf,"_pv%d",pv);
                        strcat(filenamenteil,strpuf);}
    if (topdown) {strcat(filenamenteil,(char *)"_td");}
    if (td_limits) {      /* Benutzerlimits */
      for (i=0; i<=(int)genus_end; i++) {
        if (i>0) {strcat(filenamenteil,(char *)"_");}
        if (alternative) {sprintf(strpuf,"%d.%d",fmax_g_usr[i],bmax_g_usr[i]);}
        else {sprintf(strpuf,"%d.%d.%d",cmax_g_usr[i],fmax_g_usr[i],
                                        bmax_g_usr[i]);}
        strcat(filenamenteil,strpuf);
      }
    }
    else if (td_limits_auto) {strcat(filenamenteil,(char *)"l");}    
  }
  if (mod_used) {sprintf(strpuf,"_m%d.%d",class,mod);
                 strcat(filenamenteil,strpuf);}
  if (!topdown && level_used) {sprintf(strpuf,".%d",level);
                               strcat(filenamenteil,strpuf);}
  if (alias) {strcpy(filenamenteil2,filenamenteil);}
             /* fuer Recoverreadfilename */
  if (mod2_used) {sprintf(strpuf,"_M%d.%d",class2,mod2);
                  strcat(filenamenteil,strpuf);}
  if (topdown && level2_used) {sprintf(strpuf,".%d",level2);
                               strcat(filenamenteil,strpuf);}
  if (alias2) {strcpy(filenamenteil2,filenamenteil);}
      /* fuer Recoverreadfilename - alias und alias2 gleichzeitig geht nicht,
         ebenso wenig alias2 und mod4_used */
  if (mod3_used) {sprintf(strpuf,"_MM%d.%d",class3,mod3);
                  strcat(filenamenteil,strpuf);}
  if (topdown && level3_used) {sprintf(strpuf,".%d",level3);
                               strcat(filenamenteil,strpuf);}
  if (alias3) {strcpy(filenamenteil2,filenamenteil);}
     /* fuer Recoverreadfilename - alias2 und alias3 gleichzeitig geht nicht */
  if (mod4_used) {sprintf(strpuf,"_mm%d.%d",class4,mod4);
                  strcat(filenamenteil,strpuf);}
  if (topdown && level4_used) {sprintf(strpuf,".%d",level4);
                               strcat(filenamenteil,strpuf);}
  if (alias4) {strcpy(filenamenteil2,filenamenteil);}
     /* fuer Recoverreadfilename - alias3 und alias4 gleichzeitig geht nicht */
  if (mod5_used) {sprintf(strpuf,"_3m%d.%d",class5,mod5);
                  strcat(filenamenteil,strpuf);}
  if (topdown && level5_used) {sprintf(strpuf,".%d",level5);
                               strcat(filenamenteil,strpuf);}
  if (alias5) {strcpy(filenamenteil2,filenamenteil);}
     /* fuer Recoverreadfilename - alias4 und alias5 gleichzeitig geht nicht */
  if (mod6_used) {sprintf(strpuf,"_3M%d.%d",class6,mod6);
                  strcat(filenamenteil,strpuf);}
  if (topdown && level6_used) {sprintf(strpuf,".%d",level6);
                               strcat(filenamenteil,strpuf);}

  /* Logfile oeffnen: */
  if (logfile_out) {
    if (!l) {     /* Logfilenamen ermitteln */
      if (genus_anf!=genus_end) {
        if (n_anf!=n_end) {sprintf(logfilename,"3reg_g%d_gs%d_v%d_vs%d",
                                   genus_end,genus_anf,n_end,n_anf);}
        else {sprintf(logfilename,"3reg_g%d_gs%d_v%d",genus_end,genus_anf,
                      n_end);}
      }
      else {
        if (n_anf!=n_end) {sprintf(logfilename,"3reg_g%d_v%d_vs%d",genus_end,
                                   n_end,n_anf);}
        else {sprintf(logfilename,"3reg_g%d_v%d",genus_end,n_end);}
      }
      strcat(logfilename,filenamenteil);
      strcat(logfilename,(char *)".log");    
    }
    else {strcpy(logfilename,argv[l]);}
    /* Ab hier darf der Inhalt von "logfilename" nicht mehr veraendert werden,
       da das Logfile einige Male geoeffnet und geschlossen werden wird. */
    if (strlen(logfilename)>=FILENAME_MAX)
       {fprintf(stderr,"Error: Logfilename too long!\n");  exit(75);}
       /* falls das Programm wegen des zu langen Filenamens nicht sowieso schon
          vorher abgestuerzt ist */
    logfile = repeated_fopen(logfilename,recover ? "a" : "w",1);
    if (logfile==nil) {fprintf(stderr,"Cannot open file %s!\n",logfilename);
                     exit(76);}
    fclose(logfile);  
  }

  /* Recoverfilenamen erstellen: */
  if (recover || save) {
    if (genus_anf!=genus_end) {
      if (n_anf!=n_end) {sprintf(recoversavefilename,"3reg_g%d_gs%d_v%d_vs%d",
                                 genus_end,genus_anf,n_end,n_anf);}
      else {sprintf(recoversavefilename,"3reg_g%d_gs%d_v%d",genus_end,
                    genus_anf,n_end);}
    }
    else {
      if (n_anf!=n_end) {sprintf(recoversavefilename,
                         "3reg_g%d_v%d_vs%d",genus_end,n_end,n_anf);}
      else {sprintf(recoversavefilename,"3reg_g%d_v%d",genus_end,n_end);}
    }
    strcat(recoversavefilename,filenamenteil);
    strcat(recoversavefilename,(char *)".dump");    
    if (strlen(recoversavefilename)>=FILENAME_MAX)
       {fprintf(stderr,"Error: Recoverfilename too long!\n");  exit(77);}
    strcpy(recoverfilename_sk,recoversavefilename);
    strcat(recoverfilename_sk,(char *)"~");
    if (strlen(recoverfilename_sk)>=FILENAME_MAX)
       {fprintf(stderr,"Error: Recoverfilename too long!\n");  exit(78);}
    strcpy(recoverflagfilename,recoversavefilename);
    strcat(recoverflagfilename,(char *)".bsy");
    if (strlen(recoverflagfilename)>=FILENAME_MAX)
       {fprintf(stderr,"Error: Recoverfilename too long!\n");  exit(79);}

    if (alias) {     /* eigener recoverreadfilename */
      if (genus_anf!=genus_end) {
        if (n_anf!=n_end) {sprintf(recoverreadfilename,
                                   "3reg_g%d_gs%d_v%d_vs%d",
                                   genus_end,genus_anf,n_end,n_anf);}
        else {sprintf(recoverreadfilename,"3reg_g%d_gs%d_v%d",genus_end,
                      genus_anf,n_end);}
      }
      else {
        if (n_anf!=n_end) {sprintf(recoverreadfilename,
                         "3reg_g%d_v%d_vs%d",genus_end,n_end,n_anf);}
        else {sprintf(recoverreadfilename,"3reg_g%d_v%d",genus_end,n_end);}
      }
      strcat(recoverreadfilename,filenamenteil2);
      if (old_mod2) {
        sprintf(strpuf,"_M%d.%d",old_class2,old_mod2);
        strcat(recoverreadfilename,strpuf);
        if (level2_used) {sprintf(strpuf,".%d",level2);
                          strcat(recoverreadfilename,strpuf);}
      }
      strcat(recoverreadfilename,(char *)".dump");    
      if (strlen(recoverreadfilename)>=FILENAME_MAX)
         {fprintf(stderr,"Error: Recoverfilename too long!\n");  exit(123);}
    }
    else if (alias2) {     /* eigener recoverreadfilename */
      /* alias=True und alias2=True ist unmoeglich, ebenso wenig
         alias2=True und mod4_used=True (so dass dem recoverreadfilenamen
         nichts fehlt) */
      if (genus_anf!=genus_end) {
        if (n_anf!=n_end) {sprintf(recoverreadfilename,
                                   "3reg_g%d_gs%d_v%d_vs%d",
                                   genus_end,genus_anf,n_end,n_anf);}
        else {sprintf(recoverreadfilename,"3reg_g%d_gs%d_v%d",genus_end,
                      genus_anf,n_end);}
      }
      else {
        if (n_anf!=n_end) {sprintf(recoverreadfilename,
                         "3reg_g%d_v%d_vs%d",genus_end,n_end,n_anf);}
        else {sprintf(recoverreadfilename,"3reg_g%d_v%d",genus_end,n_end);}
      }
      strcat(recoverreadfilename,filenamenteil2);
      if (old_mod3) {
        sprintf(strpuf,"_MM%d.%d",old_class3,old_mod3);
        strcat(recoverreadfilename,strpuf);
        if (level3_used) {sprintf(strpuf,".%d",level3);
                          strcat(recoverreadfilename,strpuf);}
      }
      strcat(recoverreadfilename,(char *)".dump");    
      if (strlen(recoverreadfilename)>=FILENAME_MAX)
         {fprintf(stderr,"Error: Recoverfilename too long!\n");  exit(123);}
    }
    else if (alias3) {     /* eigener recoverreadfilename */
      /* alias2=True und alias3=True ist unmoeglich */
      if (genus_anf!=genus_end) {
        if (n_anf!=n_end) {sprintf(recoverreadfilename,
                                   "3reg_g%d_gs%d_v%d_vs%d",
                                   genus_end,genus_anf,n_end,n_anf);}
        else {sprintf(recoverreadfilename,"3reg_g%d_gs%d_v%d",genus_end,
                      genus_anf,n_end);}
      }
      else {
        if (n_anf!=n_end) {sprintf(recoverreadfilename,
                         "3reg_g%d_v%d_vs%d",genus_end,n_end,n_anf);}
        else {sprintf(recoverreadfilename,"3reg_g%d_v%d",genus_end,n_end);}
      }
      strcat(recoverreadfilename,filenamenteil2);
      if (old_mod4) {
        sprintf(strpuf,"_mm%d.%d",old_class4,old_mod4);
        strcat(recoverreadfilename,strpuf);
        if (level4_used) {sprintf(strpuf,".%d",level4);
                          strcat(recoverreadfilename,strpuf);}
      }
      strcat(recoverreadfilename,(char *)".dump");    
      if (strlen(recoverreadfilename)>=FILENAME_MAX)
         {fprintf(stderr,"Error: Recoverfilename too long!\n");  exit(160);}
    }
    else if (alias4) {     /* eigener recoverreadfilename */
      /* alias3=True und alias4=True ist unmoeglich */
      if (genus_anf!=genus_end) {
        if (n_anf!=n_end) {sprintf(recoverreadfilename,
                                   "3reg_g%d_gs%d_v%d_vs%d",
                                   genus_end,genus_anf,n_end,n_anf);}
        else {sprintf(recoverreadfilename,"3reg_g%d_gs%d_v%d",genus_end,
                      genus_anf,n_end);}
      }
      else {
        if (n_anf!=n_end) {sprintf(recoverreadfilename,
                         "3reg_g%d_v%d_vs%d",genus_end,n_end,n_anf);}
        else {sprintf(recoverreadfilename,"3reg_g%d_v%d",genus_end,n_end);}
      }
      strcat(recoverreadfilename,filenamenteil2);
      if (old_mod5) {
        sprintf(strpuf,"_3m%d.%d",old_class5,old_mod5);
        strcat(recoverreadfilename,strpuf);
        if (level5_used) {sprintf(strpuf,".%d",level5);
                          strcat(recoverreadfilename,strpuf);}
      }
      strcat(recoverreadfilename,(char *)".dump");    
      if (strlen(recoverreadfilename)>=FILENAME_MAX)
         {fprintf(stderr,"Error: Recoverfilename too long!\n");  exit(216);}
    }
    else if (alias5) {     /* eigener recoverreadfilename */
      /* alias4=True und alias5=True ist unmoeglich */
      if (genus_anf!=genus_end) {
        if (n_anf!=n_end) {sprintf(recoverreadfilename,
                                   "3reg_g%d_gs%d_v%d_vs%d",
                                   genus_end,genus_anf,n_end,n_anf);}
        else {sprintf(recoverreadfilename,"3reg_g%d_gs%d_v%d",genus_end,
                      genus_anf,n_end);}
      }
      else {
        if (n_anf!=n_end) {sprintf(recoverreadfilename,
                         "3reg_g%d_v%d_vs%d",genus_end,n_end,n_anf);}
        else {sprintf(recoverreadfilename,"3reg_g%d_v%d",genus_end,n_end);}
      }
      strcat(recoverreadfilename,filenamenteil2);
      if (old_mod6) {
        sprintf(strpuf,"_3M%d.%d",old_class6,old_mod6);
        strcat(recoverreadfilename,strpuf);
        if (level6_used) {sprintf(strpuf,".%d",level6);
                          strcat(recoverreadfilename,strpuf);}
      }
      strcat(recoverreadfilename,(char *)".dump");    
      if (strlen(recoverreadfilename)>=FILENAME_MAX)
         {fprintf(stderr,"Error: Recoverfilename too long!\n");  exit(217);}
    }
    else {strcpy(recoverreadfilename,recoversavefilename);}
  }
  strcpy(recoverreadflagfilename,recoverreadfilename);
  strcat(recoverreadflagfilename,(char *)".bsy");    
  if (strlen(recoverreadflagfilename)>=FILENAME_MAX)
     {fprintf(stderr,"Error: Recoverflagfilename too long!\n");  exit(174);}
  strcpy(recoverreadfilename_sk,recoverreadfilename);
  strcat(recoverreadfilename_sk,(char *)"~");    
  if (strlen(recoverreadfilename_sk)>=FILENAME_MAX)
     {fprintf(stderr,"Error: Recoverfilename too long!\n");  exit(175);}


  /* Ab hier darf der Inhalt von "logfilename" nicht mehr veraendert werden, 
     da das File einige Male geoeffnet und geschlossen wird. */

  /* entscheiden, ob normale oder alternative Patcherzeugung: */
  big_face = face[anz_face-1];       /* vorerst */
  small_face = face[0];              /* vorerst */
  if (big_face<7 || pv<11 /*|| topdown*/) {alternative = True;}

  /* Flaechenkombination vorpruefen, eventuell Grenzen genus_anf, genus_end,
     n_anf, n_end und facenum_max einschraenken: */ 
  if (face[0]==1 && facenum_min[0]>0 && conn1==False) {
    logfile_entry((char *)"No maps with loops and connectivity higher than 1" 
                  " and more than 2 vertices possible!\n",True,True,True); 
    if (n_anf>2) {exit(80);} else {n_end = 2;}
  }
  if (((face[0]==2 && facenum_min[0]>0) || (anz_face>1 && face[1]==2 &&
      facenum_min[1]>0)) && conn1==False && conn2==False) {
    logfile_entry((char *)"No maps with digons and connectivity higher than 2" 
                          " possible!\n",True,True,True);      exit(81);
  }
  if (genus_end>1 && big_face<7) {
    logfile_entry((char *)"No maps with genus higher than 1 possible!\n",
                  True,True,True);
    genus_end = 1;    /* Falls nun genus_end < genus_anf, so wird dies in der
                         Funktion "pruefe_flaechenkombinationen" bemerkt. */ 
  }
  if (genus_end>0 && big_face<6) {
    logfile_entry((char *)"No maps with genus higher than 0 possible!\n",
                  True,True,True);
    genus_end = 0;    /* Falls nun genus_end < genus_anf, so wird dies in der
                         Funktion "pruefe_flaechenkombinationen" bemerkt. */ 
  }
  if (genus_anf<1 && small_face>5) {
    logfile_entry((char *)"No maps with genus lower than 1 possible!\n",
                  True,True,True);
    genus_anf = 1;    /* Falls nun genus_end < genus_anf, so wird dies in der
                         Funktion "pruefe_flaechenkombinationen" bemerkt. */ 
  }
  if (genus_anf<2 && small_face>6) {
    logfile_entry((char *)"No maps with genus lower than 2 possible!\n",
                  True,True,True);
    genus_anf = 2;    /* Falls nun genus_end < genus_anf, so wird dies in der
                         Funktion "pruefe_flaechenkombinationen" bemerkt. */ 
  }
  if (alternative) {krit_min = 0;          krit_max = 0;}
  else             {krit_min = USHRT_MAX;  krit_max = 0;}             
  for (i=0; i<anz_face; i++) {   /* triviale Grenze fuer "facenum_max"
       ermitteln (beschleunigt "errechne_kombinationen") */
    if (face[i]<6)        /* kleine Flaeche */
      {facenum_max[i] = MIN(facenum_max[i],big_face<7 ? 12/(6-face[i]) :
                        ((big_face-6)*(n_end/2) + 2*big_face*(1-genus_anf))/
                         (big_face-face[i]));}
    else if (face[i]==6)    /* mittlere Flaeche */
      {facenum_max[i] = MIN(facenum_max[i],n_end/2);}   
            /* falls genus!=1: sogar weniger, aber da genus in Intervall 
               liegen kann, ist genauere Einschraenkung nicht moeglich */
    else         /* grosse Flaeche */
      {facenum_max[i] = MIN(facenum_max[i],small_face>5 ? 12*(genus_anf-1)/
         (face[i]-6) :    /* korrekt, da genus_anf>0 (siehe Abfrage oben) */
       ((6-small_face)*(n_end/2) + 2*small_face*((int)genus_end-1))/
        (face[i]-small_face));}
  } 

  initialisiere_arrays();  /* An dieser Stelle werden die Arrays initialisiert,
			      die in der folgenden Funktion gebraucht werden */
  if (pruefe_flaechenkombination(&genus_anf,&genus_end,&n_anf,&n_end,face,
        facenum_min,facenum_max,&anz_face)==False) {exit(82);}
     /* nun sind genus_anf, genus_end, n_anf und n_end so weit wie moeglich
        eingeschraenkt */
  if (topdown) {patcherzeugungsgrenzen();}
  big_face = face[anz_face-1];      /* endgueltig */
  small_face = face[0];             /* endgueltig */
  initialisiere_arrays2();  /* An dieser Stelle koennen die restlichen Arrays
                  initialisiert werden, weil alle "_usr"-Werte feststehen und
                               "big_face" einen Wert hat. */

  /* Erste regulaere Eintraege in das Logfile: */
  logfile_entry((char *)"Program call:  ",True,False,False);
  for (i=0; i<argc; i++) 
      {sprintf(strpuf,"%s ",argv[i]); logfile_entry(strpuf,False,False,False);}
  logfile_entry((char *)"\n\n",False,False,False);
  sprintf(strpuf,"Genus:     min %2d   max %2d\n"
                 "Vertices:  min %2d   max %2d\n"
                 "Permitted face degrees:  ",genus_anf,genus_end,n_anf,n_end);
  logfile_entry(strpuf,False,False,False);
  for (i=0; i<anz_face; i++) 
      {sprintf(strpuf,"%d ",face[i]); logfile_entry(strpuf,False,False,False);}
  logfile_entry((char *)"\n",False,True,False);
  if (td_limits_auto) {    /* Programm legt Grenzen fest: */
    logfile_entry((char *)"Bottom-up limits for patch generation:\n",
                  True,False,False);
    for (i=0; i<=(int)genus_end; i++) {
      if (alternative) {
        sprintf(strpuf,"  Genus %d:  %d face%s  (%d boundar%s)\n",i,fmax_g[i],
                fmax_g[i]==1 ? (char *)" " : (char *)"s",bmax_g[i],
                bmax_g[i]==1 ? (char *)"y" : (char *)"ies");    
      }
      else {
        sprintf(strpuf,"  Genus %d:  concave sum %2d,  %2d face%s "
                " (%d boundar%s)\n",i,cmax_g[i],fmax_g[i],
                fmax_g[i]==1 ? (char *)" " : (char *)"s",bmax_g[i],
                bmax_g[i]==1 ? (char *)"y" : (char *)"ies");   
      } 
      logfile_entry(strpuf,False,False,False);
    }
    logfile_entry((char *)"",False,True,False);
  }
  if (mod_used) {
    sprintf(strpuf,"Module: %d    Class: %d%s",mod,class,
            !topdown ? (char *)"" : (char *)"\n");
    logfile_entry(strpuf,True,True,False);
    if (!topdown) {sprintf(strpuf,"   Level: %d\n",level);
                   logfile_entry(strpuf,True,True,False);}
  }
  if (mod2_used)
    {sprintf(strpuf,"Module 2: %d    Class 2: %d    Level 2: %d\n",mod2,class2,
             level2);
     logfile_entry(strpuf,True,True,False);}
  if (mod3_used)
    {sprintf(strpuf,"Module 3: %d    Class 3: %d    Level 3: %d\n",mod3,class3,
             level3);
     logfile_entry(strpuf,True,True,False);}
  if (mod4_used)
    {sprintf(strpuf,"Module 4: %d    Class 4: %d    Level 4: %d\n",mod4,class4,
             level4);
     logfile_entry(strpuf,True,True,False);}
  if (mod5_used)
    {sprintf(strpuf,"Module 5: %d    Class 5: %d    Level 5: %d\n",mod5,class5,
             level5);
     logfile_entry(strpuf,True,True,False);}
  if (mod6_used)
    {sprintf(strpuf,"Module 6: %d    Class 6: %d    Level 6: %d\n",mod6,class6,
             level6);
     logfile_entry(strpuf,True,True,False);}

  /* "bk_moeglich", "kp_moeglich", "kp" und "kpk" initialisieren 
     (nur topdown): */ 
  if (topdown) {
    for (i = (int)genus_anf_usr; i <= (int)genus_end_usr; i++) {
      for (j = (int)n_anf_usr; j <= (int)n_end_usr; j+=2) {
        if (is_moeglich[ARRAYPOS_N(i,j)]) {
          dummybool = errechne_kombinationen(anz_face-1,anz_face,0,facenum,
                      facenum_min,facenum_max,(KNOTENTYP)(j/2+2-2*i),
  	              (KNOTENTYP)i,nil,nil,face,2);
          if (!dummybool) 
             {fprintf(stderr,"Logischer Fehler in main!\n");  exit(70);}
        }
      }
    }  
    for (i=0; i<=(int)n_end_usr/2+2; i++) {   /* "kp" erstellen */
      for (j=0; j<=(int)bk_max; j++) {
        for (k=0; k<=(int)krit_max; k++) {
          if (IS_KP_MOEGLICH(i,j,k)) {kp_anz[i][j]++;}
        }
        if (kp_anz[i][j]) {        /* Liste erstellen */
          int anz = 0;
          kp[i][j] = (KNOTENTYP *)hole_speicher(sizeof(KNOTENTYP)*
                                                kp_anz[i][j],False,True);
          for (k=0; k<=(int)krit_max; k++) {
            if (IS_KP_MOEGLICH(i,j,k)) {kp[i][j][anz++] = k;}
          }
        }
      }
    }
  }   

  if (small_face==1) {einecke = True;}
  if (small_face==2 || (anz_face>1 && face[1]==2)) {zweiecke = True;}
  if (digon_path && einecke)  /* nicht erlaubt, weil dann die Einschraenkung,
      dass kein Patch alle Zweiecke besitzen darf, nicht gilt */
     {sprintf(strpuf,"Error: No 1-gons are allowed when using option "
                   "'digon_path'!\n"); 
      logfile_entry(strpuf,True,True,True);  exit(83);}
  if (digon_path && !((face[0]==2 && facenum_min[0]) ||
        (anz_face>1 && face[1]==2 && facenum_min[1])))
     {sprintf(strpuf,"Error: 2-gons are indispensable when using option "
                     "'digon_path'!\n");  
      logfile_entry(strpuf,True,True,True);  exit(84);}
 
  /* genus_anf_fd, genus_end_fd, f_anf, f_max und n_max belegen: */
  genus_anf_fd = 12 - (EULERTYP)genus_anf*12;
  genus_end_fd = 12 - (EULERTYP)genus_end*12;  
  for (i=(int)genus_anf; i<=(int)genus_end; i++) {
    f_max[i] = n_end/2 + 2 - 2*i;   /* Obergrenze fuer Patches/Graphen */
    f_anf[i] = n_anf/2 + 2 - 2*i;   /* reale Untergrenze fuer Graphen */
  }    /* absolute Obergrenze: f_max[genus_anf], 
          absolute Untergrenze: f_anf[genus_end] */
  if (f_max[genus_anf]>F_MAXANZ)
     {sprintf(strpuf,"Error: Face number %d is too big (maximum %d)!\n",
      f_max[genus_anf],F_MAXANZ); logfile_entry(strpuf,True,True,True); 
      exit(85);}
  n_max = 3*n_end;           /* theoretische Obergrenze fuer Patches */
  if (n_max>N_MAX_P)
     {sprintf(strpuf,"Error: Intermediate vertex number %d is too big "
      "(maximum %d)!\n",n_max,N_MAX_P); logfile_entry(strpuf,True,True,True); 
      exit(86);}
  
  /* Intervalle fuer Flaechenzahlen ausgeben: */
  logfile_entry((char *)"\nLimits for faces of certain degrees"
                " (face/min/max):\n",True,False,False);
  for (i=0; i<anz_face; i++)
      {sprintf(strpuf,"%3d : %3d %3d\n",face[i],facenum_min[i],
               facenum_max[i]);  logfile_entry(strpuf,False,False,False);}
  logfile_entry((char *)"\n",False,True,False);   

  if (face[0]==1 && facenum_min[0]) {   /* mindestens ein 1-Eck */
    loop_brille = True; /* Nur ein Brillenpfad, der ein Eineck einschliesst,
      kann kanonisch sein, weil an jedem Eineck ein Brillenpfad mit einem Code
      beginnt, der trivialerweise jeden Code eines Brillenpfades unterbietet, 
      der kein Eineck umschliesst (weil l1==1, "l1" wird zuerst codiert). */
    if (brillenkennung==1) {
      /* kanonischer Pfad ist immer ein Brillenpfad, da an jedem Eineck ein
         Brillenpfad beginnt. */
      if (!do_brille) {logfile_entry((char *)"No maps possible - canonical "
                       "Petrie path is always a type-3 path!\n",True,True,
                       True);   exit(87);}
      else {
        do_bauchbinde = do_sandwich = False;
        logfile_entry((char *)"\nGood news: No type-1 and type-2 maps need "
                              "to be constructed.\n",True,True,False);
      }
    }
  }

  if (!conn2 && !conn3) {   /* nur 1-fach-zsh. Karten => jede Karte enthaelt
                               einen Brillenpfad (ueber die Bruecke) */
    if (brillenkennung==1) {  /* kanonischer Pfad ist immer ein Brillenpfad */
      if (!do_brille) {logfile_entry((char *)"No maps possible - canonical "
                       "Petrie path is always a type-3 path!\n",True,True,
                       True);   exit(92);}
      else {
        do_bauchbinde = do_sandwich = False;
        logfile_entry((char *)"\nGood news: No type-1 and type-2 maps need "
                              "to be constructed.\n",True,True,False);
      }
    }
    if (small_face>2 && big_face<8) 
       {logfile_entry((char *)"No maps possible - no face can touch itself!\n",
                      True,True,True);   exit(93);}
  }

  if (bauchbindenkennung==3 && ((face[0]==2 && facenum_min[0]) ||
                           (anz_face>1 && face[1]==2 && facenum_min[1]))) { 
    /* kanonischer Pfad ist immer ein Brillen- oder Sandwichpfad: ist klar,
       falls 2-Eck kleinste Flaeche, da dann immer ein Brillen- oder
       Sandwichpfad in der Karte auftritt. Falls 2-Eck zweitkleinste Flaeche, 
       dann besitzt jede Karte entweder ein 1-Eck (=> keine Bauchbinde und kein
       Sandwich ist kanonisch) oder n.V. mindestens ein 2-Eck 
       (=> keine Bauchbinde ist kanonisch). */
    if (!do_brille && !do_sandwich) 
       {logfile_entry((char *)"No maps possible - canonical "
        "Petrie path is always a type-2 or type-3 path!\n",True,True,True);  
        exit(88);}
    if (do_bauchbinde) {
      do_bauchbinde = False;
      logfile_entry((char *)"\nGood news: No type-1 patches and maps need to "
                            "be constructed.\n",True,True,False);
    }
    if (do_sandwich && brillenkennung < sandwichkennung) {l1_sandwich = True;}
       /* Nur Sandwiches, bei denen l1==1 und l2==1 gilt,
          koennen kanonisch sein (wenn ausserdem kein Eineck in der Karte 
          vorhanden ist), denn:  In der Karte ist mindestens ein Zweieck.
          An jedem Zweieck beginnt ein Sandwich- oder
          Brillenpfad, dessen erste beide Kanten dieses Zweieck umschliessen. 
          Wenn es sich um einen Brillenpfad handelt, so ist dieser sowieso 
          besser als jeder Sandwichpfad. Handelt es sich um einen Sandwichpfad,
          so ist l1==1, l2==1 und das Zweieck ist ein Nebenpatch. */
    if (do_brille && sandwichkennung < brillenkennung && !loop_brille) 
       {digon_brille = True;}
       /* Nur Brillen, die ein Zweieck einschliessen, koennen kanonisch sein,
          denn:  In der Karte ist mindestens ein Zweieck. An jedem Zweieck
          beginnt ein Sandwich- oder Brillenpfad, dessen erste beide Kanten
          dieses Zweieck umschliessen. 
          Wenn es sich um einen Sandwichpfad handelt, so ist
          dieser sowieso besser als jeder Brillenpfad. Handelt es sich um
          einen Brillenpfad, so ist dieser besser als jeder Brillenpfad, der
          kein Zweieck einschliesst. Wenn ausserdem noch Einecke erlaubt (aber
          nicht obligatorisch) sind,
          so koennen Brillenpfade, die ein Eineck umschliessen, ebenfalls
          kanonisch sein. Dies wird in "top_down_generierung" und auch bei
          der bottom-up-Konstruktion beruecksichtigt.
          Insgesamt muss einfach "l1<=2" gelten, falls Einecke erlaubt sind,
          und "l1==2", falls keine Einecke erlaubt sind. */
  }

  if (do_bauchbinde) {
    f_max_bb = 0;
    for (i=(int)genus_anf; i<=(int)genus_end; i+=2) {
      for (j=(int)n_anf; j<=(int)n_end; j+=2) {
        if (is_moeglich[ARRAYPOS_N(i,j)]) {  
          /* evtl. neues Maximum fuer "f_max_bb_best" */ 
          if (bauchbindenkennung<3 || i>0 || j%4==0) 
             {f_max_bb = MAX(f_max_bb,(KNOTENTYP)(j/2+2-2*i));}
             /* bestbewertete BB mit f_max_bb Flaechen moeglich */
        }
      }
    }
    if (f_max_bb==0) {      /* keine bestbewerteten Bauchbindenpfade */
      do_bauchbinde = False;
      logfile_entry((char *)"\nGood news: No type-1 patches and maps need to "
                            "be constructed.\n",True,True,False);
    }
  }

  /* Recoverfile (dump-File) oeffnen: NACH der Initialisierung, da diese 
     die Zaehler loescht. */
  if (recover) {lies_dumpfile();}
  if (output) {                      /* Outputfile(s) oeffnen */
    for (i=(int)genus_anf; i<=(int)genus_end; i++) {
      for (j=(int)n_anf; j<=(int)n_end; j+=2) {
        k = ARRAYPOS_N(i,j);
        sprintf(outputfilename[k],"3reg_g%d_v%d",i,j);
        strcat(outputfilename[k],filenamenteil);
        strcat(outputfilename[k],(char *)".ec");
        if ((j==(int)n_end && i==(int)genus_end && standardout) || 
            standardout_all) {outputfile[ARRAYPOS_N(i,j)] = 2;}
        else {
          if (strlen(outputfilename[k])>=FILENAME_MAX)
             {fprintf(stderr,"Error: Filename too long!\n");  exit(89);}
          outputfile[ARRAYPOS_N(i,j)] = 1;
          if (!recover) {      /* sonst ist Header doppelt */
             /* "!recover" kann gelten, weil "no_recover" benutzt wurde, oder
                weil kein dumpfile gefunden wurde. Deshalb Outputfiles erst
                an dieser Stelle oeffnen */
            if ((f = repeated_fopen(outputfilename[k],"wb",5))==nil)
               {fprintf(stderr,"Cannot open file %s!\n",outputfilename[k]);
                exit(90);}
	    if (bigendian) {fprintf(f,">>embed_code be<<");}
            else           {fprintf(f,">>embed_code le<<");}
                           /* siehe "schreibe_planarcode" */
            fclose(f);
          }
        }
      }   /* for j */
    }     /* for i */ 
    if (standardout || standardout_all) {
      if (bigendian) {fprintf(stdout,">>embed_code be<<");}
      else           {fprintf(stdout,">>embed_code le<<");} 
    }
       /* nur einmal fuer alle stdout-Kanaele, da sonst Ausgabe unbrauchbar
          wuerde, aber auch nach Recovern, damit das Empfangsprogramm wie
          gewohnt einen Header erhaelt */
  }     /* if output */
  /* Ab hier darf der Inhalt von "outputfilename" nicht mehr veraendert werden,
     da die Files einige Male geoeffnet und geschlossen werden. */

  /* Patcherzeugungsgrenzen uebernehmen: */
  /* die Patcherzeugungsgrenzen sind evtl. schon einmal nach unten
     korrigiert worden. Deshalb gleich die korrigierten Grenzen nehmen.
     Dies spart im Zweifelsfalle Zeit, denn einige Patches, bei deren
     Speicherung der Speicher ueberfuellt wird, werden nicht noch einmal
     konstruiert. Auch wenn beim Recovern mehr Speicher zur Verfuegung steht
     als vorher, ist das Ausnutzen desselben natuerlich nicht erlaubt: die
     Patcherzeugungsgrenzen muessen beibehalten werden. Wenn sie nicht
     beibehalten werden koennen, weil WENIGER Speicher als beim ersten
     Durchlauf zur Verfuegung steht, dann wird dies nach der Patcherzeugung
     bemerkt und das Recovern scheitert. */
  if (topdown && recover) {  
     /* Wert von "recover" kann sich durch "lies_dumpfile" veraendert haben */
    for (i=0; i<=genus_end_usr; i++) 
        {fmax_g[i] = fmax_g_rec[i];   bmax_g[i] = bmax_g_rec[i];
         cmax_g[i] = cmax_g_rec[i];}   /* vorerst */
  }
  
  if ((alias || alias2 || alias3 || alias4 || alias5) && recover) {      
    /* bisherige Ergebnisse ausgeben */
    logfile_entry((char *)"\nResults of the old process:\n",
                  True,False,False);
    i=(int)g_rec;
    j=(int)n_rec;
    if (is_moeglich[ARRAYPOS_N(i,j)]) {    /* es gibt theoretisch Graphen */
      if (graphstat) {
        if (do_bauchbinde) {
          sprintf(strpuf,"\nConstructed %d map%s with genus %d and"
                             " %d vertices along type-1 Petrie paths,"
                             " accepted %d.",
                  graphenzahl[ARRAYPOS_LN(i,j,1)],
                  graphenzahl[ARRAYPOS_LN(i,j,1)]==1 ? (char *)"" :
                  (char *)"s",i,j,
                  non_iso_graphenzahl[ARRAYPOS_LN(i,j,1)]);
          logfile_entry(strpuf,False,False,False);
          graphenzahl[ARRAYPOS_LN(i,j,1)]=0L;
        }
        if (do_sandwich) {
          sprintf(strpuf,"\nConstructed %d map%s with genus %d and"
                             " %d vertices along type-2 Petrie paths,"
                             " accepted %d.",
                  graphenzahl[ARRAYPOS_LN(i,j,2)],
                  graphenzahl[ARRAYPOS_LN(i,j,2)]==1 ? (char *)"" :
                  (char *)"s",i,j,
                  non_iso_graphenzahl[ARRAYPOS_LN(i,j,2)]);
          logfile_entry(strpuf,False,False,False);
          graphenzahl[ARRAYPOS_LN(i,j,2)]=0L;
        }
        if (do_brille) {
          sprintf(strpuf,"\nConstructed %d map%s with genus %d and"
                             " %d vertices along type-3 Petrie paths,"
                             " accepted %d.",
                  graphenzahl[ARRAYPOS_LN(i,j,3)],
                  graphenzahl[ARRAYPOS_LN(i,j,3)]==1 ? (char *)"" :
                  (char *)"s",i,j,
                  non_iso_graphenzahl[ARRAYPOS_LN(i,j,3)]);
          logfile_entry(strpuf,False,False,False);
          graphenzahl[ARRAYPOS_LN(i,j,3)]=0L;
        }
      }
      sprintf(strpuf,"\n%sConstructed %d non-isomorphic map%s with %d "
          "vertices.\n",graphstat ? (char *)"=> " : (char *)"",
          non_iso_graphenzahl[ARRAYPOS_LN(i,j,1)] + 
          non_iso_graphenzahl[ARRAYPOS_LN(i,j,2)] +
          non_iso_graphenzahl[ARRAYPOS_LN(i,j,3)],
          non_iso_graphenzahl[ARRAYPOS_LN(i,j,1)] + 
          non_iso_graphenzahl[ARRAYPOS_LN(i,j,2)] +
          non_iso_graphenzahl[ARRAYPOS_LN(i,j,3)]==1 ? (char *)"" : 
          (char *)"s", j);
      logfile_entry(strpuf,False,False,False);
      non_iso_graphenzahl[ARRAYPOS_LN(i,j,1)]=
      non_iso_graphenzahl[ARRAYPOS_LN(i,j,2)]=
      non_iso_graphenzahl[ARRAYPOS_LN(i,j,3)]=0L;
      if (do_conn) { 
        logfile_entry((char *)"\n   (",False,False,False);
        if (conn1) {
          sprintf(strpuf,"1-connected: %d",connzahl[ARRAYPOS_LN(i,j,1)]);
          logfile_entry(strpuf,False,False,False);        
        }
        if (conn2) {
          sprintf(strpuf,"%s2%s-connected: %d",
                  conn1 ? (char *)",  " : (char *)"",
                  genus_end>0 ? (char *)"/3" : (char *)"",
                  connzahl[ARRAYPOS_LN(i,j,2)]);
          logfile_entry(strpuf,False,False,False);        
        }
        if (genus_end==0 && conn3) {
          sprintf(strpuf,"%s3-connected: %d",
                  (conn1 || conn2) ? (char *)",  " : (char *)"",
                  connzahl[ARRAYPOS_LN(i,j,3)]);
          logfile_entry(strpuf,False,False,False);        
        }
        logfile_entry((char *)")",False,False,False);
        connzahl[ARRAYPOS_LN(i,j,1)]=
        connzahl[ARRAYPOS_LN(i,j,2)]=
        connzahl[ARRAYPOS_LN(i,j,3)]=0L;
      }       /* if do_conn */
    }         /* if is_moeglich */
#ifndef NOTIMES
    sprintf(strpuf,"\nGeneration time: %.1f seconds.\n\n",
           (double)prevtime/time_factor);
    logfile_entry(strpuf,False,True,False);
#endif //NOTIMES
  }

  /* Signal setzen, falls dump-Files erzeugt werden sollen: */
#ifndef NOTIMES
  if (save) setup();
#endif //NOTIMES

  /* Jetzt geht's los: */
  /* Patches erzeugen */
  generiere_patches();
#ifndef NOTIMES
  dummy = times(&TMS);
  savetime = TMS.tms_utime;
  sprintf(strpuf,"Time for generating the patches: %.1f seconds\n"
                 "Number of stored patches: %ld\n",
                 (double)savetime/time_factor,patches);
#else
  sprintf(strpuf,"Number of stored patches: %ld\n",patches);
#endif //NOTIMES

  logfile_entry(strpuf,True,True,False);
#ifdef __FreeBsd__
  space_info = mallinfo();   /* auch wenn "memory" nicht benutzt wird */
  sprintf(strpuf,"Memory consumption: %ld bytes\n",
          (long)space_info.usmblks+space_info.uordblks);
  logfile_entry(strpuf,True,True,False);
#endif
  if (topdown && (memory_used || memory_overflow)) {
    if (memory_overflow && (mod2_used || mod3_used || mod4_used || mod5_used ||
        mod6_used))
       {logfile_entry((char *)"Error:  Not enough memory to reach"
        " topdown limits (fatal when using option 'mod')!\n",True,
        True,True);  exit(114);}  /* Weil einheitlicher Stammpatch-
        Vorrat nicht gewaehrleistet ist. Bei mod_used ist kein einheitlicher
        Stammpatchvorrat erforderlich, da in Level 0 noch keine Patches
        gesucht werden. */
    logfile_entry((char *)"Bottom-up limits for patch generation:\n",
                  True,False,False);
    for (i=0; i<=(int)genus_end; i++) {
      if (alternative) {
        sprintf(strpuf,"  Genus %d:  %2d face%s  (%d boundar%s)\n",i,
                fmax_g[i],fmax_g[i]==1 ? (char *)" " : (char *)"s",bmax_g[i],
                bmax_g[i]==1 ? (char *)"y" : (char *)"ies");   
      }
      else {
        sprintf(strpuf,"  Genus %d:  concave sum %2d,  %2d face%s "
                " (%d boundar%s)\n",i,cmax_g[i],fmax_g[i],
                fmax_g[i]==1 ? (char *)" " : (char *)"s",bmax_g[i],
                bmax_g[i]==1 ? (char *)"y" : (char *)"ies");   
      } 
      logfile_entry(strpuf,False,False,False);
    }
    logfile_entry((char *)"",False,True,False);
  }
     
  if (patchstat) {
    logfile_entry((char *)"\nStored patches sorted by canonical zig-zag"
                  " paths:",True,False,False);
    sprintf(strpuf,"\nintersection: %6ld",nahttyp[0]);
    logfile_entry(strpuf,False,False,False);
    sprintf(strpuf,"\nenclosure:    %6ld",nahttyp[1]);
    logfile_entry(strpuf,False,False,False);
    sprintf(strpuf,"\nlinkage:      %6ld",nahttyp[2]);
    logfile_entry(strpuf,False,False,False);
    sprintf(strpuf,"\nnone:         %6ld",anz_face);
    logfile_entry(strpuf,False,False,False);
    logfile_entry((char *)"\n\nPatches sorted by genus and inner faces"
           " (row: #inner faces, column: genus):\n    |",False,False,False);
    for (j=0; j<=(int)genus_end; j++) 
        {sprintf(strpuf,"%6d",j);  logfile_entry(strpuf,False,False,False);}
    logfile_entry((char *)"\n----+-",False,False,False);
    for (j=0; j<=(int)genus_end; j++) 
        {logfile_entry((char *)"------",False,False,False);}
    for (i=1; i<=(int)f_max[genus_anf]; i++) {
      sprintf(strpuf,"\n%3d |",i);  logfile_entry(strpuf,False,False,False);
      for (j=0; j<=(int)genus_end; j++) {
        sprintf(strpuf,"%6d",patch_anz[ARRAYPOS_F(j,i)]);
        logfile_entry(strpuf,False,False,False);
      }
    }
    logfile_entry((char *)"\n\n",False,True,False);
  }

  if (recover && topdown) {    /* Patcherzeugungsgrenzen ueberpruefen: */
    for (i=0; i<=(int)genus_end; i++) {
      if (fmax_g[i]!=fmax_g_rec[i] || bmax_g[i]!=bmax_g_rec[i] ||
          cmax_g[i]!=cmax_g_rec[i]) {
        logfile_entry((char *)"Error while recovering: Not enough memory"
                      " to store the required patches!\n",True,True,True);
        exit(91);
      }
    }
  }     

  /* Karten erzeugen: */
  /* Fuer bottom-up gilt: Wenn die "normale" Kartengenerierung bereits 
     erreicht wurde, so ist "recover_hislen==0", so dass beim Recovern keine 
     Rekursion eingeleitet wird. */
  for (i=recover ? (int)g_rec : (int)genus_anf; i<=(int)genus_end; i++) {
    for (j=recover ? (int)n_rec : (int)n_anf; j<=(int)n_end; j+=2) {
      if (is_moeglich[ARRAYPOS_N(i,j)]) {    /* es gibt theoretisch Graphen */

        if (topdown) {top_down_generierung((KNOTENTYP)i,(KNOTENTYP)j);}
        else {
          /* Teil 1: */
          if (do_bauchbinde && (bauchbindenkennung<3 || i>0 || j%4==0) &&
              (!recover || pfadtyp_rec==1)) { 
            bilde_graphen_aus_bauchbindenpatches((KNOTENTYP)i,(KNOTENTYP)j);
#ifndef NOTIMES
            dummy = times(&TMS);
            buffertime = TMS.tms_utime;
            if (graphstat) {
              sprintf(strpuf,"\nConstructed %d map%s with genus %d and"
                             " %d vertices along type-1 Petrie paths in"
                             " %.1f seconds, accepted %d.",
                      graphenzahl[ARRAYPOS_LN(i,j,1)],
                      graphenzahl[ARRAYPOS_LN(i,j,1)]==1 ? (char *)"": 
                      (char *)"s",i,j,
                      (double)(buffertime-savetime)/time_factor,
                      non_iso_graphenzahl[ARRAYPOS_LN(i,j,1)]);
              logfile_entry(strpuf,True,True,False);
              savetime = buffertime;
#else
            if (graphstat) {
              sprintf(strpuf,"\nConstructed %d map%s with genus %d and"
                             " %d vertices along type-1 Petrie paths,"
                             " accepted %d.",
                      graphenzahl[ARRAYPOS_LN(i,j,1)],
                      graphenzahl[ARRAYPOS_LN(i,j,1)]==1 ? (char *)"": 
                      (char *)"s",i,j,
                      non_iso_graphenzahl[ARRAYPOS_LN(i,j,1)]);
              logfile_entry(strpuf,True,True,False);
#endif //NOTIMES
            }
          }
          /* Teil 2: */
          if ((do_sandwich || do_brille) && (!recover || pfadtyp_rec>1)) {
            bilde_graphen_aus_bruchkantenpatches((KNOTENTYP)i,(KNOTENTYP)j);
#ifndef NOTIMES
            dummy = times(&TMS);
            buffertime = TMS.tms_utime; 
            if (graphstat) {
              sprintf(strpuf,"\nConstructed %d map%s with genus %d and"
                  " %d vertices along type-2 Petrie paths in"
                  " %.1f seconds, accepted %d.\nConstructed %d" 
                  " map%s with genus %d and %d vertices along type-3 Petrie"
                  " paths, accepted %d.",
                      graphenzahl[ARRAYPOS_LN(i,j,2)],
                      graphenzahl[ARRAYPOS_LN(i,j,2)]==1 ? (char *)"": 
                      (char *)"s",i,j,
                      (double)(buffertime-savetime)/time_factor,
                      non_iso_graphenzahl[ARRAYPOS_LN(i,j,2)],
                      graphenzahl[ARRAYPOS_LN(i,j,3)],
                      graphenzahl[ARRAYPOS_LN(i,j,3)]==1 ? (char *)"": 
                      (char *)"s",i,j,
                      non_iso_graphenzahl[ARRAYPOS_LN(i,j,3)]);
              logfile_entry(strpuf,True,True,False);
              savetime = buffertime;
#else
            if (graphstat) {
              sprintf(strpuf,"\nConstructed %d map%s with genus %d and"
                  " %d vertices along type-2 Petrie paths,"
                  " accepted %d.\nConstructed %d" 
                  " map%s with genus %d and %d vertices along type-3 Petrie"
                  " paths, accepted %d.",
                      graphenzahl[ARRAYPOS_LN(i,j,2)],
                      graphenzahl[ARRAYPOS_LN(i,j,2)]==1 ? (char *)"": 
                      (char *)"s",i,j,
                      non_iso_graphenzahl[ARRAYPOS_LN(i,j,2)],
                      graphenzahl[ARRAYPOS_LN(i,j,3)],
                      graphenzahl[ARRAYPOS_LN(i,j,3)]==1 ? (char *)"": 
                      (char *)"s",i,j,
                      non_iso_graphenzahl[ARRAYPOS_LN(i,j,3)]);
              logfile_entry(strpuf,True,True,False);
#endif //NOTIMES
            }
          }
        }

        /* Statistik: */
        sprintf(strpuf,"\n%sConstructed %d non-isomorphic map%s with %d "
          "vertices.\n",graphstat ? (char *)"=> " : (char *)"",
          non_iso_graphenzahl[ARRAYPOS_LN(i,j,1)] + 
          non_iso_graphenzahl[ARRAYPOS_LN(i,j,2)] +
          non_iso_graphenzahl[ARRAYPOS_LN(i,j,3)],
          non_iso_graphenzahl[ARRAYPOS_LN(i,j,1)] + 
          non_iso_graphenzahl[ARRAYPOS_LN(i,j,2)] +
          non_iso_graphenzahl[ARRAYPOS_LN(i,j,3)]==1 ? (char *)"" : 
          (char *)"s", j);
        logfile_entry(strpuf,True,True,False);
        if (do_conn) { 
          logfile_entry((char *)"\n   (",True,False,False);
          if (conn1) {
            sprintf(strpuf,"1-connected: %d",connzahl[ARRAYPOS_LN(i,j,1)]);
            logfile_entry(strpuf,False,False,False);        
          }
          if (conn2) {
            sprintf(strpuf,"%s2%s-connected: %d",
                    conn1 ? (char *)",  " : (char *)"",
                    genus_end>0 ? (char *)"/3" : (char *)"",
                    connzahl[ARRAYPOS_LN(i,j,2)]);
            logfile_entry(strpuf,False,False,False);        
          }
          if (genus_end==0 && conn3) {
            sprintf(strpuf,"%s3-connected: %d",
                    (conn1 || conn2) ? (char *)",  " : (char *)"",
                    connzahl[ARRAYPOS_LN(i,j,3)]);
            logfile_entry(strpuf,False,False,False);        
          }
          logfile_entry((char *)")",False,True,False);
        }       /* if do_conn */
      }         /* if is_moeglich */
    }          /* for j */
  }           /* for i */

  /* Restliche Ausgabe: */
#ifndef NOTIMES
  dummy = times(&TMS);
  buffertime = TMS.tms_utime;
  sprintf(strpuf,"\nTotal generation time: %.1f seconds.\n",
          (double)(buffertime+prevtime)/time_factor);
  logfile_entry(strpuf,True,True,False);
#endif //NOTIMES

  if (facestat) {       /* Flaechenstatistik */
    FLAECHENTYP faces[MAXFTYPEN];
    logfile_entry((char *)"\nMaps sorted by degree sets:\n",True,False,
                  False);
    gehe_facestatbaum_durch(facestatbaum,faces,0);
    logfile_entry((char *)"",False,True,False);    /* logfile schliessen */
  }
  
  if (pv_used || patchstat) {
    sprintf(strpuf,"Used patches: %d\n",gute_basen);
    logfile_entry(strpuf,True,True,False);
  }

  /* Restliche in der Outputliste verbliebene Graphen ausgeben: */
  speichere_graphen_aus_outputliste_in_files(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);

  if (save) 
     {schreibe_dumpfile(True,0,recoverdata,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);}  
     /* das ist wichtig, damit man von dem vorangegangenen Dumpfile aus keinen 
        Restart mehr vornehmen kann, der die Ausgabedateien beeinflusst */
  exit(0);
}


